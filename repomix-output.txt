This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T17:32:58.012Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
pipe-core/
  package.json
  tsconfig.json
scripts/
  test-api.ts
  test-basic-operations.ts
  test-bundles.ts
  test-encryption.ts
src/
  tests/
    pipe.test.ts
  api.ts
  encryption.ts
  index.ts
  ipfsClient.ts
  pipe.ts
  schema.ts
  types.ts
.gitignore
jest.config.cjs
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: pipe-core/package.json
================
{
  "name": "pipe-core",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.13.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "helia": "^5.2.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "typescript": "^5.7.3",
    "zod": "^3.24.1"
  }
}

================
File: pipe-core/tsconfig.json
================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2016",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  }
}

================
File: scripts/test-api.ts
================
import { PipeProtocol } from '../src/pipe.js';
import { createApi } from '../src/api.js';
import { AddressInfo } from 'net';
import { request } from 'http';
import { Server } from 'http';

async function testApi() {
  console.log('Starting API test...\n');
  
  const pipe = new PipeProtocol({});
  const app = createApi(pipe);
  let server: Server;

  try {
    // Start the API server
    server = app.listen(0); // Use port 0 to get a random available port
    const address = server.address() as AddressInfo;
    const port = address.port;
    console.log(`API server started on port ${port}\n`);

    // Helper function to make API requests
    async function makeRequest(method: string, path: string, body?: any): Promise<{ status: number; data: any }> {
      return new Promise((resolve, reject) => {
        const options = {
          hostname: 'localhost',
          port: port,
          path: path,
          method: method,
          headers: {
            'Content-Type': 'application/json'
          }
        };

        const req = request(options, (res) => {
          let data = '';
          res.on('data', chunk => data += chunk);
          res.on('end', () => {
            try {
              resolve({
                status: res.statusCode || 500,
                data: data ? JSON.parse(data) : null
              });
            } catch (error) {
              resolve({
                status: res.statusCode || 500,
                data: null
              });
            }
          });
        });

        req.on('error', (error) => {
          console.error('Request error:', error);
          reject(error);
        });

        if (body) {
          req.write(JSON.stringify(body));
        }
        req.end();
      });
    }

    // Test 1: Publish a record via API
    console.log('Test 1: Publishing a record via API...');
    const record = {
      type: 'data' as const,
      content: { message: 'Hello from API!' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const publishResponse = await makeRequest('POST', '/publish', record);
    console.log('Publish response:', {
      status: publishResponse.status,
      data: publishResponse.data
    });

    const publishedCid = publishResponse.data?.cid;

    // Test 2: Fetch the published record
    console.log('\nTest 2: Fetching the published record...');
    const fetchResponse = await makeRequest('GET', `/fetch/${publishedCid}/private`);
    console.log('Fetch response:', {
      status: fetchResponse.status,
      data: fetchResponse.data
    });

    // Verify content matches
    const contentMatches = JSON.stringify(fetchResponse.data?.content) === JSON.stringify(record.content);
    console.log('Content matches original:', contentMatches);

    // Test 3: Get node status
    console.log('\nTest 3: Getting node status...');
    const statusResponse = await makeRequest('GET', '/status');
    console.log('Status response:', {
      status: statusResponse.status,
      data: statusResponse.data
    });

    // Test 4: Pin the record
    console.log('\nTest 4: Pinning the record...');
    const pinResponse = await makeRequest('POST', `/pin/${publishedCid}/private`);
    console.log('Pin response:', {
      status: pinResponse.status,
      data: pinResponse.data
    });

    // Test 5: Get pinned CIDs
    console.log('\nTest 5: Getting pinned CIDs...');
    const pinnedResponse = await makeRequest('GET', '/pins/private');
    console.log('Pinned CIDs response:', {
      status: pinnedResponse.status,
      data: pinnedResponse.data
    });

    // Verify the published CID is in the pinned list
    const isPinned = pinnedResponse.data?.includes(publishedCid);
    console.log('Published CID is pinned:', isPinned);

    // Test 6: Publish a bundle
    console.log('\nTest 6: Publishing a bundle...');
    const bundle = {
      schemaRecord: {
        type: 'schema' as const,
        content: {
          type: 'object',
          properties: {
            name: { type: 'string' }
          }
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
      },
      dataRecord: {
        type: 'data' as const,
        content: { name: 'Test Bundle' },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
      },
      combinedScope: 'private',
      timestamp: new Date().toISOString()
    };

    const bundleResponse = await makeRequest('POST', '/publish/bundle', bundle);
    console.log('Bundle publish response:', {
      status: bundleResponse.status,
      data: bundleResponse.data
    });

    // Test 7: Error handling
    console.log('\nTest 7: Testing error handling...');
    
    // Invalid CID
    const invalidFetchResponse = await makeRequest('GET', '/fetch/invalid-cid/private');
    console.log('Invalid CID fetch response:', {
      status: invalidFetchResponse.status,
      error: invalidFetchResponse.data
    });

    // Invalid scope
    const invalidScopeResponse = await makeRequest('GET', `/fetch/${publishedCid}/invalid`);
    console.log('Invalid scope fetch response:', {
      status: invalidScopeResponse.status,
      error: invalidScopeResponse.data
    });

  } catch (error) {
    console.error('Error during test:', error);
  } finally {
    try {
      if (server) {
        server.close();
      }
      await pipe.stop();
      console.log('\nTest completed, server stopped, and node stopped.');
    } catch (error) {
      console.error('Error stopping server/node:', error);
    }
  }
}

// Run the test
(async () => {
  try {
    await testApi();
  } catch (error) {
    console.error('Test failed:', error);
    process.exit(1);
  }
})();

================
File: scripts/test-basic-operations.ts
================
import { PipeProtocol } from '../src/pipe.js';

async function testBasicOperations() {
  console.log('Starting basic operations test...\n');
  
  let pipe: PipeProtocol | undefined;

  try {
    pipe = new PipeProtocol({});

    // Test 1: Publish a simple record
    console.log('Test 1: Publishing a simple record...');
    const record = {
      type: 'data' as const,
      content: { message: 'Hello, IPFS!' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const published = await pipe.publishRecord(record);
    console.log('Published record:', {
      cid: published.cid,
      content: published.content
    });

    // Test 2: Fetch the published record
    console.log('\nTest 2: Fetching the published record...');
    if (published.cid) {
      const fetched = await pipe.fetchRecord(published.cid, 'private');
      console.log('Fetched record:', fetched);

      // Verify content matches
      const contentMatches = JSON.stringify(fetched?.content) === JSON.stringify(record.content);
      console.log('Content matches original:', contentMatches);
    }

    // Test 3: Pin the record
    console.log('\nTest 3: Pinning the record...');
    if (published.cid) {
      await pipe.pin(published.cid, 'private');
      console.log('Record pinned successfully');
    }

    // Test 4: Get pinned CIDs
    console.log('\nTest 4: Getting pinned CIDs...');
    const pinnedCids = await pipe.getPinnedCids('private');
    console.log('Pinned CIDs:', pinnedCids);

    // Verify the published CID is in the pinned list
    if (published.cid) {
      const isPinned = pinnedCids.includes(published.cid);
      console.log('Published CID is pinned:', isPinned);
    }

    // Test 5: Get node status
    console.log('\nTest 5: Getting node status...');
    const status = await pipe.getStatus();
    console.log('Node status:', status);

  } catch (error) {
    console.error('Error during test:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  } finally {
    try {
      if (pipe) {
        await pipe.stop();
        console.log('\nTest completed and node stopped.');
      }
    } catch (error) {
      console.error('Error stopping node:', error);
      if (error instanceof Error) {
        console.error('Error stack:', error.stack);
      }
      process.exit(1);
    }
  }
}

// Run the test
(async () => {
  try {
    await testBasicOperations();
  } catch (error) {
    console.error('Test failed:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  }
})();

================
File: scripts/test-bundles.ts
================
import { PipeProtocol } from '../src/pipe';
import { PipeBundle } from '../src/types';

async function testBundles() {
  console.log('Starting bundles test...\n');
  
  const pipe = new PipeProtocol({});

  try {
    // Test 1: Create and publish a bundle with schema and data
    console.log('Test 1: Publishing a bundle with schema and data...');
    const bundle: PipeBundle = {
      schemaRecord: {
        type: 'schema' as const,
        content: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            age: { type: 'number' }
          },
          required: ['name', 'age']
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
      },
      dataRecord: {
        type: 'data' as const,
        content: {
          name: 'John Doe',
          age: 30
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
      },
      combinedScope: 'private',
      timestamp: new Date().toISOString()
    };

    const published = await pipe.publishBundle(bundle);
    console.log('Published bundle:', {
      schemaRecord: {
        cid: published.schemaRecord.cid,
        content: published.schemaRecord.content
      },
      dataRecord: {
        cid: published.dataRecord.cid,
        content: published.dataRecord.content
      },
      timestamp: published.timestamp
    });

    // Test 2: Fetch and verify bundle records
    console.log('\nTest 2: Fetching bundle records...');
    if (published.schemaRecord.cid && published.dataRecord.cid) {
      const fetchedSchema = await pipe.fetchRecord(published.schemaRecord.cid, 'private');
      const fetchedData = await pipe.fetchRecord(published.dataRecord.cid, 'private');

      console.log('Fetched schema record:', {
        content: fetchedSchema?.content,
        type: fetchedSchema?.type
      });

      console.log('Fetched data record:', {
        content: fetchedData?.content,
        type: fetchedData?.type
      });

      // Verify content matches
      const schemaMatches = JSON.stringify(fetchedSchema?.content) === JSON.stringify(bundle.schemaRecord.content);
      const dataMatches = JSON.stringify(fetchedData?.content) === JSON.stringify(bundle.dataRecord.content);
      console.log('Content matches original:', {
        schema: schemaMatches,
        data: dataMatches
      });
    }

    // Test 3: Create and publish an encrypted bundle
    console.log('\nTest 3: Publishing an encrypted bundle...');
    const encryptedBundle: PipeBundle = {
      schemaRecord: {
        type: 'schema' as const,
        content: {
          type: 'object',
          properties: {
            secretKey: { type: 'string' },
            value: { type: 'string' }
          },
          required: ['secretKey', 'value']
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: true },
        encryption: { 
          enabled: true,
          method: 'AES-GCM',
          keyRef: 'bundleKey1'
        },
        pinned: true
      },
      dataRecord: {
        type: 'data' as const,
        content: {
          secretKey: 'super-secret',
          value: 'classified-data'
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: true },
        encryption: { 
          enabled: true,
          method: 'AES-GCM',
          keyRef: 'bundleKey1'
        },
        pinned: true
      },
      combinedScope: 'private',
      timestamp: new Date().toISOString()
    };

    const publishedEncrypted = await pipe.publishBundle(encryptedBundle);
    console.log('Published encrypted bundle:', {
      schemaRecord: {
        cid: publishedEncrypted.schemaRecord.cid,
        encryption: publishedEncrypted.schemaRecord.encryption
      },
      dataRecord: {
        cid: publishedEncrypted.dataRecord.cid,
        encryption: publishedEncrypted.dataRecord.encryption
      }
    });

    // Test 4: Verify pinning of bundle records
    console.log('\nTest 4: Verifying pinned bundle records...');
    const pinnedCids = await pipe.getPinnedCids('private');
    
    const schemaPinned = published.schemaRecord.cid && pinnedCids.includes(published.schemaRecord.cid);
    const dataPinned = published.dataRecord.cid && pinnedCids.includes(published.dataRecord.cid);
    const encryptedSchemaPinned = publishedEncrypted.schemaRecord.cid && 
      pinnedCids.includes(publishedEncrypted.schemaRecord.cid);
    const encryptedDataPinned = publishedEncrypted.dataRecord.cid && 
      pinnedCids.includes(publishedEncrypted.dataRecord.cid);

    console.log('Bundle records are pinned:', {
      plainSchema: schemaPinned,
      plainData: dataPinned,
      encryptedSchema: encryptedSchemaPinned,
      encryptedData: encryptedDataPinned
    });

  } catch (error) {
    console.error('Error during test:', error);
  } finally {
    try {
      await pipe.stop();
      console.log('\nTest completed and node stopped.');
    } catch (error) {
      console.error('Error stopping node:', error);
    }
  }
}

// Run the test
(async () => {
  try {
    await testBundles();
  } catch (error) {
    console.error('Test failed:', error);
    process.exit(1);
  }
})();

================
File: scripts/test-encryption.ts
================
import { PipeProtocol } from '../src/pipe';

async function testEncryption() {
  console.log('Starting encryption test...\n');
  
  const pipe = new PipeProtocol({});

  try {
    // Test 1: Publish an encrypted record
    console.log('Test 1: Publishing an encrypted record...');
    const record = {
      type: 'data' as const,
      content: { secretMessage: 'This is a secret!' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: true },
      encryption: { 
        enabled: true,
        method: 'AES-GCM',
        keyRef: 'testKey1'
      },
      pinned: true
    };

    const published = await pipe.publishRecord(record);
    console.log('Published encrypted record:', {
      cid: published.cid,
      content: published.content,
      encryption: published.encryption
    });

    // Verify the content is encrypted (should be different from original)
    const contentChanged = JSON.stringify(published.content) !== JSON.stringify(record.content);
    console.log('Content was encrypted (different from original):', contentChanged);

    // Test 2: Publish a record with different encryption settings
    console.log('\nTest 2: Publishing with different encryption settings...');
    const record2 = {
      type: 'data' as const,
      content: { secretMessage: 'Another secret!' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: true },
      encryption: { 
        enabled: true,
        method: 'AES-GCM',
        keyRef: 'testKey2'
      },
      pinned: true
    };

    const published2 = await pipe.publishRecord(record2);
    console.log('Published second encrypted record:', {
      cid: published2.cid,
      content: published2.content,
      encryption: published2.encryption
    });

    // Test 3: Verify different keys produce different ciphertexts
    console.log('\nTest 3: Verifying different keys produce different ciphertexts...');
    const differentCiphertexts = published.content !== published2.content;
    console.log('Different keys produced different ciphertexts:', differentCiphertexts);

    // Test 4: Publish an unencrypted record
    console.log('\nTest 4: Publishing an unencrypted record...');
    const record3 = {
      type: 'data' as const,
      content: { publicMessage: 'This is public!' },
      scope: 'public' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const published3 = await pipe.publishRecord(record3);
    console.log('Published unencrypted record:', {
      cid: published3.cid,
      content: published3.content,
      encryption: published3.encryption
    });

    // Verify content matches (should be unchanged)
    const contentUnchanged = JSON.stringify(published3.content) === JSON.stringify(record3.content);
    console.log('Unencrypted content matches original:', contentUnchanged);

    // Test 5: Fetch and verify records
    console.log('\nTest 5: Fetching and verifying records...');
    
    if (published.cid && published2.cid && published3.cid) {
      // Fetch encrypted records
      const fetched1 = await pipe.fetchRecord(published.cid, 'private');
      const fetched2 = await pipe.fetchRecord(published2.cid, 'private');
      const fetched3 = await pipe.fetchRecord(published3.cid, 'public');

      console.log('Fetched records have encryption enabled:', {
        record1: fetched1?.encryption?.enabled,
        record2: fetched2?.encryption?.enabled,
        record3: fetched3?.encryption?.enabled
      });

      // Verify encryption settings are preserved
      const encryptionPreserved = 
        fetched1?.encryption?.enabled === record.encryption.enabled &&
        fetched2?.encryption?.enabled === record2.encryption.enabled &&
        fetched3?.encryption?.enabled === record3.encryption.enabled;

      console.log('Encryption settings preserved:', encryptionPreserved);
    }

  } catch (error) {
    console.error('Error during test:', error);
  } finally {
    try {
      await pipe.stop();
      console.log('\nTest completed and node stopped.');
    } catch (error) {
      console.error('Error stopping node:', error);
    }
  }
}

// Run the test
(async () => {
  try {
    await testEncryption();
  } catch (error) {
    console.error('Test failed:', error);
    process.exit(1);
  }
})();

================
File: src/tests/pipe.test.ts
================
import { PipeProtocol } from '../pipe.js';
import { PipeOptions } from '../pipe';
import { pipe } from '../index';
import { createApi } from '../api';
import { PipeRecord, PipeBundle, Scope } from '../types.js';
import { AddressInfo } from 'net';
import { Server } from 'http';
import { expect, describe, test, beforeEach, afterEach } from '@jest/globals';

interface NodeStatus {
  localNode: boolean;
  publicNode: boolean;
}

interface NodeInfo {
  peerId: string;
}

interface StorageMetrics {
  repoSize: number;
}

interface NodeConfig {
  peerId: string;
  addrs: string[];
}

const mockRecord: PipeRecord = {
  type: 'data',
  content: { test: 'data' },
  scope: 'private' as Scope,
  accessPolicy: { hiddenFromLLM: false },
  encryption: { enabled: false },
  pinned: true
};

describe('PipeProtocol', () => {
  let pipe: PipeProtocol;
  
  beforeEach(() => {
    pipe = new PipeProtocol({});
  });

  afterEach(async () => {
    await pipe.stop();
  });

  it('should publish and fetch a record', async () => {
    const published = await pipe.publishRecord(mockRecord);
    expect(published.cid).toBeDefined();

    if (published.cid) {
      const fetched = await pipe.fetchRecord(published.cid, 'private');
      expect(fetched?.content).toEqual(mockRecord.content);
    }
  });

  it('should get node status', async () => {
    const status = await pipe.getStatus() as NodeStatus;
    expect(status).toEqual({
      localNode: true,
      publicNode: false
    });
  });

  it('should get node info', async () => {
    const info = await pipe.getNodeInfo('private') as NodeInfo;
    expect(info).toEqual({
      peerId: expect.any(String)
    });
  });

  it('should get storage metrics', async () => {
    const metrics = await pipe.getStorageMetrics('private') as StorageMetrics;
    expect(metrics).toEqual({
      repoSize: 0
    });
  });

  it('should get configuration', async () => {
    const config = await pipe.getConfiguration('private') as NodeConfig;
    expect(config).toEqual({
      peerId: expect.any(String),
      addrs: []
    });
  });
});

describe('Pipe Core Functionality', () => {
  let pipeProtocol: PipeProtocol;
  let server: Server;
  let port: number;

  beforeAll(async () => {
    const options: PipeOptions = {
      publicNodeEndpoint: 'https://ipfs.infura.io:5001'
    };
    pipeProtocol = new PipeProtocol(options);
    const app = createApi(pipeProtocol);
    server = app.listen(0);
    port = (server.address() as AddressInfo).port;
  });

  afterAll(async() => {
    server.close();
    await pipeProtocol.stop();
  });

  it('Tool Wrapping', () => {
    const tools = [{
      name: 'weatherTool',
      description: 'Get weather data',
      call: () => 'Sunny'
    }];

    const wrapped = pipe(tools);
    const pipeTool = wrapped.find(t => t.name === 'Pipe');
    expect(pipeTool).toBeDefined();
  });

  it('Should publish a record and return a cid', async () => {
    const record = await pipeProtocol.publishRecord(mockRecord);
    expect(record.cid).toBeDefined();
  });

  it('Should publish a record and then fetch it', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    const fetched = await pipeProtocol.fetchRecord(published.cid || '', 'private');
    expect(fetched?.content).toEqual(mockRecord.content);
  });

  it('Should publish a bundle and return two cids', async () => {
    const bundle = await pipeProtocol.publishBundle(mockBundle);
    expect(bundle.dataRecord.cid).toBeDefined();
    expect(bundle.schemaRecord.cid).toBeDefined();
  });

  it('Should pin a record', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    await pipeProtocol.pin(published.cid || '', 'private');
  });

  it('Should unpin a record', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    await pipeProtocol.unpin(published.cid || '', 'private');
  });

  it('Should replicate a record', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    await pipeProtocol.replicate(published.cid || '', 'private', 'public');
  });

  it('Should get node status', () => {
    const status = pipeProtocol.getStatus();
    expect(status.localNode).toBe(true);
    expect(status.publicNode).toBe(true);
  });

  it('Should get node info', () => {
    const info = pipeProtocol.getNodeInfo('private');
    expect(info.peerId).toBeDefined();
  });

  it('Should be able to post a record to the api and return a record', async () => {
    const response = await fetch(`http://localhost:${port}/publish`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(mockRecord)
    });
    const data = await response.json();
    expect(data.cid).toBeDefined();
  });

  it('Should be able to get a record from the api', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    const response = await fetch(`http://localhost:${port}/fetch?cid=${published.cid}&scope=private`);
    const data = await response.json();
    expect(data.content).toEqual(mockRecord.content);
  });

  it('Should be able to get the node status from the api', async () => {
    const response = await fetch(`http://localhost:${port}/node-status`);
    const status = await response.json();
    expect(status.localNode).toBe(true);
    expect(status.publicNode).toBe(true);
  });

  it('Should be able to get the node info from the api', async () => {
    const response = await fetch(`http://localhost:${port}/node-info?scope=private`);
    const info = await response.json();
    expect(info.peerId).toBeDefined();
  });

  it('Should be able to get storage metrics from the api', async() => {
    const response = await fetch(`http://localhost:${port}/storage-metrics?scope=private`);
    const metrics = await response.json();
    expect(metrics.repoSize).toBeDefined();
  });

  it('Should be able to get the pinned CIDs from the api', async () => {
    const record = await pipeProtocol.publishRecord(mockRecord);
    await pipeProtocol.pin(record.cid || '', 'private');
    const response = await fetch(`http://localhost:${port}/pinned-cids?scope=private`);
    const pins = await response.json();
    expect(pins).toContain(record.cid);
  });

  it('Should be able to get the configuration from the api', async () => {
    const response = await fetch(`http://localhost:${port}/configuration?scope=private`);
    const config = await response.json();
    expect(config.peerId).toBeDefined();
    expect(config.addrs).toBeDefined();
  });
});

================
File: src/api.ts
================
import express from 'express';
import { PipeProtocol } from './pipe';
import { PipeRecord, PipeBundle, Scope } from './types';

export function createApi(pipeProtocol: PipeProtocol) {
  const app = express();
  app.use(express.json());

  app.post('/publish', async (req, res) => {
    try {
      const record = await pipeProtocol.publishRecord(req.body as PipeRecord);
      res.json(record);
    } catch (error) {
      console.error("Error publishing record:", error);
      res.status(500).send("Failed to publish record.");
    }
  });

  app.post('/publish-bundle', async (req, res) => {
    try {
      const bundle = await pipeProtocol.publishBundle(req.body as PipeBundle);
      res.json(bundle);
    } catch(error) {
      console.error("Error publishing bundle:", error);
      res.status(500).send("Failed to publish bundle.");
    }
  });

  app.get('/fetch', async (req, res) => {
    try {
      const { cid, scope } = req.query;
      const data = await pipeProtocol.fetchRecord(cid as string, scope as Scope);
      res.json(data);
    } catch(error) {
      console.error("Error fetching record:", error);
      res.status(500).send("Failed to fetch record.");
    }
  });

  app.post('/pin', async (req, res) => {
    try {
      const { cid, scope } = req.body;
      await pipeProtocol.pin(cid as string, scope as Scope);
      res.status(200).send('Pinned successfully');
    } catch (error) {
      console.error("Error pinning record:", error);
      res.status(500).send("Failed to pin record.");
    }
  });

  app.post('/unpin', async (req, res) => {
    try {
      const { cid, scope } = req.body;
      await pipeProtocol.unpin(cid as string, scope as Scope);
      res.status(200).send('Unpinned successfully');
    } catch(error) {
      console.error("Error unpinning record:", error);
      res.status(500).send("Failed to unpin record.");
    }
  });

  app.post('/replicate', async (req, res) => {
    try {
      const { cid, fromScope, toScope } = req.body;
      await pipeProtocol.replicate(cid as string, fromScope as Scope, toScope as Scope);
      res.status(200).send("Replicated successfully");
    } catch(error) {
      console.error("Error replicating record:", error);
      res.status(500).send("Failed to replicate record.");
    }
  });

  app.get('/node-status', async (req, res) => {
    try {
      const status = await pipeProtocol.getStatus();
      res.json(status);
    } catch (error) {
      console.error('Error getting node status:', error);
      res.status(500).send("Failed to fetch node status.");
    }
  });

  app.get('/node-info', async (req, res) => {
    try {
      const { scope } = req.query;
      const info = await pipeProtocol.getNodeInfo(scope as Scope);
      res.json(info);
    } catch(error) {
      console.error('Error getting node info:', error);
      res.status(500).send("Failed to fetch node info.");
    }
  });

  app.get('/storage-metrics', async (req, res) => {
    try {
      const { scope } = req.query;
      const metrics = await pipeProtocol.getStorageMetrics(scope as Scope);
      res.json(metrics);
    } catch(error) {
      console.error('Error getting storage metrics:', error);
      res.status(500).send("Failed to fetch storage metrics");
    }
  });

  app.get('/pinned-cids', async(req, res) => {
    try {
      const { scope } = req.query;
      const pins = await pipeProtocol.getPinnedCids(scope as Scope);
      res.json(pins);
    } catch(error) {
      console.error('Error getting pinned CIDs:', error);
      res.status(500).send('Failed to fetch pinned cids');
    }
  });

  app.get('/configuration', async (req, res) => {
    try {
      const { scope } = req.query;
      const config = await pipeProtocol.getConfiguration(scope as Scope);
      res.json(config);
    } catch(error) {
      console.error('Error getting configuration:', error);
      res.status(500).send('Failed to fetch configuration');
    }
  });

  return app;
}

================
File: src/encryption.ts
================
export class EncryptionService {
  encrypt(plaintext: string, method?: string, keyRef?: string): string {
    const methodString = method || "AES-GCM";
    const keyRefString = keyRef || "defaultKey";
    // In a real application, use proper encryption here
    const encryptedData = {
      data: plaintext,
      method: methodString,
      keyRef: keyRefString
    };
    return `encrypted:${Buffer.from(JSON.stringify(encryptedData)).toString('base64')}`;
  }

  decrypt(ciphertext: string, method?: string, keyRef?: string): string {
    if (!ciphertext.startsWith('encrypted:')) {
      throw new Error('Invalid encrypted data format');
    }
    
    const base64Data = ciphertext.slice(10); // Remove 'encrypted:' prefix
    const decryptedJson = Buffer.from(base64Data, 'base64').toString();
    const { data } = JSON.parse(decryptedJson);
    return data;
  }

  getEncryptionInfo(ciphertext: string): { method: string; keyRef: string } | null {
    if (!ciphertext.startsWith('encrypted:')) {
      return null;
    }
    
    try {
      const base64Data = ciphertext.slice(10); // Remove 'encrypted:' prefix
      const decryptedJson = Buffer.from(base64Data, 'base64').toString();
      const { method, keyRef } = JSON.parse(decryptedJson);
      return { method, keyRef };
    } catch (error) {
      console.warn('Failed to extract encryption info:', error);
      return null;
    }
  }
}

================
File: src/index.ts
================
import { PipeProtocol } from './pipe';
import { PipeRecord, PipeBundle, Scope } from './types';

interface Tool {
  name: string;
  description: string;
  call: (...args: any[]) => any;
}

interface PipeTool {
  name: string;
  description: string;
  call: (method: string, args: any) => Promise<PipeRecord | PipeBundle | null | void>;
}

export function pipe(tools: Tool[]): (Tool | PipeTool)[] {
  const pipeProtocol = new PipeProtocol();

  const pipeTool: PipeTool = {
    name: 'Pipe',
    description: `
      A special tool that allows referencing large data via IPFS.
      You can publish data or fetch data by CID.
      Example usage:
        - publishRecord({type, content, scope, pinned, encryption, accessPolicy})
        - fetchRecord(cid, scope)
        - publishBundle({schemaRecord, dataRecord, combinedScope})
        - pin(cid, scope)
        - unpin(cid, scope)
        - replicate(cid, fromScope, toScope)
        - getStatus()
        - getNodeInfo(scope)
        - getStorageMetrics(scope)
        - getPinnedCids(scope)
        - getConfiguration(scope)
      The LLM typically should not decrypt hidden data if hiddenFromLLM = true.
    `,
    call: async (method: string, args: any) => {
      switch (method) {
        case 'publishRecord':
          return pipeProtocol.publishRecord(args as PipeRecord);
        case 'fetchRecord':
          return pipeProtocol.fetchRecord(args.cid, args.scope as Scope);
        case 'publishBundle':
          return pipeProtocol.publishBundle(args as PipeBundle);
        case 'pin':
          return pipeProtocol.pin(args.cid, args.scope as Scope);
        case 'unpin':
          return pipeProtocol.unpin(args.cid, args.scope as Scope);
        case 'replicate':
          return pipeProtocol.replicate(args.cid, args.fromScope as Scope, args.toScope as Scope);
        case 'getStatus':
          return pipeProtocol.getStatus();
        case 'getNodeInfo':
          return pipeProtocol.getNodeInfo(args.scope as Scope);
        case 'getStorageMetrics':
          return pipeProtocol.getStorageMetrics(args.scope as Scope);
        case 'getPinnedCids':
          return pipeProtocol.getPinnedCids(args.scope as Scope);
        case 'getConfiguration':
          return pipeProtocol.getConfiguration(args.scope as Scope);
        default:
          throw new Error(`Unknown Pipe method: ${method}`);
      }
    },
  };

  return [...tools, pipeTool];
}

================
File: src/ipfsClient.ts
================
import { createHelia, Helia } from 'helia';
import { PipeRecord, Scope } from './types.js';
import { config } from 'dotenv';
import { CID } from 'multiformats/cid';
import * as raw from 'multiformats/codecs/raw';
import { sha256 } from 'multiformats/hashes/sha2';
import { MemoryBlockstore } from 'blockstore-core';
config();

interface PipeIpfsOptions {
  localNodeEndpoint?: string;
  publicNodeEndpoint?: string;
}

export class IpfsClient {
  private localNode!: Helia;
  private publicNode?: Helia;
  private initialized: Promise<void>;
  private localPinnedCids: Set<string>;
  private publicPinnedCids: Set<string>;

  constructor(options: PipeIpfsOptions = {}) {
    console.log('Initializing IpfsClient...');
    try {
      const { localNodeEndpoint, publicNodeEndpoint } = options;
      console.log('Creating pinned CID sets...');
      this.localPinnedCids = new Set();
      this.publicPinnedCids = new Set();
      console.log('Starting IPFS node initialization...');
      this.initialized = this.init(localNodeEndpoint, publicNodeEndpoint).catch(error => {
        console.error('Error during IPFS initialization:', error);
        if (error instanceof Error) {
          console.error('Error stack:', error.stack);
        }
        throw error;
      });
      console.log('IpfsClient constructor complete.');
    } catch (error) {
      console.error('Error in IpfsClient constructor:', error);
      if (error instanceof Error) {
        console.error('Error stack:', error.stack);
      }
      throw error;
    }
  }

  private async init(localNodeEndpoint?: string, publicNodeEndpoint?: string) {
    try {
      console.log('Creating local IPFS node...');
      // Initialize with memory blockstore for testing
      const blockstore = new MemoryBlockstore();
      
      this.localNode = await createHelia({
        blockstore,
        start: true
      });
      console.log('Local IPFS node created successfully.');
      
      if(publicNodeEndpoint || process.env.PUBLIC_IPFS_ENDPOINT) {
        console.log('Creating public IPFS node...');
        const publicEndpoint = publicNodeEndpoint || process.env.PUBLIC_IPFS_ENDPOINT || 'https://ipfs.infura.io:5001';
        const publicBlockstore = new MemoryBlockstore();
        this.publicNode = await createHelia({
          blockstore: publicBlockstore,
          start: true
        });
        console.log('Public IPFS node created successfully.');
      }
    } catch (error) {
      console.error('Failed to initialize IPFS client:', error);
      if (error instanceof Error) {
        console.error('Error stack:', error.stack);
      }
      throw error;
    }
  }

  private async getNode(scope: Scope): Promise<{ node: Helia; pinnedCids: Set<string> }> {
    await this.initialized;
    if(scope === 'public') {
      if(!this.publicNode) {
        throw new Error("Cannot use public scope when no public endpoint is provided");
      }
      return { node: this.publicNode, pinnedCids: this.publicPinnedCids };
    }
    return { node: this.localNode, pinnedCids: this.localPinnedCids };
  }

  private async createCID(bytes: Uint8Array): Promise<CID> {
    const hash = await sha256.digest(bytes);
    return CID.create(1, raw.code, hash);
  }

  public async publish(record: PipeRecord): Promise<PipeRecord> {
    const { node } = await this.getNode(record.scope);
    const content = JSON.stringify(record.content);
    const encoder = new TextEncoder();
    const bytes = encoder.encode(content);
    const cid = await this.createCID(bytes);
    
    // Store the content
    await node.blockstore.put(cid, bytes);
    
    // Pin if requested
    if (record.pinned) {
      try {
        await this.pin(cid.toString(), record.scope);
      } catch (error) {
        console.warn('Failed to pin content:', error);
        // Continue even if pinning fails
      }
    }
    
    return {...record, cid: cid.toString()};
  }

  public async fetch(cidStr: string, scope: Scope): Promise<any> {
    const { node } = await this.getNode(scope);
    const cid = CID.parse(cidStr);
    const bytes = await node.blockstore.get(cid);
    const decoder = new TextDecoder();
    const content = decoder.decode(bytes);
    return JSON.parse(content);
  }

  public async pin(cidStr: string, scope: Scope): Promise<void> {
    const { node, pinnedCids } = await this.getNode(scope);
    const cid = CID.parse(cidStr);
    try {
      // Verify the content exists before pinning
      await node.blockstore.get(cid);
      pinnedCids.add(cidStr);
    } catch (error) {
      console.error('Error pinning content:', error);
      throw error;
    }
  }

  public async unpin(cidStr: string, scope: Scope): Promise<void> {
    const { pinnedCids } = await this.getNode(scope);
    try {
      pinnedCids.delete(cidStr);
    } catch (error) {
      console.error('Error unpinning content:', error);
      throw error;
    }
  }

  public async replicate(cidStr: string, fromScope: Scope, toScope: Scope): Promise<void> {
    if (toScope === 'public') {
      await this.pin(cidStr, fromScope);
    }
    console.log(`Replication from ${fromScope} to ${toScope} for CID: ${cidStr}`);
  }

  public async stop(): Promise<void> {
    await this.initialized;
    await this.localNode.stop();
    if(this.publicNode) await this.publicNode.stop();
  }

  public async getStatus(): Promise<any> {
    await this.initialized;
    return {
      localNode: Boolean(this.localNode),
      publicNode: Boolean(this.publicNode)
    };
  }

  public async getNodeInfo(scope: Scope): Promise<any> {
    const { node } = await this.getNode(scope);
    return {
      peerId: node.toString()
    };
  }

  public async getStorageMetrics(scope: Scope): Promise<any> {
    const { node } = await this.getNode(scope);
    return {
      repoSize: 0 // Simplified metric for now
    };
  }

  public async getPinnedCids(scope: Scope): Promise<string[]> {
    const { pinnedCids } = await this.getNode(scope);
    return Array.from(pinnedCids);
  }

  public async getConfiguration(scope: Scope): Promise<any> {
    const { node } = await this.getNode(scope);
    return {
      peerId: node.toString(),
      addrs: []
    };
  }
}

================
File: src/pipe.ts
================
import { IpfsClient } from './ipfsClient.js';
import { EncryptionService } from './encryption.js';
import { PipeRecord, PipeBundle, Scope } from './types.js';
import { PipeRecordSchema, PipeBundleSchema } from './schema.js';

export interface PipeOptions {
  localNodeEndpoint?: string;
  publicNodeEndpoint?: string;
}

export class PipeProtocol {
  private ipfs: IpfsClient;
  private encryption: EncryptionService;

  constructor(options: PipeOptions = {}) {
    console.log('Initializing PipeProtocol...');
    try {
      console.log('Creating EncryptionService...');
      this.encryption = new EncryptionService();
      console.log('Creating IpfsClient...');
      this.ipfs = new IpfsClient(options);
      console.log('PipeProtocol initialization complete.');
    } catch (error) {
      console.error('Error during PipeProtocol initialization:', error);
      if (error instanceof Error) {
        console.error('Error stack:', error.stack);
      }
      throw error;
    }
  }

  public async publishRecord(record: PipeRecord): Promise<PipeRecord> {
    const parsedRecord = await PipeRecordSchema.parseAsync(record);
    const validRecord: PipeRecord = {
      ...parsedRecord,
      type: parsedRecord.type,
      scope: parsedRecord.scope,
      cid: parsedRecord.cid || undefined
    };

    if(validRecord.encryption?.enabled && !validRecord.encryption?.ciphertext && validRecord.content) {
      const method = validRecord.encryption?.method || "AES-GCM";
      const keyRef = validRecord.encryption?.keyRef || "defaultKey";

      const plaintext = typeof validRecord.content === 'string'
        ? validRecord.content
        : JSON.stringify(validRecord.content);
      
      const encrypted = this.encryption.encrypt(plaintext, method, keyRef);

      validRecord.content = encrypted;
      validRecord.encryption.ciphertext = true;
    }
    return this.ipfs.publish(validRecord);
  }

  public async publishBundle(bundle: PipeBundle): Promise<PipeBundle> {
    const parsedBundle = await PipeBundleSchema.parseAsync(bundle);
    const validBundle: PipeBundle = {
      ...parsedBundle,
      schemaRecord: {
        ...parsedBundle.schemaRecord,
        type: parsedBundle.schemaRecord.type,
        scope: parsedBundle.schemaRecord.scope,
        cid: parsedBundle.schemaRecord.cid || undefined
      },
      dataRecord: {
        ...parsedBundle.dataRecord,
        type: parsedBundle.dataRecord.type,
        scope: parsedBundle.dataRecord.scope,
        cid: parsedBundle.dataRecord.cid || undefined
      }
    };
    
    const publishedSchema = await this.publishRecord(validBundle.schemaRecord);
    const publishedData = await this.publishRecord(validBundle.dataRecord);

    return {
      ...validBundle,
      schemaRecord: publishedSchema,
      dataRecord: publishedData,
      timestamp: new Date().toISOString(),
    };
  }

  public async fetchRecord(cid: string, scope: Scope): Promise<PipeRecord | null> {
    const content = await this.ipfs.fetch(cid, scope);
    if (!content) return null;

    // If the content is a string and starts with 'encrypted:', it's an encrypted record
    const isEncrypted = typeof content === 'string' && content.startsWith('encrypted:');
    
    // Get encryption info if the content is encrypted
    let encryptionInfo = { enabled: false };
    if (isEncrypted && typeof content === 'string') {
      const info = this.encryption.getEncryptionInfo(content);
      if (info) {
        encryptionInfo = {
          enabled: true,
          method: info.method,
          keyRef: info.keyRef,
          ciphertext: true
        };
      }
    }
    
    return {
      cid,
      content,
      type: 'data',
      scope,
      accessPolicy: { hiddenFromLLM: false },
      encryption: encryptionInfo
    };
  }

  public async pin(cid: string, scope: Scope): Promise<void> {
    return this.ipfs.pin(cid, scope);
  }

  public async unpin(cid: string, scope: Scope): Promise<void> {
    return this.ipfs.unpin(cid, scope);
  }

  public async replicate(cid: string, fromScope: Scope, toScope: Scope): Promise<void> {
    return this.ipfs.replicate(cid, fromScope, toScope);
  }

  public async stop() {
    await this.ipfs.stop();
  }

  public getStatus() {
    return this.ipfs.getStatus();
  }

  public getNodeInfo(scope: Scope) {
    return this.ipfs.getNodeInfo(scope);
  }

  public async getStorageMetrics(scope: Scope): Promise<any> {
    return this.ipfs.getStorageMetrics(scope);
  }

  public async getPinnedCids(scope: Scope): Promise<any> {
    return this.ipfs.getPinnedCids(scope);
  }

  public getConfiguration(scope: Scope): any {
    return this.ipfs.getConfiguration(scope);
  }
}

================
File: src/schema.ts
================
import { z } from 'zod';
import { AccessPolicy, EncryptionInfo } from './types';

const EncryptionSchema: z.ZodSchema<EncryptionInfo> = z.object({
  enabled: z.boolean(),
  method: z.string().optional(),
  keyRef: z.string().optional(),
  nonce: z.string().optional(),
  ciphertext: z.boolean().optional(),
});

const AccessPolicySchema: z.ZodSchema<AccessPolicy> = z.object({
  hiddenFromLLM: z.boolean().optional(),
  allowedTools: z.array(z.string()).optional(),
  allowedUsers: z.array(z.string()).optional(),
});

export const PipeRecordSchema = z.object({
  type: z.enum(['data', 'schema']),
  cid: z.string().nullable().optional(),
  content: z.any().nullable().optional(),
  scope: z.enum(['private', 'public', 'machine', 'user']),
  pinned: z.boolean().optional(),
  encryption: EncryptionSchema.optional(),
  accessPolicy: AccessPolicySchema.optional(),
  metadata: z.record(z.any()).optional(),
});

export const PipeBundleSchema = z.object({
  schemaRecord: PipeRecordSchema,
  dataRecord: PipeRecordSchema,
  combinedScope: z.enum(['private', 'public', 'machine', 'user']),
  timestamp: z.string().datetime(),
});

================
File: src/types.ts
================
export interface EncryptionInfo {
  enabled: boolean;
  method?: string;
  keyRef?: string;
  nonce?: string;
  ciphertext?: boolean;
}

export interface AccessPolicy {
  hiddenFromLLM?: boolean;
  allowedTools?: string[];
  allowedUsers?: string[];
}

export type Scope = "private" | "public" | "machine" | "user";

export interface PipeRecord {
  type: "data" | "schema";
  cid?: string;
  content?: any;
  scope: Scope;
  pinned?: boolean;
  encryption?: EncryptionInfo;
  accessPolicy?: AccessPolicy;
  metadata?: Record<string, any>;
}

export interface PipeBundle {
  schemaRecord: PipeRecord;
  dataRecord: PipeRecord;
  combinedScope: Scope;
  timestamp: string;
}

================
File: .gitignore
================
node_modules
dist
*.log
.env
coverage

================
File: jest.config.cjs
================
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/*.test.ts'],
  transform: {
    '^.+\\.tsx?$': ['ts-jest', {
      useESM: true,
    }]
  },
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  extensionsToTreatAsEsm: ['.ts'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  verbose: true
};

================
File: package.json
================
{
  "name": "pipe-core",
  "version": "1.0.0",
  "description": "A protocol for sharing data between LLMs via IPFS",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "build:scripts": "tsc",
    "test": "jest",
    "start": "node dist/index.js",
    "dev": "node --loader ts-node/esm src/index.ts",
    "lint": "eslint src/**/*.ts",
    "clean": "rm -rf dist",
    "pretest:basic": "npm run build",
    "pretest:encryption": "npm run build",
    "pretest:bundles": "npm run build",
    "pretest:api": "npm run build",
    "test:basic": "node dist/scripts/test-basic-operations.js",
    "test:encryption": "node dist/scripts/test-encryption.js",
    "test:bundles": "node dist/scripts/test-bundles.js",
    "test:api": "node dist/scripts/test-api.js",
    "test:all": "npm run test:basic && npm run test:encryption && npm run test:bundles && npm run test:api"
  },
  "keywords": [
    "ipfs",
    "llm",
    "data-sharing",
    "protocol"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@helia/unixfs": "^4.0.2",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.13.0",
    "blockstore-core": "^5.0.2",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "helia": "^5.2.0",
    "jest": "^29.7.0",
    "multiformats": "^13.3.1",
    "node-fetch": "^2.7.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.3",
    "zod": "^3.24.1"
  }
}

================
File: README.md
================
# Pipe Core

A protocol for sharing data between LLMs via IPFS with in-process nodes and visibility tooling.

## Features

- In-process IPFS nodes (local and public)
- Data encryption support
- Schema validation
- Access policy management
- API endpoints for data management
- Comprehensive testing suite

## Installation

```bash
npm install
```

## Configuration

Create a `.env` file with the following variables:

```env
LOCAL_IPFS_ENDPOINT="http://localhost:5001"
PUBLIC_IPFS_ENDPOINT="https://ipfs.infura.io:5001"
```

## Usage

### Building the Project

```bash
npm run build
```

### Running Tests

```bash
npm test
```

### Starting the Server

```bash
npm start
```

### Development Mode

```bash
npm run dev
```

## API Endpoints

- `POST /publish` - Publish a record
- `POST /publish-bundle` - Publish a bundle (schema + data)
- `GET /fetch` - Fetch a record by CID
- `POST /pin` - Pin a record
- `POST /unpin` - Unpin a record
- `POST /replicate` - Replicate a record between scopes
- `GET /node-status` - Get node status
- `GET /node-info` - Get node information
- `GET /storage-metrics` - Get storage metrics
- `GET /pinned-cids` - Get pinned CIDs
- `GET /configuration` - Get node configuration

## License

ISC

================
File: tsconfig.json
================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "ES2020",
    "lib": ["ES2020"],
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "ES2020",
    "moduleResolution": "node",
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    "resolveJsonModule": true,
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    "allowJs": true,
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    "declaration": true,
    "declarationMap": true,
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    "sourceMap": true,
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist",
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    "isolatedModules": true,
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    "allowSyntheticDefaultImports": true,
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,

    /* Type Checking */
    "strict": true,
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true,
    "rootDir": "."
  },
  "ts-node": {
    "esm": true,
    "experimentalSpecifierResolution": "node"
  },
  "include": ["src/**/*", "scripts/**/*"],
  "exclude": ["node_modules", "dist"]
}
