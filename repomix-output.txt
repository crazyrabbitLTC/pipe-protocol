This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T22:34:24.534Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
dist-scripts/
  scripts/
    test-api.d.ts
    test-api.d.ts.map
    test-api.js
    test-api.js.map
    test-basic-operations.d.ts
    test-basic-operations.d.ts.map
    test-basic-operations.js
    test-basic-operations.js.map
    test-bundles.d.ts
    test-bundles.d.ts.map
    test-bundles.js
    test-bundles.js.map
    test-encryption.d.ts
    test-encryption.d.ts.map
    test-encryption.js
    test-encryption.js.map
    test-ipfs.d.ts
    test-ipfs.d.ts.map
    test-ipfs.js
    test-ipfs.js.map
    test-llm-wrapping.d.ts
    test-llm-wrapping.d.ts.map
    test-llm-wrapping.js
    test-llm-wrapping.js.map
    test-replication.d.ts
    test-replication.d.ts.map
    test-replication.js
    test-replication.js.map
  src/
    __tests__/
      mocks/
        ipfs-http-client.d.ts
        ipfs-http-client.d.ts.map
        ipfs-http-client.js
        ipfs-http-client.js.map
      encryption.test.js
      ipfsClient.test.js
      pipe.test.js
      setup.d.ts
      setup.d.ts.map
      setup.js
      setup.js.map
    tests/
      pipe.test.js
    types/
      index.d.ts
      index.d.ts.map
      index.js
      index.js.map
    utils/
      index.d.ts
      index.d.ts.map
      index.js
      index.js.map
    api.d.ts
    api.d.ts.map
    api.js
    api.js.map
    encryption.d.ts
    encryption.d.ts.map
    encryption.js
    encryption.js.map
    index.d.ts
    index.d.ts.map
    index.js
    index.js.map
    ipfsClient.d.ts
    ipfsClient.d.ts.map
    ipfsClient.js
    ipfsClient.js.map
    pipe.d.ts
    pipe.d.ts.map
    pipe.js
    pipe.js.map
    schema.d.ts
    schema.d.ts.map
    schema.js
    schema.js.map
    types.d.ts
    types.d.ts.map
    types.js
    types.js.map
pipe-core/
  package.json
  tsconfig.json
pipe-docs/
  website/
    .docusaurus/
      docusaurus-plugin-content-blog/
        default/
          p/
            blog-archive-f05.json
            blog-authors-790.json
            blog-authors-all-sebastien-lorber-articles-6eb.json
            blog-authors-yangshun-af2.json
            blog-bd9.json
            blog-tags-df9.json
            blog-tags-docusaurus-f20.json
            blog-tags-facebook-f47.json
            blog-tags-hello-f96.json
            blog-tags-hola-73f.json
          __plugin.json
          blog-post-list-prop-default.json
          blogMetadata-default.json
          site-blog-2019-05-28-first-blog-post-md-e27.json
          site-blog-2019-05-29-long-blog-post-md-736.json
          site-blog-2021-08-01-mdx-blog-post-mdx-593.json
          site-blog-2021-08-26-welcome-index-md-d9f.json
      docusaurus-plugin-content-docs/
        default/
          p/
            docs-175.json
            docs-category-tutorial-basics-ea4.json
            docs-category-tutorial-extras-128.json
            index-466.json
          __plugin.json
          site-docs-api-reference-configuration-md-4f2.json
          site-docs-api-reference-fetch-md-72c.json
          site-docs-api-reference-node-info-md-cc6.json
          site-docs-api-reference-node-status-md-213.json
          site-docs-api-reference-pin-md-e40.json
          site-docs-api-reference-pinned-cids-md-567.json
          site-docs-api-reference-publish-bundle-md-98e.json
          site-docs-api-reference-publish-md-c40.json
          site-docs-api-reference-replicate-md-c5d.json
          site-docs-api-reference-storage-metrics-md-37d.json
          site-docs-api-reference-unpin-md-df6.json
          site-docs-core-concepts-encryption-md-3be.json
          site-docs-core-concepts-inline-referenced-md-231.json
          site-docs-core-concepts-pipebundle-md-6a7.json
          site-docs-core-concepts-piperecord-md-f4d.json
          site-docs-core-concepts-scopes-md-417.json
          site-docs-core-concepts-terminology-md-7d7.json
          site-docs-intro-md-0e3.json
          site-docs-introduction-overview-md-761.json
          site-docs-introduction-problem-md-20e.json
          site-docs-introduction-solution-md-167.json
          site-docs-tutorial-basics-congratulations-md-822.json
          site-docs-tutorial-basics-create-a-blog-post-md-533.json
          site-docs-tutorial-basics-create-a-document-md-1e4.json
          site-docs-tutorial-basics-create-a-page-md-5c8.json
          site-docs-tutorial-basics-deploy-your-site-md-f55.json
          site-docs-tutorial-basics-markdown-features-mdx-18c.json
          site-docs-tutorial-extras-manage-docs-versions-md-dff.json
          site-docs-tutorial-extras-translate-your-site-md-e44.json
          site-docs-usage-examples-fetch-data-md-513.json
          site-docs-usage-examples-pin-unpin-md-8de.json
          site-docs-usage-examples-publish-data-md-b8d.json
          site-docs-usage-examples-publish-hidden-data-md-7d3.json
          site-docs-usage-examples-replicate-data-md-d94.json
          site-docs-usage-examples-work-bundles-md-16e.json
      docusaurus-plugin-content-pages/
        default/
          __plugin.json
          site-src-pages-markdown-page-md-393.json
      docusaurus-plugin-debug/
        default/
          p/
            docusaurus-debug-content-0d5.json
          __plugin.json
      client-modules.js
      codeTranslations.json
      docusaurus.config.mjs
      DONT-EDIT-THIS-FOLDER
      globalData.json
      i18n.json
      registry.js
      routes.js
      routesChunkNames.json
      site-metadata.json
      site-storage.json
scripts/
  test-api.ts
  test-basic-operations.ts
  test-bundles.ts
  test-encryption.ts
  test-ipfs.ts
  test-llm-wrapping.ts
  test-replication.ts
  tsconfig.json
src/
  __tests__/
    mocks/
      ipfs-http-client.ts
    encryption.test.ts
    ipfsClient.test.ts
    pipe.test.ts
    setup.ts
  tests/
    pipe.test.ts
  types/
    index.ts
  utils/
    index.ts
  api.ts
  encryption.ts
  index.ts
  ipfsClient.ts
  pipe.ts
  schema.ts
  types.ts
.eslintrc.json
.gitignore
jest.config.ts
jest.setup.cjs
LICENSE
package.json
README.md
tsconfig.json
tsconfig.scripts.json

================================================================
Files
================================================================

================
File: dist-scripts/scripts/test-api.d.ts
================
export {};
//# sourceMappingURL=test-api.d.ts.map

================
File: dist-scripts/scripts/test-api.d.ts.map
================
{"version":3,"file":"test-api.d.ts","sourceRoot":"","sources":["../../scripts/test-api.ts"],"names":[],"mappings":""}

================
File: dist-scripts/scripts/test-api.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pipe_js_1 = require("../src/pipe.js");
const api_js_1 = require("../src/api.js");
const http_1 = require("http");
async function testApi() {
    console.log('Starting API test...\n');
    const pipe = new pipe_js_1.PipeProtocol({});
    const app = (0, api_js_1.createApi)(pipe);
    let server;
    try {
        // Start the API server
        server = app.listen(0); // Use port 0 to get a random available port
        const address = server.address();
        const port = address.port;
        console.log(`API server started on port ${port}\n`);
        // Helper function to make API requests
        async function makeRequest(method, path, body) {
            return new Promise((resolve, reject) => {
                const options = {
                    hostname: 'localhost',
                    port: port,
                    path: path,
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    }
                };
                const req = (0, http_1.request)(options, (res) => {
                    let data = '';
                    res.on('data', chunk => data += chunk);
                    res.on('end', () => {
                        try {
                            resolve({
                                status: res.statusCode || 500,
                                data: data ? JSON.parse(data) : null
                            });
                        }
                        catch (error) {
                            resolve({
                                status: res.statusCode || 500,
                                data: null
                            });
                        }
                    });
                });
                req.on('error', (error) => {
                    console.error('Request error:', error);
                    reject(error);
                });
                if (body) {
                    req.write(JSON.stringify(body));
                }
                req.end();
            });
        }
        // Test 1: Publish a record via API
        console.log('Test 1: Publishing a record via API...');
        const record = {
            type: 'data',
            content: { message: 'Hello from API!' },
            scope: 'private',
            accessPolicy: { hiddenFromLLM: false },
            encryption: { enabled: false },
            pinned: true
        };
        const publishResponse = await makeRequest('POST', '/publish', record);
        console.log('Publish response:', {
            status: publishResponse.status,
            data: publishResponse.data
        });
        const publishedCid = publishResponse.data?.cid;
        // Test 2: Fetch the published record
        console.log('\nTest 2: Fetching the published record...');
        const fetchResponse = await makeRequest('GET', `/fetch/${publishedCid}/private`);
        console.log('Fetch response:', {
            status: fetchResponse.status,
            data: fetchResponse.data
        });
        // Verify content matches
        const contentMatches = JSON.stringify(fetchResponse.data?.content) === JSON.stringify(record.content);
        console.log('Content matches original:', contentMatches);
        // Test 3: Get node status
        console.log('\nTest 3: Getting node status...');
        const statusResponse = await makeRequest('GET', '/status');
        console.log('Status response:', {
            status: statusResponse.status,
            data: statusResponse.data
        });
        // Test 4: Pin the record
        console.log('\nTest 4: Pinning the record...');
        const pinResponse = await makeRequest('POST', `/pin/${publishedCid}/private`);
        console.log('Pin response:', {
            status: pinResponse.status,
            data: pinResponse.data
        });
        // Test 5: Get pinned CIDs
        console.log('\nTest 5: Getting pinned CIDs...');
        const pinnedResponse = await makeRequest('GET', '/pins/private');
        console.log('Pinned CIDs response:', {
            status: pinnedResponse.status,
            data: pinnedResponse.data
        });
        // Verify the published CID is in the pinned list
        const isPinned = pinnedResponse.data?.includes(publishedCid);
        console.log('Published CID is pinned:', isPinned);
        // Test 6: Publish a bundle
        console.log('\nTest 6: Publishing a bundle...');
        const bundle = {
            schemaRecord: {
                type: 'schema',
                content: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' }
                    }
                },
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false },
                pinned: true
            },
            dataRecord: {
                type: 'data',
                content: { name: 'Test Bundle' },
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false },
                pinned: true
            },
            combinedScope: 'private',
            timestamp: new Date().toISOString()
        };
        const bundleResponse = await makeRequest('POST', '/publish/bundle', bundle);
        console.log('Bundle publish response:', {
            status: bundleResponse.status,
            data: bundleResponse.data
        });
        // Test 7: Error handling
        console.log('\nTest 7: Testing error handling...');
        // Invalid CID
        const invalidFetchResponse = await makeRequest('GET', '/fetch/invalid-cid/private');
        console.log('Invalid CID fetch response:', {
            status: invalidFetchResponse.status,
            error: invalidFetchResponse.data
        });
        // Invalid scope
        const invalidScopeResponse = await makeRequest('GET', `/fetch/${publishedCid}/invalid`);
        console.log('Invalid scope fetch response:', {
            status: invalidScopeResponse.status,
            error: invalidScopeResponse.data
        });
    }
    catch (error) {
        console.error('Error during test:', error);
    }
    finally {
        try {
            if (server) {
                server.close();
            }
            await pipe.stop();
            console.log('\nTest completed, server stopped, and node stopped.');
        }
        catch (error) {
            console.error('Error stopping server/node:', error);
        }
    }
}
// Run the test
(async () => {
    try {
        await testApi();
    }
    catch (error) {
        console.error('Test failed:', error);
        process.exit(1);
    }
})();
//# sourceMappingURL=test-api.js.map

================
File: dist-scripts/scripts/test-api.js.map
================
{"version":3,"file":"test-api.js","sourceRoot":"","sources":["../../scripts/test-api.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/scripts/test-basic-operations.d.ts
================
export {};
//# sourceMappingURL=test-basic-operations.d.ts.map

================
File: dist-scripts/scripts/test-basic-operations.d.ts.map
================
{"version":3,"file":"test-basic-operations.d.ts","sourceRoot":"","sources":["../../scripts/test-basic-operations.ts"],"names":[],"mappings":""}

================
File: dist-scripts/scripts/test-basic-operations.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pipe_js_1 = require("../src/pipe.js");
async function testBasicOperations() {
    console.log('Starting basic operations test...\n');
    let pipe;
    try {
        pipe = new pipe_js_1.PipeProtocol({});
        // Test 1: Publish a simple record
        console.log('Test 1: Publishing a simple record...');
        const record = {
            type: 'data',
            content: { message: 'Hello, IPFS!' },
            scope: 'private',
            accessPolicy: { hiddenFromLLM: false },
            encryption: { enabled: false },
            pinned: true
        };
        const published = await pipe.publishRecord(record);
        console.log('Published record:', {
            cid: published.cid,
            content: published.content
        });
        // Test 2: Fetch the published record
        console.log('\nTest 2: Fetching the published record...');
        if (published.cid) {
            const fetched = await pipe.fetchRecord(published.cid, 'private');
            console.log('Fetched record:', fetched);
            // Verify content matches
            const contentMatches = JSON.stringify(fetched?.content) === JSON.stringify(record.content);
            console.log('Content matches original:', contentMatches);
        }
        // Test 3: Pin the record
        console.log('\nTest 3: Pinning the record...');
        if (published.cid) {
            await pipe.pin(published.cid, 'private');
            console.log('Record pinned successfully');
        }
        // Test 4: Get pinned CIDs
        console.log('\nTest 4: Getting pinned CIDs...');
        const pinnedCids = await pipe.getPinnedCids('private');
        console.log('Pinned CIDs:', pinnedCids);
        // Verify the published CID is in the pinned list
        if (published.cid) {
            const isPinned = pinnedCids.includes(published.cid);
            console.log('Published CID is pinned:', isPinned);
        }
        // Test 5: Get node status
        console.log('\nTest 5: Getting node status...');
        const status = await pipe.getStatus();
        console.log('Node status:', status);
    }
    catch (error) {
        console.error('Error during test:', error);
        if (error instanceof Error) {
            console.error('Error stack:', error.stack);
        }
        process.exit(1);
    }
    finally {
        try {
            if (pipe) {
                await pipe.stop();
                console.log('\nTest completed and node stopped.');
            }
        }
        catch (error) {
            console.error('Error stopping node:', error);
            if (error instanceof Error) {
                console.error('Error stack:', error.stack);
            }
            process.exit(1);
        }
    }
}
// Run the test
(async () => {
    try {
        await testBasicOperations();
    }
    catch (error) {
        console.error('Test failed:', error);
        if (error instanceof Error) {
            console.error('Error stack:', error.stack);
        }
        process.exit(1);
    }
})();
//# sourceMappingURL=test-basic-operations.js.map

================
File: dist-scripts/scripts/test-basic-operations.js.map
================
{"version":3,"file":"test-basic-operations.js","sourceRoot":"","sources":["../../scripts/test-basic-operations.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/scripts/test-bundles.d.ts
================
export {};
//# sourceMappingURL=test-bundles.d.ts.map

================
File: dist-scripts/scripts/test-bundles.d.ts.map
================
{"version":3,"file":"test-bundles.d.ts","sourceRoot":"","sources":["../../scripts/test-bundles.ts"],"names":[],"mappings":""}

================
File: dist-scripts/scripts/test-bundles.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pipe_1 = require("../src/pipe");
async function testBundles() {
    console.log('Starting bundles test...\n');
    const pipe = new pipe_1.PipeProtocol({});
    try {
        // Test 1: Create and publish a bundle with schema and data
        console.log('Test 1: Publishing a bundle with schema and data...');
        const bundle = {
            schemaRecord: {
                type: 'schema',
                content: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' },
                        age: { type: 'number' }
                    },
                    required: ['name', 'age']
                },
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false },
                pinned: true
            },
            dataRecord: {
                type: 'data',
                content: {
                    name: 'John Doe',
                    age: 30
                },
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false },
                pinned: true
            },
            combinedScope: 'private',
            timestamp: new Date().toISOString()
        };
        const published = await pipe.publishBundle(bundle);
        console.log('Published bundle:', {
            schemaRecord: {
                cid: published.schemaRecord.cid,
                content: published.schemaRecord.content
            },
            dataRecord: {
                cid: published.dataRecord.cid,
                content: published.dataRecord.content
            },
            timestamp: published.timestamp
        });
        // Test 2: Fetch and verify bundle records
        console.log('\nTest 2: Fetching bundle records...');
        if (published.schemaRecord.cid && published.dataRecord.cid) {
            const fetchedSchema = await pipe.fetchRecord(published.schemaRecord.cid, 'private');
            const fetchedData = await pipe.fetchRecord(published.dataRecord.cid, 'private');
            console.log('Fetched schema record:', {
                content: fetchedSchema?.content,
                type: fetchedSchema?.type
            });
            console.log('Fetched data record:', {
                content: fetchedData?.content,
                type: fetchedData?.type
            });
            // Verify content matches
            const schemaMatches = JSON.stringify(fetchedSchema?.content) === JSON.stringify(bundle.schemaRecord.content);
            const dataMatches = JSON.stringify(fetchedData?.content) === JSON.stringify(bundle.dataRecord.content);
            console.log('Content matches original:', {
                schema: schemaMatches,
                data: dataMatches
            });
        }
        // Test 3: Create and publish an encrypted bundle
        console.log('\nTest 3: Publishing an encrypted bundle...');
        const encryptedBundle = {
            schemaRecord: {
                type: 'schema',
                content: {
                    type: 'object',
                    properties: {
                        secretKey: { type: 'string' },
                        value: { type: 'string' }
                    },
                    required: ['secretKey', 'value']
                },
                scope: 'private',
                accessPolicy: { hiddenFromLLM: true },
                encryption: {
                    enabled: true,
                    method: 'AES-GCM',
                    keyRef: 'bundleKey1'
                },
                pinned: true
            },
            dataRecord: {
                type: 'data',
                content: {
                    secretKey: 'super-secret',
                    value: 'classified-data'
                },
                scope: 'private',
                accessPolicy: { hiddenFromLLM: true },
                encryption: {
                    enabled: true,
                    method: 'AES-GCM',
                    keyRef: 'bundleKey1'
                },
                pinned: true
            },
            combinedScope: 'private',
            timestamp: new Date().toISOString()
        };
        const publishedEncrypted = await pipe.publishBundle(encryptedBundle);
        console.log('Published encrypted bundle:', {
            schemaRecord: {
                cid: publishedEncrypted.schemaRecord.cid,
                encryption: publishedEncrypted.schemaRecord.encryption
            },
            dataRecord: {
                cid: publishedEncrypted.dataRecord.cid,
                encryption: publishedEncrypted.dataRecord.encryption
            }
        });
        // Test 4: Verify pinning of bundle records
        console.log('\nTest 4: Verifying pinned bundle records...');
        const pinnedCids = await pipe.getPinnedCids('private');
        const schemaPinned = published.schemaRecord.cid && pinnedCids.includes(published.schemaRecord.cid);
        const dataPinned = published.dataRecord.cid && pinnedCids.includes(published.dataRecord.cid);
        const encryptedSchemaPinned = publishedEncrypted.schemaRecord.cid &&
            pinnedCids.includes(publishedEncrypted.schemaRecord.cid);
        const encryptedDataPinned = publishedEncrypted.dataRecord.cid &&
            pinnedCids.includes(publishedEncrypted.dataRecord.cid);
        console.log('Bundle records are pinned:', {
            plainSchema: schemaPinned,
            plainData: dataPinned,
            encryptedSchema: encryptedSchemaPinned,
            encryptedData: encryptedDataPinned
        });
    }
    catch (error) {
        console.error('Error during test:', error);
    }
    finally {
        try {
            await pipe.stop();
            console.log('\nTest completed and node stopped.');
        }
        catch (error) {
            console.error('Error stopping node:', error);
        }
    }
}
// Run the test
(async () => {
    try {
        await testBundles();
    }
    catch (error) {
        console.error('Test failed:', error);
        process.exit(1);
    }
})();
//# sourceMappingURL=test-bundles.js.map

================
File: dist-scripts/scripts/test-bundles.js.map
================
{"version":3,"file":"test-bundles.js","sourceRoot":"","sources":["../../scripts/test-bundles.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/scripts/test-encryption.d.ts
================
export {};
//# sourceMappingURL=test-encryption.d.ts.map

================
File: dist-scripts/scripts/test-encryption.d.ts.map
================
{"version":3,"file":"test-encryption.d.ts","sourceRoot":"","sources":["../../scripts/test-encryption.ts"],"names":[],"mappings":""}

================
File: dist-scripts/scripts/test-encryption.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pipe_1 = require("../src/pipe");
async function testEncryption() {
    console.log('Starting encryption test...\n');
    const pipe = new pipe_1.PipeProtocol({});
    try {
        // Test 1: Publish an encrypted record
        console.log('Test 1: Publishing an encrypted record...');
        const record = {
            type: 'data',
            content: { secretMessage: 'This is a secret!' },
            scope: 'private',
            accessPolicy: { hiddenFromLLM: true },
            encryption: {
                enabled: true,
                method: 'AES-GCM',
                keyRef: 'testKey1'
            },
            pinned: true
        };
        const published = await pipe.publishRecord(record);
        console.log('Published encrypted record:', {
            cid: published.cid,
            content: published.content,
            encryption: published.encryption
        });
        // Verify the content is encrypted (should be different from original)
        const contentChanged = JSON.stringify(published.content) !== JSON.stringify(record.content);
        console.log('Content was encrypted (different from original):', contentChanged);
        // Test 2: Publish a record with different encryption settings
        console.log('\nTest 2: Publishing with different encryption settings...');
        const record2 = {
            type: 'data',
            content: { secretMessage: 'Another secret!' },
            scope: 'private',
            accessPolicy: { hiddenFromLLM: true },
            encryption: {
                enabled: true,
                method: 'AES-GCM',
                keyRef: 'testKey2'
            },
            pinned: true
        };
        const published2 = await pipe.publishRecord(record2);
        console.log('Published second encrypted record:', {
            cid: published2.cid,
            content: published2.content,
            encryption: published2.encryption
        });
        // Test 3: Verify different keys produce different ciphertexts
        console.log('\nTest 3: Verifying different keys produce different ciphertexts...');
        const differentCiphertexts = published.content !== published2.content;
        console.log('Different keys produced different ciphertexts:', differentCiphertexts);
        // Test 4: Publish an unencrypted record
        console.log('\nTest 4: Publishing an unencrypted record...');
        const record3 = {
            type: 'data',
            content: { publicMessage: 'This is public!' },
            scope: 'public',
            accessPolicy: { hiddenFromLLM: false },
            encryption: { enabled: false },
            pinned: true
        };
        const published3 = await pipe.publishRecord(record3);
        console.log('Published unencrypted record:', {
            cid: published3.cid,
            content: published3.content,
            encryption: published3.encryption
        });
        // Verify content matches (should be unchanged)
        const contentUnchanged = JSON.stringify(published3.content) === JSON.stringify(record3.content);
        console.log('Unencrypted content matches original:', contentUnchanged);
        // Test 5: Fetch and verify records
        console.log('\nTest 5: Fetching and verifying records...');
        if (published.cid && published2.cid && published3.cid) {
            // Fetch encrypted records
            const fetched1 = await pipe.fetchRecord(published.cid, 'private');
            const fetched2 = await pipe.fetchRecord(published2.cid, 'private');
            const fetched3 = await pipe.fetchRecord(published3.cid, 'public');
            console.log('Fetched records have encryption enabled:', {
                record1: fetched1?.encryption?.enabled,
                record2: fetched2?.encryption?.enabled,
                record3: fetched3?.encryption?.enabled
            });
            // Verify encryption settings are preserved
            const encryptionPreserved = fetched1?.encryption?.enabled === record.encryption.enabled &&
                fetched2?.encryption?.enabled === record2.encryption.enabled &&
                fetched3?.encryption?.enabled === record3.encryption.enabled;
            console.log('Encryption settings preserved:', encryptionPreserved);
        }
    }
    catch (error) {
        console.error('Error during test:', error);
    }
    finally {
        try {
            await pipe.stop();
            console.log('\nTest completed and node stopped.');
        }
        catch (error) {
            console.error('Error stopping node:', error);
        }
    }
}
// Run the test
(async () => {
    try {
        await testEncryption();
    }
    catch (error) {
        console.error('Test failed:', error);
        process.exit(1);
    }
})();
//# sourceMappingURL=test-encryption.js.map

================
File: dist-scripts/scripts/test-encryption.js.map
================
{"version":3,"file":"test-encryption.js","sourceRoot":"","sources":["../../scripts/test-encryption.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/scripts/test-ipfs.d.ts
================
export {};
//# sourceMappingURL=test-ipfs.d.ts.map

================
File: dist-scripts/scripts/test-ipfs.d.ts.map
================
{"version":3,"file":"test-ipfs.d.ts","sourceRoot":"","sources":["../../scripts/test-ipfs.ts"],"names":[],"mappings":""}

================
File: dist-scripts/scripts/test-ipfs.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ipfsClient_js_1 = require("../src/ipfsClient.js");
async function testIpfsClient() {
    console.log('Starting IPFS Client tests...\n');
    const client = new ipfsClient_js_1.IpfsClient();
    try {
        // Test 1: Node Initialization and Status
        console.log('Test 1: Testing node initialization and status...');
        const status = await client.getStatus();
        console.log('Node status:', status);
        console.assert(status.localNode === true, 'Local node should be initialized');
        console.assert(status.machineNode === true, 'Machine node should be initialized');
        console.assert(status.userNode === true, 'User node should be initialized');
        console.log('✓ Node initialization test passed\n');
        // Test 2: Publishing and Fetching
        console.log('Test 2: Testing publishing and fetching...');
        const testRecord = {
            type: 'data',
            content: { test: 'data' },
            scope: 'private',
            pinned: true
        };
        const publishedRecord = await client.publish(testRecord);
        console.log('Published record:', publishedRecord);
        console.assert(publishedRecord.cid, 'Published record should have a CID');
        if (!publishedRecord.cid) {
            throw new Error('Published record CID is undefined');
        }
        const fetchedContent = await client.fetch(publishedRecord.cid, 'private');
        console.log('Fetched content:', fetchedContent);
        console.assert(JSON.stringify(fetchedContent) === JSON.stringify(testRecord.content), 'Fetched content should match original content');
        console.log('✓ Publishing and fetching test passed\n');
        // Test 3: Pinning Operations
        console.log('Test 3: Testing pinning operations...');
        const pinnedCids = await client.getPinnedCids('private');
        console.log('Pinned CIDs:', pinnedCids);
        console.assert(publishedRecord.cid && pinnedCids.includes(publishedRecord.cid), 'Published record should be in pinned CIDs');
        if (publishedRecord.cid) {
            await client.unpin(publishedRecord.cid, 'private');
            const afterUnpinCids = await client.getPinnedCids('private');
            console.assert(!afterUnpinCids.includes(publishedRecord.cid), 'Unpinned record should not be in pinned CIDs');
        }
        console.log('✓ Pinning operations test passed\n');
        // Test 4: Cross-scope Access Prevention
        console.log('Test 4: Testing cross-scope access prevention...');
        const machineRecord = {
            type: 'data',
            content: { scope: 'machine-data' },
            scope: 'machine',
            pinned: true
        };
        const publishedMachineRecord = await client.publish(machineRecord);
        if (!publishedMachineRecord.cid) {
            throw new Error('Published machine record CID is undefined');
        }
        try {
            await client.fetch(publishedMachineRecord.cid, 'user');
            console.assert(false, 'Should not be able to fetch machine record from user scope');
        }
        catch (error) {
            console.log('✓ Successfully prevented cross-scope access');
        }
        console.log('✓ Cross-scope access prevention test passed\n');
        // Test 5: Storage Metrics and Configuration
        console.log('Test 5: Testing storage metrics and configuration...');
        const metrics = await client.getStorageMetrics('private');
        console.log('Storage metrics:', metrics);
        console.assert(typeof metrics.repoSize === 'number', 'Storage metrics should include repo size');
        const config = await client.getConfiguration('private');
        console.log('Node configuration:', config);
        console.assert(config.peerId, 'Configuration should include peer ID');
        console.log('✓ Storage metrics and configuration test passed\n');
        console.log('All tests completed successfully!');
    }
    catch (error) {
        console.error('Test failed:', error);
        if (error instanceof Error) {
            console.error('Error stack:', error.stack);
        }
        process.exit(1);
    }
    finally {
        await client.stop();
        console.log('IPFS client stopped.');
    }
}
testIpfsClient().catch(error => {
    console.error('Test suite failed:', error);
    process.exit(1);
});
//# sourceMappingURL=test-ipfs.js.map

================
File: dist-scripts/scripts/test-ipfs.js.map
================
{"version":3,"file":"test-ipfs.js","sourceRoot":"","sources":["../../scripts/test-ipfs.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/scripts/test-llm-wrapping.d.ts
================
export {};
//# sourceMappingURL=test-llm-wrapping.d.ts.map

================
File: dist-scripts/scripts/test-llm-wrapping.d.ts.map
================
{"version":3,"file":"test-llm-wrapping.d.ts","sourceRoot":"","sources":["../../scripts/test-llm-wrapping.ts"],"names":[],"mappings":""}

================
File: dist-scripts/scripts/test-llm-wrapping.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pipe_js_1 = require("../src/pipe.js");
async function testLLMWrapping() {
    console.log('Testing LLM function wrapping with Pipe...');
    let pipe;
    try {
        // Initialize PipeProtocol
        pipe = new pipe_js_1.PipeProtocol({
            localNodeEndpoint: 'http://localhost:5001',
            publicNodeEndpoint: 'http://localhost:5001'
        });
        // Mock LLM function that simulates making an API call
        const mockLLMCall = async (prompt) => {
            console.log('Making mock LLM call with prompt:', prompt);
            // Simulate API latency
            await new Promise(resolve => setTimeout(resolve, 1000));
            return `Response to: ${prompt}\nThis is a simulated LLM response that provides an answer to your query.`;
        };
        // Create a tool definition for the LLM function
        const llmTool = {
            name: 'llm-query',
            description: 'Makes a query to a language model and returns its response',
            parameters: {
                type: 'object',
                properties: {
                    prompt: {
                        type: 'string',
                        description: 'The prompt to send to the language model'
                    }
                },
                required: ['prompt']
            },
            call: async (args) => {
                const response = await mockLLMCall(args.prompt);
                return {
                    prompt: args.prompt,
                    response,
                    timestamp: new Date().toISOString(),
                    metadata: {
                        model: 'mock-llm-model',
                        version: '1.0.0'
                    }
                };
            }
        };
        // Wrap the LLM tool with Pipe
        const [wrappedLLMTool] = pipe.wrap([llmTool]);
        // Test the wrapped tool with different prompts
        const prompts = [
            'What is the capital of France?',
            'Explain quantum computing in simple terms',
            'Write a haiku about programming'
        ];
        console.log('\nTesting wrapped LLM tool with multiple prompts...');
        for (const prompt of prompts) {
            console.log(`\nSending prompt: "${prompt}"`);
            const result = await wrappedLLMTool.execute({
                prompt,
                pipeOptions: {
                    scope: 'private',
                    generateSchema: true,
                    pin: true
                }
            });
            console.log('Result CID:', result.cid);
            console.log('Schema CID:', result.schemaCid);
            // Fetch the stored result
            const storedRecord = await pipe.fetchRecord(result.cid, 'private');
            console.log('Stored content:', storedRecord?.content);
        }
        console.log('\nTest completed successfully!');
    }
    catch (error) {
        console.error('Error during test:', error);
        if (error instanceof Error) {
            console.error('Error stack:', error.stack);
        }
        process.exit(1);
    }
    finally {
        try {
            if (pipe) {
                await pipe.stop();
                console.log('\nTest completed and node stopped.');
            }
        }
        catch (error) {
            console.error('Error stopping node:', error);
            if (error instanceof Error) {
                console.error('Error stack:', error.stack);
            }
            process.exit(1);
        }
    }
}
// Run the test
(async () => {
    try {
        await testLLMWrapping();
    }
    catch (error) {
        console.error('Test failed:', error);
        if (error instanceof Error) {
            console.error('Error stack:', error.stack);
        }
        process.exit(1);
    }
})();
//# sourceMappingURL=test-llm-wrapping.js.map

================
File: dist-scripts/scripts/test-llm-wrapping.js.map
================
{"version":3,"file":"test-llm-wrapping.js","sourceRoot":"","sources":["../../scripts/test-llm-wrapping.ts"],"names":[],"mappings":";;AAAA,4CAA8C;AAG9C,KAAK,UAAU,eAAe;IAC5B,OAAO,CAAC,GAAG,CAAC,4CAA4C,CAAC,CAAC;IAE1D,IAAI,IAA8B,CAAC;IAEnC,IAAI,CAAC;QACH,0BAA0B;QAC1B,IAAI,GAAG,IAAI,sBAAY,CAAC;YACtB,iBAAiB,EAAE,uBAAuB;YAC1C,kBAAkB,EAAE,uBAAuB;SAC5C,CAAC,CAAC;QAEH,sDAAsD;QACtD,MAAM,WAAW,GAAG,KAAK,EAAE,MAAc,EAAmB,EAAE;YAC5D,OAAO,CAAC,GAAG,CAAC,mCAAmC,EAAE,MAAM,CAAC,CAAC;YACzD,uBAAuB;YACvB,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;YACxD,OAAO,gBAAgB,MAAM,2EAA2E,CAAC;QAC3G,CAAC,CAAC;QAEF,gDAAgD;QAChD,MAAM,OAAO,GAAS;YACpB,IAAI,EAAE,WAAW;YACjB,WAAW,EAAE,4DAA4D;YACzE,UAAU,EAAE;gBACV,IAAI,EAAE,QAAQ;gBACd,UAAU,EAAE;oBACV,MAAM,EAAE;wBACN,IAAI,EAAE,QAAQ;wBACd,WAAW,EAAE,0CAA0C;qBACxD;iBACF;gBACD,QAAQ,EAAE,CAAC,QAAQ,CAAC;aACrB;YACD,IAAI,EAAE,KAAK,EAAE,IAAwB,EAAE,EAAE;gBACvC,MAAM,QAAQ,GAAG,MAAM,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAChD,OAAO;oBACL,MAAM,EAAE,IAAI,CAAC,MAAM;oBACnB,QAAQ;oBACR,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;oBACnC,QAAQ,EAAE;wBACR,KAAK,EAAE,gBAAgB;wBACvB,OAAO,EAAE,OAAO;qBACjB;iBACF,CAAC;YACJ,CAAC;SACF,CAAC;QAEF,8BAA8B;QAC9B,MAAM,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;QAE9C,+CAA+C;QAC/C,MAAM,OAAO,GAAG;YACd,gCAAgC;YAChC,2CAA2C;YAC3C,iCAAiC;SAClC,CAAC;QAEF,OAAO,CAAC,GAAG,CAAC,qDAAqD,CAAC,CAAC;QAEnE,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;YAC7B,OAAO,CAAC,GAAG,CAAC,sBAAsB,MAAM,GAAG,CAAC,CAAC;YAE7C,MAAM,MAAM,GAAG,MAAM,cAAc,CAAC,OAAO,CAAC;gBAC1C,MAAM;gBACN,WAAW,EAAE;oBACX,KAAK,EAAE,SAAS;oBAChB,cAAc,EAAE,IAAI;oBACpB,GAAG,EAAE,IAAI;iBACV;aACF,CAAC,CAAC;YAEH,OAAO,CAAC,GAAG,CAAC,aAAa,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC;YACvC,OAAO,CAAC,GAAG,CAAC,aAAa,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;YAE7C,0BAA0B;YAC1B,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YACnE,OAAO,CAAC,GAAG,CAAC,iBAAiB,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;QACxD,CAAC;QAED,OAAO,CAAC,GAAG,CAAC,gCAAgC,CAAC,CAAC;IAChD,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC;QAC3C,IAAI,KAAK,YAAY,KAAK,EAAE,CAAC;YAC3B,OAAO,CAAC,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QAC7C,CAAC;QACD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;YAAS,CAAC;QACT,IAAI,CAAC;YACH,IAAI,IAAI,EAAE,CAAC;gBACT,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;gBAClB,OAAO,CAAC,GAAG,CAAC,oCAAoC,CAAC,CAAC;YACpD,CAAC;QACH,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;YAC7C,IAAI,KAAK,YAAY,KAAK,EAAE,CAAC;gBAC3B,OAAO,CAAC,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;YAC7C,CAAC;YACD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;AACH,CAAC;AAED,eAAe;AACf,CAAC,KAAK,IAAI,EAAE;IACV,IAAI,CAAC;QACH,MAAM,eAAe,EAAE,CAAC;IAC1B,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC;QACrC,IAAI,KAAK,YAAY,KAAK,EAAE,CAAC;YAC3B,OAAO,CAAC,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QAC7C,CAAC;QACD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;AACH,CAAC,CAAC,EAAE,CAAC"}

================
File: dist-scripts/scripts/test-replication.d.ts
================
export {};
//# sourceMappingURL=test-replication.d.ts.map

================
File: dist-scripts/scripts/test-replication.d.ts.map
================
{"version":3,"file":"test-replication.d.ts","sourceRoot":"","sources":["../../scripts/test-replication.ts"],"names":[],"mappings":""}

================
File: dist-scripts/scripts/test-replication.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pipe_js_1 = require("../src/pipe.js");
async function testReplication() {
    console.log('Starting replication test...\n');
    const pipe = new pipe_js_1.PipeProtocol({
        publicNodeEndpoint: 'https://ipfs.infura.io:5001'
    });
    try {
        // Test 1: Publish a record to private scope
        console.log('Test 1: Publishing a record to private scope...');
        const privateRecord = {
            type: 'data',
            content: { message: 'Private data' },
            scope: 'private',
            accessPolicy: { hiddenFromLLM: false },
            encryption: { enabled: false },
            pinned: true
        };
        const publishedPrivate = await pipe.publishRecord(privateRecord);
        console.log('Published private record:', {
            cid: publishedPrivate.cid,
            scope: publishedPrivate.scope
        });
        // Test 2: Replicate to public scope
        console.log('\nTest 2: Replicating to public scope...');
        if (publishedPrivate.cid) {
            await pipe.replicate(publishedPrivate.cid, 'private', 'public');
            console.log('Record replicated to public scope');
        }
        // Test 3: Verify record is accessible in both scopes
        console.log('\nTest 3: Verifying record accessibility...');
        if (publishedPrivate.cid) {
            const privateAccess = await pipe.fetchRecord(publishedPrivate.cid, 'private');
            const publicAccess = await pipe.fetchRecord(publishedPrivate.cid, 'public');
            console.log('Record accessibility:', {
                privateScope: Boolean(privateAccess),
                publicScope: Boolean(publicAccess)
            });
        }
        // Test 4: Test machine scope
        console.log('\nTest 4: Testing machine scope...');
        const machineRecord = {
            type: 'data',
            content: { message: 'Machine-specific data' },
            scope: 'machine',
            accessPolicy: { hiddenFromLLM: false },
            encryption: { enabled: false },
            pinned: true
        };
        const publishedMachine = await pipe.publishRecord(machineRecord);
        console.log('Published machine record:', {
            cid: publishedMachine.cid,
            scope: publishedMachine.scope
        });
        // Test 5: Test user scope
        console.log('\nTest 5: Testing user scope...');
        const userRecord = {
            type: 'data',
            content: { message: 'User-specific data' },
            scope: 'user',
            accessPolicy: { hiddenFromLLM: false },
            encryption: { enabled: false },
            pinned: true
        };
        const publishedUser = await pipe.publishRecord(userRecord);
        console.log('Published user record:', {
            cid: publishedUser.cid,
            scope: publishedUser.scope
        });
        // Test 6: Verify pinning across scopes
        console.log('\nTest 6: Verifying pinning across scopes...');
        const privatePins = await pipe.getPinnedCids('private');
        const publicPins = await pipe.getPinnedCids('public');
        const machinePins = await pipe.getPinnedCids('machine');
        const userPins = await pipe.getPinnedCids('user');
        console.log('Pinned CIDs by scope:', {
            private: privatePins.length,
            public: publicPins.length,
            machine: machinePins.length,
            user: userPins.length
        });
        // Test 7: Test scope isolation
        console.log('\nTest 7: Testing scope isolation...');
        if (publishedMachine.cid && publishedUser.cid) {
            try {
                await pipe.fetchRecord(publishedMachine.cid, 'user');
                console.log('Warning: Machine record accessible from user scope');
            }
            catch (error) {
                console.log('Expected: Machine record not accessible from user scope');
            }
            try {
                await pipe.fetchRecord(publishedUser.cid, 'machine');
                console.log('Warning: User record accessible from machine scope');
            }
            catch (error) {
                console.log('Expected: User record not accessible from machine scope');
            }
        }
    }
    catch (error) {
        console.error('Error during test:', error);
        if (error instanceof Error) {
            console.error('Error stack:', error.stack);
        }
        process.exit(1);
    }
    finally {
        try {
            await pipe.stop();
            console.log('\nTest completed and node stopped.');
        }
        catch (error) {
            console.error('Error stopping node:', error);
            if (error instanceof Error) {
                console.error('Error stack:', error.stack);
            }
            process.exit(1);
        }
    }
}
// Run the test
(async () => {
    try {
        await testReplication();
    }
    catch (error) {
        console.error('Test failed:', error);
        if (error instanceof Error) {
            console.error('Error stack:', error.stack);
        }
        process.exit(1);
    }
})();
//# sourceMappingURL=test-replication.js.map

================
File: dist-scripts/scripts/test-replication.js.map
================
{"version":3,"file":"test-replication.js","sourceRoot":"","sources":["../../scripts/test-replication.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/src/__tests__/mocks/ipfs-http-client.d.ts
================
export declare const mockDataStore: Map<string, any>;
export declare const mockPinnedCids: Set<string>;
export declare const mockRecordStore: Map<string, any>;
export declare const create: jest.Mock<{
    add: jest.Mock<any, any, any>;
    cat: jest.Mock<any, any, any>;
    pin: {
        add: jest.Mock<any, any, any>;
        rm: jest.Mock<any, any, any>;
        ls: jest.Mock<any, any, any>;
    };
    id: jest.Mock<any, any, any>;
    stats: {
        repo: jest.Mock<any, any, any>;
    };
    stop: jest.Mock<any, any, any>;
    getEndpointConfig: jest.Mock<any, any, any>;
}, [], any>;
export type { IPFSHTTPClient } from 'ipfs-http-client';
//# sourceMappingURL=ipfs-http-client.d.ts.map

================
File: dist-scripts/src/__tests__/mocks/ipfs-http-client.d.ts.map
================
{"version":3,"file":"ipfs-http-client.d.ts","sourceRoot":"","sources":["../../../../src/__tests__/mocks/ipfs-http-client.ts"],"names":[],"mappings":"AACA,eAAO,MAAM,aAAa,kBAAyB,CAAC;AACpD,eAAO,MAAM,cAAc,aAAoB,CAAC;AAmDhD,eAAO,MAAM,eAAe,kBAAyB,CAAC;AAWtD,eAAO,MAAM,MAAM;;;;;;;;;;;;;;WAAgC,CAAC;AACpD,YAAY,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC"}

================
File: dist-scripts/src/__tests__/mocks/ipfs-http-client.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.mockRecordStore = exports.mockPinnedCids = exports.mockDataStore = void 0;
// Create a shared data store for all tests
exports.mockDataStore = new Map();
exports.mockPinnedCids = new Set();
const mockIPFSClient = {
    add: jest.fn().mockImplementation(async (data) => {
        const cid = `QmTest${Math.random().toString(36).substring(7)}`;
        // Store the data as a string, just like the real IPFS client
        const stringData = typeof data === 'string' ? data : JSON.stringify(data);
        exports.mockDataStore.set(cid, stringData);
        return { path: cid };
    }),
    cat: jest.fn().mockImplementation(function* (cid) {
        const data = exports.mockDataStore.get(cid);
        if (!data) {
            throw new Error('CID not found');
        }
        // Return the data as a Buffer, just like the real IPFS client
        yield Buffer.from(data);
    }),
    pin: {
        add: jest.fn().mockImplementation(async (cid) => {
            exports.mockPinnedCids.add(cid);
            return undefined;
        }),
        rm: jest.fn().mockImplementation(async (cid) => {
            exports.mockPinnedCids.delete(cid);
            return undefined;
        }),
        ls: jest.fn().mockImplementation(function* () {
            for (const cid of exports.mockPinnedCids) {
                yield { cid: { toString: () => cid } };
            }
        })
    },
    id: jest.fn().mockResolvedValue({ id: 'test-node' }),
    stats: {
        repo: jest.fn().mockResolvedValue({
            repoSize: 1000,
            storageMax: 10000,
            numObjects: exports.mockDataStore.size
        })
    },
    stop: jest.fn().mockResolvedValue(undefined),
    getEndpointConfig: jest.fn().mockReturnValue('http://localhost:5001')
};
// Create a store for record metadata
exports.mockRecordStore = new Map();
// Override the add method to store both content and record metadata
mockIPFSClient.add = jest.fn().mockImplementation(async (data) => {
    const cid = `QmTest${Math.random().toString(36).substring(7)}`;
    // Store the data as a string, just like the real IPFS client
    const stringData = typeof data === 'string' ? data : JSON.stringify(data);
    exports.mockDataStore.set(cid, stringData);
    return { path: cid };
});
exports.create = jest.fn(() => mockIPFSClient);
//# sourceMappingURL=ipfs-http-client.js.map

================
File: dist-scripts/src/__tests__/mocks/ipfs-http-client.js.map
================
{"version":3,"file":"ipfs-http-client.js","sourceRoot":"","sources":["../../../../src/__tests__/mocks/ipfs-http-client.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/src/__tests__/encryption.test.js
================
import { EncryptionService } from '../encryption';
describe('EncryptionService', () => {
    let encryption;
    beforeEach(() => {
        encryption = new EncryptionService();
    });
    describe('encrypt and decrypt', () => {
        it('should successfully encrypt and decrypt data', async () => {
            const plaintext = 'Hello, World!';
            const encrypted = await encryption.encrypt(plaintext);
            const decrypted = await encryption.decrypt(encrypted);
            expect(decrypted).toBe(plaintext);
        });
        it('should handle empty strings', async () => {
            const plaintext = '';
            const encrypted = await encryption.encrypt(plaintext);
            const decrypted = await encryption.decrypt(encrypted);
            expect(decrypted).toBe(plaintext);
        });
        it('should handle long strings', async () => {
            const plaintext = 'a'.repeat(1000);
            const encrypted = await encryption.encrypt(plaintext);
            const decrypted = await encryption.decrypt(encrypted);
            expect(decrypted).toBe(plaintext);
        });
        it('should handle special characters', async () => {
            const plaintext = '!@#$%^&*()_+-=[]{}|;:,.<>?';
            const encrypted = await encryption.encrypt(plaintext);
            const decrypted = await encryption.decrypt(encrypted);
            expect(decrypted).toBe(plaintext);
        });
        it('should handle unicode characters', async () => {
            const plaintext = '你好，世界！🌍';
            const encrypted = await encryption.encrypt(plaintext);
            const decrypted = await encryption.decrypt(encrypted);
            expect(decrypted).toBe(plaintext);
        });
        it('should handle JSON strings', async () => {
            const data = { hello: 'world', num: 42, arr: [1, 2, 3] };
            const plaintext = JSON.stringify(data);
            const encrypted = await encryption.encrypt(plaintext);
            const decrypted = await encryption.decrypt(encrypted);
            expect(decrypted).toBe(plaintext);
        });
        it('should handle different encryption methods', async () => {
            const plaintext = 'Test different methods';
            const encrypted = await encryption.encrypt(plaintext, 'AES-GCM');
            const decrypted = await encryption.decrypt(encrypted, 'AES-GCM');
            expect(decrypted).toBe(plaintext);
        });
        it('should handle different key references', async () => {
            const plaintext = 'Test different keys';
            const keyRef = 'customKey';
            const encrypted = await encryption.encrypt(plaintext, 'AES-GCM', keyRef);
            const decrypted = await encryption.decrypt(encrypted, 'AES-GCM', keyRef);
            expect(decrypted).toBe(plaintext);
        });
    });
    describe('key management', () => {
        it('should export and import keys', async () => {
            const keyRef = 'testKey';
            const plaintext = 'Test export/import';
            // Encrypt with original key
            const encrypted = await encryption.encrypt(plaintext, 'AES-GCM', keyRef);
            // Export the key
            const exportedKey = await encryption.exportKey(keyRef);
            // Create new encryption service
            const newEncryption = new EncryptionService();
            // Import the key
            await newEncryption.importKey(exportedKey, 'AES-GCM', keyRef);
            // Decrypt with imported key
            const decrypted = await newEncryption.decrypt(encrypted, 'AES-GCM', keyRef);
            expect(decrypted).toBe(plaintext);
        });
        it('should handle multiple keys', async () => {
            const plaintext = 'test';
            const encrypted1 = await encryption.encrypt(plaintext, 'AES-GCM', 'key1', true);
            const encrypted2 = await encryption.encrypt(plaintext, 'AES-GCM', 'key2', true);
            const decrypted1 = await encryption.decrypt(encrypted1, 'AES-GCM', 'key1');
            const decrypted2 = await encryption.decrypt(encrypted2, 'AES-GCM', 'key2');
            expect(decrypted1).toBe(plaintext);
            expect(decrypted2).toBe(plaintext);
            expect(encrypted1).not.toBe(encrypted2);
        });
        it.skip('should clear keys correctly', async () => {
            const plaintext = 'test';
            const keyRef = 'testKey';
            const encrypted = await encryption.encrypt(plaintext, 'AES-GCM', keyRef, true);
            encryption.clearKeys();
            const encrypted2 = await encryption.encrypt(plaintext, 'AES-GCM', keyRef, true);
            expect(encrypted).not.toBe(encrypted2);
        });
    });
    describe('error handling', () => {
        it('should throw error for invalid encryption method', async () => {
            await expect(encryption.encrypt('test', 'INVALID')).rejects.toThrow();
        });
        it('should throw error for invalid ciphertext', async () => {
            await expect(encryption.decrypt('invalid-base64!')).rejects.toThrow();
        });
        it('should throw error for tampered ciphertext', async () => {
            const encrypted = await encryption.encrypt('test');
            const tampered = encrypted.slice(0, -5) + 'XXXXX'; // Modify the end
            await expect(encryption.decrypt(tampered)).rejects.toThrow();
        });
        it('should throw error for wrong key', async () => {
            const encrypted = await encryption.encrypt('test', 'AES-GCM', 'key1');
            await expect(encryption.decrypt(encrypted, 'AES-GCM', 'key2')).rejects.toThrow();
        });
        it('should throw error for invalid key export reference', async () => {
            await expect(encryption.exportKey('nonexistent-key')).rejects.toThrow();
        });
        it('should throw error for invalid key import data', async () => {
            const invalidKey = { k: 'invalid-key-data' };
            await expect(encryption.importKey(invalidKey)).rejects.toThrow();
        });
        it('should handle encryption info extraction errors', () => {
            const result = encryption.getEncryptionInfo('not-encrypted-data');
            expect(result).toBeNull();
        });
        it('should handle malformed encryption info', () => {
            const malformed = Buffer.from('{"invalid":"json').toString('base64');
            const result = encryption.getEncryptionInfo(`encrypted:${malformed}`);
            expect(result).toBeNull();
        });
    });
});

================
File: dist-scripts/src/__tests__/ipfsClient.test.js
================
import { IpfsClient } from '../ipfsClient';
import { mockDataStore, mockPinnedCids } from './mocks/ipfs-http-client';
describe('IpfsClient', () => {
    let ipfsClient;
    beforeEach(async () => {
        mockDataStore.clear();
        mockPinnedCids.clear();
        ipfsClient = new IpfsClient({
            endpoint: 'http://localhost:5001'
        });
        await ipfsClient.init('http://localhost:5001', 'http://localhost:5001');
    });
    afterEach(async () => {
        await ipfsClient.stop();
    });
    describe('publish and fetch', () => {
        it('should successfully publish and fetch data', async () => {
            const record = {
                content: 'test data',
                type: 'data',
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            };
            const published = await ipfsClient.publish(record);
            expect(published.cid).toBeDefined();
            const fetched = await ipfsClient.fetch(published.cid, 'private');
            expect(fetched).toBeDefined();
            expect(fetched?.content).toBe('test data');
        });
        it('should handle JSON data', async () => {
            const data = { message: 'Hello, World!' };
            const record = {
                content: data,
                type: 'data',
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            };
            const published = await ipfsClient.publish(record);
            expect(published.cid).toBeDefined();
            const fetched = await ipfsClient.fetch(published.cid, 'private');
            expect(fetched).toBeDefined();
            expect(fetched?.content).toEqual(data);
        });
        it('should handle different scopes', async () => {
            const record = {
                content: 'test data',
                type: 'data',
                scope: 'public',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            };
            const published = await ipfsClient.publish(record);
            expect(published.cid).toBeDefined();
            const fetched = await ipfsClient.fetch(published.cid, 'public');
            expect(fetched).toBeDefined();
            expect(fetched?.content).toBe('test data');
        });
    });
    describe('pin management', () => {
        it('should pin and unpin content', async () => {
            const record = {
                content: 'test data',
                type: 'data',
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            };
            const published = await ipfsClient.publish(record);
            await ipfsClient.pin(published.cid, 'private');
            const pinnedCids = await ipfsClient.getPinnedCids('private');
            expect(pinnedCids).toContain(published.cid);
            await ipfsClient.unpin(published.cid, 'private');
            const updatedPinnedCids = await ipfsClient.getPinnedCids('private');
            expect(updatedPinnedCids).not.toContain(published.cid);
        });
    });
    describe('replication', () => {
        it('should replicate content between scopes', async () => {
            const record = {
                content: 'test data',
                type: 'data',
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            };
            const published = await ipfsClient.publish(record);
            await ipfsClient.replicate(published.cid, 'private', 'public');
            const fetched = await ipfsClient.fetch(published.cid, 'public');
            expect(fetched).toBeDefined();
            expect(fetched?.content).toBe('test data');
        });
    });
    describe('node management', () => {
        it('should return node status', () => {
            const status = ipfsClient.getStatus();
            expect(status).toBe(true);
        });
        it('should return node info', async () => {
            const info = await ipfsClient.getNodeInfo('private');
            expect(info).toBeDefined();
            expect(info.id).toBe('test-node');
        });
        it('should return storage metrics', async () => {
            const metrics = await ipfsClient.getStorageMetrics('private');
            expect(metrics).toBeDefined();
            expect(metrics.repoSize).toBe(1000);
            expect(metrics.storageMax).toBe(10000);
            expect(metrics.numObjects).toBe(0); // Should be 0 since we clear the store before each test
        });
        it('should return node configuration', async () => {
            const config = await ipfsClient.getConfiguration('private');
            expect(config).toBeDefined();
            expect(config.endpoint).toBe('http://localhost:5001');
        });
    });
    describe('error handling', () => {
        it('should handle non-existent CID', async () => {
            const result = await ipfsClient.fetch('QmNonExistent', 'private');
            expect(result).toBeNull();
        });
        it('should handle invalid scope', async () => {
            const record = {
                content: 'test data',
                type: 'data',
                scope: 'invalid',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            };
            await expect(ipfsClient.publish(record)).rejects.toThrow();
        });
        it('should handle stop and restart', async () => {
            await ipfsClient.stop();
            expect(ipfsClient.getStatus()).toBe(false);
            await ipfsClient.init('http://localhost:5001', 'http://localhost:5001');
            expect(ipfsClient.getStatus()).toBe(true);
        });
    });
});

================
File: dist-scripts/src/__tests__/pipe.test.js
================
import { PipeProtocol } from '../pipe';
import { mockDataStore } from './mocks/ipfs-http-client';
describe('PipeProtocol', () => {
    let pipe;
    beforeEach(() => {
        mockDataStore.clear();
        pipe = new PipeProtocol({
            localNodeEndpoint: 'http://localhost:5001',
            publicNodeEndpoint: 'http://localhost:5001'
        });
    });
    afterEach(async () => {
        await pipe.stop();
    });
    describe('data storage', () => {
        it('should store and retrieve data', async () => {
            const data = { message: 'Hello, World!' };
            const { cid } = await pipe.storeData(data);
            expect(cid).toBeDefined();
            const record = await pipe.fetchRecord(cid, 'private');
            expect(record).toBeDefined();
            expect(record?.content).toEqual(data);
        });
        it('should generate schema when storing data', async () => {
            const data = {
                name: 'John Doe',
                age: 30,
                email: 'john@example.com'
            };
            const { cid, schemaCid } = await pipe.storeData(data);
            expect(cid).toBeDefined();
            expect(schemaCid).toBeDefined();
            const schemaRecord = await pipe.fetchRecord(schemaCid, 'private');
            expect(schemaRecord).toBeDefined();
            expect(schemaRecord?.content).toMatchObject({
                $schema: 'http://json-schema.org/draft-07/schema#',
                type: 'object',
                properties: {
                    name: { type: 'string' },
                    age: { type: 'number' },
                    email: { type: 'string' }
                }
            });
        });
        it('should handle storing data without schema', async () => {
            const data = { message: 'No Schema' };
            const { cid, schemaCid } = await pipe.storeData(data, { generateSchema: false });
            expect(cid).toBeDefined();
            expect(schemaCid).toBeNull();
        });
    });
    describe('record management', () => {
        it('should publish and fetch records', async () => {
            const record = {
                content: { message: 'Test Record' },
                type: 'data',
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            };
            const published = await pipe.publishRecord(record);
            expect(published.cid).toBeDefined();
            const fetched = await pipe.fetchRecord(published.cid, 'private');
            expect(fetched).toBeDefined();
            expect(fetched?.content).toEqual(record.content);
        });
        it('should handle encrypted records', async () => {
            const record = {
                content: { message: 'Secret Data' },
                type: 'data',
                scope: 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: {
                    enabled: true,
                    keyRef: 'test-key',
                    method: 'AES-GCM'
                }
            };
            const published = await pipe.publishRecord(record);
            expect(published.cid).toBeDefined();
            expect(published.encryption.ciphertext).toBe(true);
            const fetched = await pipe.fetchRecord(published.cid, 'private');
            expect(fetched).toBeDefined();
            expect(fetched?.content).toEqual(record.content);
            expect(fetched?.encryption.ciphertext).toBe(false);
        });
    });
    describe('bundle management', () => {
        it('should publish and fetch bundles', async () => {
            const bundle = {
                schemaRecord: {
                    content: {
                        $schema: 'http://json-schema.org/draft-07/schema#',
                        type: 'object',
                        properties: {
                            message: { type: 'string' }
                        }
                    },
                    type: 'schema',
                    scope: 'private',
                    accessPolicy: { hiddenFromLLM: false },
                    encryption: { enabled: false }
                },
                dataRecord: {
                    content: { message: 'Test Bundle' },
                    type: 'data',
                    scope: 'private',
                    accessPolicy: { hiddenFromLLM: false },
                    encryption: { enabled: false }
                }
            };
            const published = await pipe.publishBundle(bundle);
            expect(published.schemaRecord.cid).toBeDefined();
            expect(published.dataRecord.cid).toBeDefined();
            expect(published.timestamp).toBeDefined();
            const fetchedSchema = await pipe.fetchRecord(published.schemaRecord.cid, 'private');
            const fetchedData = await pipe.fetchRecord(published.dataRecord.cid, 'private');
            expect(fetchedSchema?.content).toEqual(bundle.schemaRecord.content);
            expect(fetchedData?.content).toEqual(bundle.dataRecord.content);
        });
    });
    describe('tool wrapping', () => {
        it('should wrap tools and store their results', async () => {
            const mockTool = {
                name: 'testTool',
                description: 'A test tool',
                parameters: {
                    type: 'object',
                    properties: {
                        input: { type: 'string' }
                    }
                },
                call: async (args) => ({ result: args.input })
            };
            const wrappedTools = pipe.wrap([mockTool]);
            expect(wrappedTools).toHaveLength(1);
            const result = await wrappedTools[0].execute({ input: 'test' });
            expect(result.cid).toBeDefined();
            expect(result.schemaCid).toBeDefined();
            expect(result.description).toBe(mockTool.description);
            const storedResult = await pipe.fetchRecord(result.cid, 'private');
            expect(storedResult?.content).toEqual({ result: 'test' });
        });
        it('should handle tool execution with custom options', async () => {
            const mockTool = {
                name: 'testTool',
                description: 'A test tool',
                parameters: {
                    type: 'object',
                    properties: {
                        input: { type: 'string' }
                    }
                },
                call: async (args) => ({ result: args.input })
            };
            const wrappedTools = pipe.wrap([mockTool]);
            const result = await wrappedTools[0].execute({
                input: 'test',
                pipeOptions: {
                    scope: 'public',
                    generateSchema: false,
                    pin: true
                }
            });
            expect(result.cid).toBeDefined();
            expect(result.schemaCid).toBeNull();
            const storedResult = await pipe.fetchRecord(result.cid, 'public');
            expect(storedResult?.content).toEqual({ result: 'test' });
        });
    });
    describe('hooks', () => {
        it('should process pre-store hooks', async () => {
            const hook = {
                name: 'testHook',
                trigger: 'pre-store',
                handler: async (data) => ({
                    ...data,
                    processed: true
                })
            };
            pipe.addHook(hook);
            const { cid } = await pipe.storeData({ message: 'Test' });
            const record = await pipe.fetchRecord(cid, 'private');
            expect(record?.content).toHaveProperty('processed', true);
        });
        it('should process post-store hooks', async () => {
            let hookCalled = false;
            const hook = {
                name: 'testHook',
                trigger: 'post-store',
                handler: async (data) => {
                    hookCalled = true;
                    return data;
                }
            };
            pipe.addHook(hook);
            await pipe.storeData({ message: 'Test' });
            expect(hookCalled).toBe(true);
        });
    });
});

================
File: dist-scripts/src/__tests__/setup.d.ts
================
declare const mockRandomValues: Uint8Array<ArrayBuffer>;
declare const originalCrypto: Crypto;
//# sourceMappingURL=setup.d.ts.map

================
File: dist-scripts/src/__tests__/setup.d.ts.map
================
{"version":3,"file":"setup.d.ts","sourceRoot":"","sources":["../../../src/__tests__/setup.ts"],"names":[],"mappings":"AAIA,QAAA,MAAM,gBAAgB,yBAEpB,CAAC;AAEH,QAAA,MAAM,cAAc,QAAgB,CAAC"}

================
File: dist-scripts/src/__tests__/setup.js
================
"use strict";
// Increase timeout for IPFS operations
jest.setTimeout(10000);
// Mock crypto for consistent test results
const mockRandomValues = new Uint8Array([
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
]);
const originalCrypto = global.crypto;
global.crypto = {
    ...originalCrypto,
    getRandomValues: (array) => {
        if (array instanceof Uint8Array) {
            array.set(mockRandomValues.subarray(0, array.length));
        }
        return array;
    }
};
// Clean up function to restore original crypto
afterAll(() => {
    global.crypto = originalCrypto;
});
//# sourceMappingURL=setup.js.map

================
File: dist-scripts/src/__tests__/setup.js.map
================
{"version":3,"file":"setup.js","sourceRoot":"","sources":["../../../src/__tests__/setup.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AAEvB,0CAA0C;AAC1C,MAAM,gBAAgB,GAAG,IAAI,UAAU,CAAC;IACtC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;CACtC,CAAC,CAAC;AAEH,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC;AACrC,MAAM,CAAC,MAAM,GAAG;IACd,GAAG,cAAc;IACjB,eAAe,EAAE,CAAmC,KAAQ,EAAK,EAAE;QACjE,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;YAChC,KAAK,CAAC,GAAG,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QACxD,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF,CAAC;AAEF,+CAA+C;AAC/C,QAAQ,CAAC,GAAG,EAAE;IACZ,MAAM,CAAC,MAAM,GAAG,cAAc,CAAC;AACjC,CAAC,CAAC,CAAC"}

================
File: dist-scripts/src/tests/pipe.test.js
================
import { PipeProtocol } from '../pipe.js';
import { pipe } from '../index';
import { createApi } from '../api';
import { expect, describe, test, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';
const mockRecord = {
    type: 'data',
    content: { test: 'data' },
    scope: 'private',
    accessPolicy: { hiddenFromLLM: false },
    encryption: { enabled: false },
    pinned: true
};
const mockBundle = {
    schemaRecord: {
        type: 'schema',
        content: {
            type: 'object',
            properties: {
                name: { type: 'string' },
                age: { type: 'number' }
            },
            required: ['name', 'age']
        },
        scope: 'private',
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
    },
    dataRecord: {
        type: 'data',
        content: {
            name: 'John Doe',
            age: 30
        },
        scope: 'private',
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
    },
    combinedScope: 'private',
    timestamp: new Date().toISOString()
};
describe('PipeProtocol', () => {
    let pipe;
    beforeEach(() => {
        pipe = new PipeProtocol({});
    });
    afterEach(async () => {
        await pipe.stop();
    });
    test('should publish and fetch a record', async () => {
        const published = await pipe.publishRecord(mockRecord);
        expect(published.cid).toBeDefined();
        if (published.cid) {
            const fetched = await pipe.fetchRecord(published.cid, 'private');
            expect(fetched?.content).toEqual(mockRecord.content);
        }
    });
    test('should get node status', async () => {
        const status = await pipe.getStatus();
        expect(status).toEqual({
            localNode: true,
            publicNode: false
        });
    });
    test('should get node info', async () => {
        const info = await pipe.getNodeInfo('private');
        expect(info).toEqual({
            peerId: expect.any(String)
        });
    });
    test('should get storage metrics', async () => {
        const metrics = await pipe.getStorageMetrics('private');
        expect(metrics).toEqual({
            repoSize: 0
        });
    });
    test('should get configuration', async () => {
        const config = await pipe.getConfiguration('private');
        expect(config).toEqual({
            peerId: expect.any(String),
            addrs: []
        });
    });
});
describe('Pipe Core Functionality', () => {
    let pipeProtocol;
    let server;
    let port;
    beforeAll(async () => {
        const options = {
            publicNodeEndpoint: 'https://ipfs.infura.io:5001'
        };
        pipeProtocol = new PipeProtocol(options);
        const app = createApi(pipeProtocol);
        server = app.listen(0);
        port = server.address().port;
    });
    afterAll(async () => {
        server.close();
        await pipeProtocol.stop();
    });
    test('Tool Wrapping', () => {
        const tools = [{
                name: 'weatherTool',
                description: 'Get weather data',
                call: () => 'Sunny'
            }];
        const wrapped = pipe(tools);
        const pipeTool = wrapped.find(t => t.name === 'Pipe');
        expect(pipeTool).toBeDefined();
    });
    test('Should publish a record and return a cid', async () => {
        const record = await pipeProtocol.publishRecord(mockRecord);
        expect(record.cid).toBeDefined();
    });
    test('Should publish a record and then fetch it', async () => {
        const published = await pipeProtocol.publishRecord(mockRecord);
        const fetched = await pipeProtocol.fetchRecord(published.cid || '', 'private');
        expect(fetched?.content).toEqual(mockRecord.content);
    });
    test('Should publish a bundle and return two cids', async () => {
        const bundle = await pipeProtocol.publishBundle(mockBundle);
        expect(bundle.dataRecord.cid).toBeDefined();
        expect(bundle.schemaRecord.cid).toBeDefined();
    });
    test('Should pin a record', async () => {
        const published = await pipeProtocol.publishRecord(mockRecord);
        await pipeProtocol.pin(published.cid || '', 'private');
    });
    test('Should unpin a record', async () => {
        const published = await pipeProtocol.publishRecord(mockRecord);
        await pipeProtocol.unpin(published.cid || '', 'private');
    });
    test('Should replicate a record', async () => {
        const published = await pipeProtocol.publishRecord(mockRecord);
        await pipeProtocol.replicate(published.cid || '', 'private', 'public');
    });
    test('Should get node status', async () => {
        const status = await pipeProtocol.getStatus();
        expect(status.localNode).toBe(true);
        expect(status.publicNode).toBe(true);
    });
    test('Should get node info', async () => {
        const info = await pipeProtocol.getNodeInfo('private');
        expect(info.peerId).toBeDefined();
    });
    test('Should be able to post a record to the api and return a record', async () => {
        const response = await fetch(`http://localhost:${port}/publish`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(mockRecord)
        });
        const data = await response.json();
        expect(data.cid).toBeDefined();
    });
    test('Should be able to get a record from the api', async () => {
        const published = await pipeProtocol.publishRecord(mockRecord);
        const response = await fetch(`http://localhost:${port}/fetch?cid=${published.cid}&scope=private`);
        const data = await response.json();
        expect(data.content).toEqual(mockRecord.content);
    });
    test('Should be able to get the node status from the api', async () => {
        const response = await fetch(`http://localhost:${port}/node-status`);
        const status = await response.json();
        expect(status.localNode).toBe(true);
        expect(status.publicNode).toBe(true);
    });
    test('Should be able to get the node info from the api', async () => {
        const response = await fetch(`http://localhost:${port}/node-info?scope=private`);
        const info = await response.json();
        expect(info.peerId).toBeDefined();
    });
    test('Should be able to get storage metrics from the api', async () => {
        const response = await fetch(`http://localhost:${port}/storage-metrics?scope=private`);
        const metrics = await response.json();
        expect(metrics.repoSize).toBeDefined();
    });
    test('Should be able to get the pinned CIDs from the api', async () => {
        const record = await pipeProtocol.publishRecord(mockRecord);
        await pipeProtocol.pin(record.cid || '', 'private');
        const response = await fetch(`http://localhost:${port}/pinned-cids?scope=private`);
        const pins = await response.json();
        expect(pins).toContain(record.cid);
    });
    test('Should be able to get the configuration from the api', async () => {
        const response = await fetch(`http://localhost:${port}/configuration?scope=private`);
        const config = await response.json();
        expect(config.peerId).toBeDefined();
        expect(config.addrs).toBeDefined();
    });
});

================
File: dist-scripts/src/types/index.d.ts
================
export type Scope = 'private' | 'public' | 'machine' | 'user';
export interface EncryptionInfo {
    enabled: boolean;
    method?: string;
    keyRef?: string;
    ciphertext?: boolean;
}
export interface AccessPolicy {
    hiddenFromLLM: boolean;
    allowedTools?: string[];
}
export interface PipeRecord {
    type: 'data' | 'schema';
    content: any;
    scope: Scope;
    cid?: string;
    pinned?: boolean;
    encryption?: EncryptionInfo;
    accessPolicy?: AccessPolicy;
    metadata?: Record<string, any>;
    timestamp?: string;
}
export interface PipeBundle {
    schemaRecord: PipeRecord;
    dataRecord: PipeRecord;
    combinedScope: Scope;
    timestamp?: string;
}
export interface PipeConfig {
    ipfsEndpoint?: string;
    defaultScope?: Scope;
    autoPin?: boolean;
    hooks?: PipeHook[];
}
export interface PipeHook {
    name: string;
    handler: (data: any, metadata: Record<string, any>) => Promise<any>;
    trigger: 'pre-store' | 'post-store';
}
export interface StoreOptions {
    scope?: Scope;
    pin?: boolean;
    generateSchema?: boolean;
}
export interface Tool {
    name: string;
    description: string;
    call: (...args: any[]) => any;
    parameters?: any;
    returns?: any;
}
export interface PipeTool {
    name: string;
    description: string;
    call: (method: string, args: any) => Promise<PipeRecord | PipeBundle | null | void>;
}
//# sourceMappingURL=index.d.ts.map

================
File: dist-scripts/src/types/index.d.ts.map
================
{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/types/index.ts"],"names":[],"mappings":"AAAA,MAAM,MAAM,KAAK,GAAG,SAAS,GAAG,QAAQ,GAAG,SAAS,GAAG,MAAM,CAAC;AAE9D,MAAM,WAAW,cAAc;IAC7B,OAAO,EAAE,OAAO,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,CAAC,EAAE,OAAO,CAAC;CACtB;AAED,MAAM,WAAW,YAAY;IAC3B,aAAa,EAAE,OAAO,CAAC;IACvB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;CACzB;AAED,MAAM,WAAW,UAAU;IACzB,IAAI,EAAE,MAAM,GAAG,QAAQ,CAAC;IACxB,OAAO,EAAE,GAAG,CAAC;IACb,KAAK,EAAE,KAAK,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,UAAU,CAAC,EAAE,cAAc,CAAC;IAC5B,YAAY,CAAC,EAAE,YAAY,CAAC;IAC5B,QAAQ,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC/B,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,MAAM,WAAW,UAAU;IACzB,YAAY,EAAE,UAAU,CAAC;IACzB,UAAU,EAAE,UAAU,CAAC;IACvB,aAAa,EAAE,KAAK,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,MAAM,WAAW,UAAU;IACzB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,YAAY,CAAC,EAAE,KAAK,CAAC;IACrB,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,KAAK,CAAC,EAAE,QAAQ,EAAE,CAAC;CACpB;AAED,MAAM,WAAW,QAAQ;IACvB,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,OAAO,CAAC,GAAG,CAAC,CAAC;IACpE,OAAO,EAAE,WAAW,GAAG,YAAY,CAAC;CACrC;AAED,MAAM,WAAW,YAAY;IAC3B,KAAK,CAAC,EAAE,KAAK,CAAC;IACd,GAAG,CAAC,EAAE,OAAO,CAAC;IACd,cAAc,CAAC,EAAE,OAAO,CAAC;CAC1B;AAED,MAAM,WAAW,IAAI;IACnB,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,IAAI,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,KAAK,GAAG,CAAC;IAC9B,UAAU,CAAC,EAAE,GAAG,CAAC;IACjB,OAAO,CAAC,EAAE,GAAG,CAAC;CACf;AAED,MAAM,WAAW,QAAQ;IACvB,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,IAAI,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,KAAK,OAAO,CAAC,UAAU,GAAG,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC;CACrF"}

================
File: dist-scripts/src/types/index.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

================
File: dist-scripts/src/types/index.js.map
================
{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/types/index.ts"],"names":[],"mappings":""}

================
File: dist-scripts/src/utils/index.d.ts
================
/**
 * Generates a summary of the provided data
 * @param data Any data to be summarized
 * @returns A string summary of the data
 */
export declare function generateSummary(data: any): Promise<string>;
/**
 * Validates a scope value
 * @param scope The scope to validate
 * @returns boolean indicating if the scope is valid
 */
export declare function isValidScope(scope: any): boolean;
/**
 * Deep clones an object
 * @param obj The object to clone
 * @returns A deep clone of the object
 */
export declare function deepClone<T>(obj: T): T;
/**
 * Generates a timestamp in ISO format
 * @returns Current timestamp in ISO format
 */
export declare function generateTimestamp(): string;
/**
 * Validates a CID string
 * @param cid The CID to validate
 * @returns boolean indicating if the CID is valid
 */
export declare function isValidCID(cid: string): boolean;
/**
 * Formats error messages
 * @param message The error message
 * @param code Optional error code
 * @returns Formatted error message
 */
export declare function formatError(message: string, code?: string): string;
//# sourceMappingURL=index.d.ts.map

================
File: dist-scripts/src/utils/index.d.ts.map
================
{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/utils/index.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,wBAAsB,eAAe,CAAC,IAAI,EAAE,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,CAchE;AAED;;;;GAIG;AACH,wBAAgB,YAAY,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAEhD;AAED;;;;GAIG;AACH,wBAAgB,SAAS,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAEtC;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,IAAI,MAAM,CAE1C;AAED;;;;GAIG;AACH,wBAAgB,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAG/C;AAED;;;;;GAKG;AACH,wBAAgB,WAAW,CAAC,OAAO,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,MAAM,GAAG,MAAM,CAElE"}

================
File: dist-scripts/src/utils/index.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSummary = generateSummary;
exports.isValidScope = isValidScope;
exports.deepClone = deepClone;
exports.generateTimestamp = generateTimestamp;
exports.isValidCID = isValidCID;
exports.formatError = formatError;
/**
 * Generates a summary of the provided data
 * @param data Any data to be summarized
 * @returns A string summary of the data
 */
async function generateSummary(data) {
    try {
        // Convert data to string if it's not already
        const stringData = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
        // For now, return a simple summary
        // In a production environment, this could use an LLM or other summarization technique
        const summary = `Data of type ${typeof data}, length: ${stringData.length} characters`;
        return summary;
    }
    catch (error) {
        console.error('Error generating summary:', error);
        return 'Error generating summary';
    }
}
/**
 * Validates a scope value
 * @param scope The scope to validate
 * @returns boolean indicating if the scope is valid
 */
function isValidScope(scope) {
    return ['private', 'public', 'machine', 'user'].includes(scope);
}
/**
 * Deep clones an object
 * @param obj The object to clone
 * @returns A deep clone of the object
 */
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 * Generates a timestamp in ISO format
 * @returns Current timestamp in ISO format
 */
function generateTimestamp() {
    return new Date().toISOString();
}
/**
 * Validates a CID string
 * @param cid The CID to validate
 * @returns boolean indicating if the CID is valid
 */
function isValidCID(cid) {
    // Basic validation - could be enhanced with actual CID validation logic
    return typeof cid === 'string' && cid.length > 0;
}
/**
 * Formats error messages
 * @param message The error message
 * @param code Optional error code
 * @returns Formatted error message
 */
function formatError(message, code) {
    return code ? `[${code}] ${message}` : message;
}
//# sourceMappingURL=index.js.map

================
File: dist-scripts/src/utils/index.js.map
================
{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/utils/index.ts"],"names":[],"mappings":";;AAKA,0CAcC;AAOD,oCAEC;AAOD,8BAEC;AAMD,8CAEC;AAOD,gCAGC;AAQD,kCAEC;AAjED;;;;GAIG;AACI,KAAK,UAAU,eAAe,CAAC,IAAS;IAC7C,IAAI,CAAC;QACH,6CAA6C;QAC7C,MAAM,UAAU,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;QAEnF,mCAAmC;QACnC,sFAAsF;QACtF,MAAM,OAAO,GAAG,gBAAgB,OAAO,IAAI,aAAa,UAAU,CAAC,MAAM,aAAa,CAAC;QAEvF,OAAO,OAAO,CAAC;IACjB,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,2BAA2B,EAAE,KAAK,CAAC,CAAC;QAClD,OAAO,0BAA0B,CAAC;IACpC,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,SAAgB,YAAY,CAAC,KAAU;IACrC,OAAO,CAAC,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AAClE,CAAC;AAED;;;;GAIG;AACH,SAAgB,SAAS,CAAI,GAAM;IACjC,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;AACzC,CAAC;AAED;;;GAGG;AACH,SAAgB,iBAAiB;IAC/B,OAAO,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;AAClC,CAAC;AAED;;;;GAIG;AACH,SAAgB,UAAU,CAAC,GAAW;IACpC,wEAAwE;IACxE,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;AACnD,CAAC;AAED;;;;;GAKG;AACH,SAAgB,WAAW,CAAC,OAAe,EAAE,IAAa;IACxD,OAAO,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,KAAK,OAAO,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;AACjD,CAAC"}

================
File: dist-scripts/src/api.d.ts
================
import { PipeProtocol } from './pipe';
export declare function createPipeAPI(pipe: PipeProtocol): import("express-serve-static-core").Express;
//# sourceMappingURL=api.d.ts.map

================
File: dist-scripts/src/api.d.ts.map
================
{"version":3,"file":"api.d.ts","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAGtC,wBAAgB,aAAa,CAAC,IAAI,EAAE,YAAY,+CA0I/C"}

================
File: dist-scripts/src/api.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPipeAPI = createPipeAPI;
const express_1 = require("express");
function createPipeAPI(pipe) {
    const app = (0, express_1.default)();
    app.use(express_1.default.json());
    app.post('/publish', async (req, res) => {
        try {
            const record = req.body;
            const published = await pipe.publishRecord(record);
            res.json(published);
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.post('/publish-bundle', async (req, res) => {
        try {
            const bundle = req.body;
            const published = await pipe.publishBundle(bundle);
            res.json(published);
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.get('/fetch', async (req, res) => {
        try {
            const { cid, scope } = req.query;
            if (!cid || !scope) {
                return res.status(400).json({ error: 'Missing cid or scope parameter' });
            }
            const record = await pipe.fetchRecord(cid, scope);
            res.json(record);
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.post('/pin', async (req, res) => {
        try {
            const { cid, scope } = req.body;
            if (!cid || !scope) {
                return res.status(400).json({ error: 'Missing cid or scope parameter' });
            }
            await pipe.pin(cid, scope);
            res.json({ success: true });
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.post('/unpin', async (req, res) => {
        try {
            const { cid, scope } = req.body;
            if (!cid || !scope) {
                return res.status(400).json({ error: 'Missing cid or scope parameter' });
            }
            await pipe.unpin(cid, scope);
            res.json({ success: true });
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.post('/replicate', async (req, res) => {
        try {
            const { cid, fromScope, toScope } = req.body;
            if (!cid || !fromScope || !toScope) {
                return res.status(400).json({ error: 'Missing required parameters' });
            }
            await pipe.replicate(cid, fromScope, toScope);
            res.json({ success: true });
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.get('/node-status', async (_req, res) => {
        try {
            const status = await pipe.getStatus();
            res.json(status);
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.get('/node-info', async (req, res) => {
        try {
            const { scope } = req.query;
            if (!scope) {
                return res.status(400).json({ error: 'Missing scope parameter' });
            }
            const info = await pipe.getNodeInfo(scope);
            res.json(info);
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.get('/storage-metrics', async (req, res) => {
        try {
            const { scope } = req.query;
            if (!scope) {
                return res.status(400).json({ error: 'Missing scope parameter' });
            }
            const metrics = await pipe.getStorageMetrics(scope);
            res.json(metrics);
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.get('/pinned-cids', async (req, res) => {
        try {
            const { scope } = req.query;
            if (!scope) {
                return res.status(400).json({ error: 'Missing scope parameter' });
            }
            const cids = await pipe.getPinnedCids(scope);
            res.json(cids);
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    app.get('/configuration', async (req, res) => {
        try {
            const { scope } = req.query;
            if (!scope) {
                return res.status(400).json({ error: 'Missing scope parameter' });
            }
            const config = await pipe.getConfiguration(scope);
            res.json(config);
        }
        catch (error) {
            res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
        }
    });
    return app;
}
//# sourceMappingURL=api.js.map

================
File: dist-scripts/src/api.js.map
================
{"version":3,"file":"api.js","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/src/encryption.d.ts
================
import { webcrypto } from 'node:crypto';
type JsonWebKey = webcrypto.JsonWebKey;
export declare class EncryptionService {
    private keyCache;
    private encoder;
    private decoder;
    private readonly IV_LENGTH;
    constructor();
    private generateKey;
    private getKey;
    encrypt(plaintext: string, method?: string, keyRef?: string, isTest?: boolean): Promise<string>;
    decrypt(ciphertext: string, method?: string, keyRef?: string, isTest?: boolean): Promise<string>;
    exportKey(keyRef: string, method?: string): Promise<JsonWebKey>;
    importKey(jwk: JsonWebKey, method?: string, keyRef?: string): Promise<void>;
    clearKeys(): void;
    getEncryptionInfo(ciphertext: string): {
        method: string;
        keyRef: string;
    } | null;
}
export {};
//# sourceMappingURL=encryption.d.ts.map

================
File: dist-scripts/src/encryption.d.ts.map
================
{"version":3,"file":"encryption.d.ts","sourceRoot":"","sources":["../../src/encryption.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAMxC,KAAK,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC;AAEvC,qBAAa,iBAAiB;IAC5B,OAAO,CAAC,QAAQ,CAAyB;IACzC,OAAO,CAAC,OAAO,CAAc;IAC7B,OAAO,CAAC,OAAO,CAAc;IAC7B,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAM;;YAQlB,WAAW;YAyCX,MAAM;IAYd,OAAO,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,GAAE,MAAkB,EAAE,MAAM,GAAE,MAAqB,EAAE,MAAM,GAAE,OAAe,GAAG,OAAO,CAAC,MAAM,CAAC;IAoD/H,OAAO,CACX,UAAU,EAAE,MAAM,EAClB,MAAM,GAAE,MAAkB,EAC1B,MAAM,GAAE,MAAqB,EAC7B,MAAM,GAAE,OAAe,GACtB,OAAO,CAAC,MAAM,CAAC;IA2BZ,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,GAAE,MAAkB,GAAG,OAAO,CAAC,UAAU,CAAC;IAS1E,SAAS,CAAC,GAAG,EAAE,UAAU,EAAE,MAAM,GAAE,MAAkB,EAAE,MAAM,GAAE,MAAqB,GAAG,OAAO,CAAC,IAAI,CAAC;IAe1G,SAAS,IAAI,IAAI;IAIjB,iBAAiB,CAAC,UAAU,EAAE,MAAM,GAAG;QAAE,MAAM,EAAE,MAAM,CAAC;QAAC,MAAM,EAAE,MAAM,CAAA;KAAE,GAAG,IAAI;CAejF"}

================
File: dist-scripts/src/encryption.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptionService = void 0;
/// <reference lib="dom" />
const node_crypto_1 = require("node:crypto");
const util_1 = require("util");
const { subtle } = node_crypto_1.webcrypto;
class EncryptionService {
    constructor() {
        this.IV_LENGTH = 12;
        this.keyCache = new Map();
        this.encoder = new util_1.TextEncoder();
        this.decoder = new util_1.TextDecoder();
    }
    async generateKey(method, keyRef, isTest = false) {
        if (method !== 'AES-GCM') {
            throw new Error('Unsupported encryption method: ' + method);
        }
        // Generate a 32-byte key (256 bits)
        const seed = new Uint8Array(32);
        if (isTest) {
            // In test mode, use a deterministic seed based on keyRef and timestamp
            const timestamp = Date.now().toString();
            const keyBytes = this.encoder.encode(keyRef + timestamp);
            const hash = new Uint32Array(8); // 32 bytes / 4 bytes per uint32
            // Simple hash function to distribute keyRef bytes across the seed
            for (let i = 0; i < keyBytes.length; i++) {
                const pos = i % 8;
                hash[pos] = ((hash[pos] << 5) - hash[pos]) + keyBytes[i];
            }
            // Fill seed with hash values
            const hashBytes = new Uint8Array(hash.buffer);
            for (let i = 0; i < 32; i++) {
                seed[i] = hashBytes[i % hashBytes.length];
            }
        }
        else {
            // In production, use random values
            node_crypto_1.webcrypto.getRandomValues(seed);
        }
        return subtle.importKey('raw', seed, {
            name: method,
            length: 256
        }, true, ['encrypt', 'decrypt']);
    }
    async getKey(method, keyRef, isTest = false) {
        const keyId = `${method}:${keyRef}`;
        let key = this.keyCache.get(keyId);
        if (!key) {
            key = await this.generateKey(method, keyRef, isTest);
            this.keyCache.set(keyId, key);
        }
        return key;
    }
    async encrypt(plaintext, method = 'AES-GCM', keyRef = 'defaultKey', isTest = false) {
        try {
            const key = await this.getKey(method, keyRef, isTest);
            let iv;
            if (isTest) {
                // In test mode, use a deterministic IV based on both keyRef and plaintext
                const keyBytes = this.encoder.encode(keyRef);
                const textBytes = this.encoder.encode(plaintext);
                iv = new Uint8Array(this.IV_LENGTH);
                // Mix keyRef and plaintext bytes to create IV
                for (let i = 0; i < this.IV_LENGTH; i++) {
                    iv[i] = ((i < keyBytes.length ? keyBytes[i] : 0) ^
                        (i < textBytes.length ? textBytes[i] : 0)) % 256;
                }
            }
            else {
                iv = node_crypto_1.webcrypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
            }
            const algorithm = {
                name: method,
                iv
            };
            const encodedData = this.encoder.encode(plaintext);
            const encryptedData = await subtle.encrypt(algorithm, key, encodedData);
            // Convert ArrayBuffer to Uint8Array for manipulation
            const encryptedArray = new Uint8Array(encryptedData);
            // Create combined array with space for both IV and encrypted data
            const combined = new Uint8Array(this.IV_LENGTH + encryptedArray.byteLength);
            // Copy IV and encrypted data into combined array
            combined.set(iv, 0);
            combined.set(encryptedArray, this.IV_LENGTH);
            // Convert to base64 for storage/transmission
            return Buffer.from(combined).toString('base64');
        }
        catch (error) {
            console.error('Encryption error:', error);
            throw new Error('Failed to encrypt data');
        }
    }
    async decrypt(ciphertext, method = 'AES-GCM', keyRef = 'defaultKey', isTest = false) {
        try {
            const key = await this.getKey(method, keyRef, isTest);
            if (!key) {
                throw new Error('No key available for decryption');
            }
            const data = Buffer.from(ciphertext, 'base64');
            const iv = data.subarray(0, this.IV_LENGTH);
            const encryptedData = data.subarray(this.IV_LENGTH);
            const decryptedData = await subtle.decrypt({
                name: method,
                iv
            }, key, encryptedData);
            return this.decoder.decode(new Uint8Array(decryptedData));
        }
        catch (error) {
            console.error('Decryption error:', error);
            throw new Error('Failed to decrypt data');
        }
    }
    async exportKey(keyRef, method = 'AES-GCM') {
        const keyId = `${method}:${keyRef}`;
        const key = this.keyCache.get(keyId);
        if (!key) {
            throw new Error(`Key not found: ${keyRef}`);
        }
        return subtle.exportKey('jwk', key);
    }
    async importKey(jwk, method = 'AES-GCM', keyRef = 'defaultKey') {
        try {
            const key = await subtle.importKey('jwk', jwk, { name: method }, true, ['encrypt', 'decrypt']);
            this.keyCache.set(`${method}:${keyRef}`, key);
        }
        catch (error) {
            throw new Error('Failed to import key');
        }
    }
    clearKeys() {
        this.keyCache.clear();
    }
    getEncryptionInfo(ciphertext) {
        if (!ciphertext.startsWith('encrypted:')) {
            return null;
        }
        try {
            const base64Data = ciphertext.slice(10); // Remove 'encrypted:' prefix
            const decryptedJson = Buffer.from(base64Data, 'base64').toString();
            const { method, keyRef } = JSON.parse(decryptedJson);
            return { method, keyRef };
        }
        catch (error) {
            console.warn('Failed to extract encryption info:', error);
            return null;
        }
    }
}
exports.EncryptionService = EncryptionService;
//# sourceMappingURL=encryption.js.map

================
File: dist-scripts/src/encryption.js.map
================
{"version":3,"file":"encryption.js","sourceRoot":"","sources":["../../src/encryption.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/src/index.d.ts
================
import { PipeProtocol } from './pipe';
import { PipeRecord, PipeBundle } from './types';
interface Tool {
    name: string;
    description: string;
    call: (...args: any[]) => any;
}
interface PipeTool {
    name: string;
    description: string;
    call: (method: string, args: any) => Promise<PipeRecord | PipeBundle | null | void>;
}
export declare function pipe(tools: Tool[]): (Tool | PipeTool)[];
export { PipeProtocol };
export { IpfsClient } from './ipfsClient';
export { EncryptionService } from './encryption';
export * from './types';
export { summaryHook } from './pipe';
//# sourceMappingURL=index.d.ts.map

================
File: dist-scripts/src/index.d.ts.map
================
{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AACtC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAS,MAAM,SAAS,CAAC;AAExD,UAAU,IAAI;IACZ,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,IAAI,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,KAAK,GAAG,CAAC;CAC/B;AAED,UAAU,QAAQ;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,IAAI,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,KAAK,OAAO,CAAC,UAAU,GAAG,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC;CACrF;AAED,wBAAgB,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,GAAG,QAAQ,CAAC,EAAE,CAqDvD;AAED,OAAO,EAAE,YAAY,EAAE,CAAC;AACxB,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,iBAAiB,EAAE,MAAM,cAAc,CAAC;AACjD,cAAc,SAAS,CAAC;AAGxB,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC"}

================
File: dist-scripts/src/index.js
================
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summaryHook = exports.EncryptionService = exports.IpfsClient = exports.PipeProtocol = void 0;
exports.pipe = pipe;
const pipe_1 = require("./pipe");
Object.defineProperty(exports, "PipeProtocol", { enumerable: true, get: function () { return pipe_1.PipeProtocol; } });
function pipe(tools) {
    const pipeProtocol = new pipe_1.PipeProtocol();
    const pipeTool = {
        name: 'Pipe',
        description: `
      A special tool that allows referencing large data via IPFS.
      You can publish data or fetch data by CID.
      Example usage:
        - publishRecord({type, content, scope, pinned, encryption, accessPolicy})
        - fetchRecord(cid, scope)
        - publishBundle({schemaRecord, dataRecord, combinedScope})
        - pin(cid, scope)
        - unpin(cid, scope)
        - replicate(cid, fromScope, toScope)
        - getStatus()
        - getNodeInfo(scope)
        - getStorageMetrics(scope)
        - getPinnedCids(scope)
        - getConfiguration(scope)
      The LLM typically should not decrypt hidden data if hiddenFromLLM = true.
    `,
        call: async (method, args) => {
            switch (method) {
                case 'publishRecord':
                    return pipeProtocol.publishRecord(args);
                case 'fetchRecord':
                    return pipeProtocol.fetchRecord(args.cid, args.scope);
                case 'publishBundle':
                    return pipeProtocol.publishBundle(args);
                case 'pin':
                    return pipeProtocol.pin(args.cid, args.scope);
                case 'unpin':
                    return pipeProtocol.unpin(args.cid, args.scope);
                case 'replicate':
                    return pipeProtocol.replicate(args.cid, args.fromScope, args.toScope);
                case 'getStatus':
                    return pipeProtocol.getStatus();
                case 'getNodeInfo':
                    return pipeProtocol.getNodeInfo(args.scope);
                case 'getStorageMetrics':
                    return pipeProtocol.getStorageMetrics(args.scope);
                case 'getPinnedCids':
                    return pipeProtocol.getPinnedCids(args.scope);
                case 'getConfiguration':
                    return pipeProtocol.getConfiguration(args.scope);
                default:
                    throw new Error(`Unknown Pipe method: ${method}`);
            }
        },
    };
    return [...tools, pipeTool];
}
var ipfsClient_1 = require("./ipfsClient");
Object.defineProperty(exports, "IpfsClient", { enumerable: true, get: function () { return ipfsClient_1.IpfsClient; } });
var encryption_1 = require("./encryption");
Object.defineProperty(exports, "EncryptionService", { enumerable: true, get: function () { return encryption_1.EncryptionService; } });
__exportStar(require("./types"), exports);
// Export the example summary hook
var pipe_2 = require("./pipe");
Object.defineProperty(exports, "summaryHook", { enumerable: true, get: function () { return pipe_2.summaryHook; } });
//# sourceMappingURL=index.js.map

================
File: dist-scripts/src/index.js.map
================
{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAeA,oBAqDC;AApED,iCAAsC;AAsE7B,6FAtEA,mBAAY,OAsEA;AAvDrB,SAAgB,IAAI,CAAC,KAAa;IAChC,MAAM,YAAY,GAAG,IAAI,mBAAY,EAAE,CAAC;IAExC,MAAM,QAAQ,GAAa;QACzB,IAAI,EAAE,MAAM;QACZ,WAAW,EAAE;;;;;;;;;;;;;;;;KAgBZ;QACD,IAAI,EAAE,KAAK,EAAE,MAAc,EAAE,IAAS,EAAE,EAAE;YACxC,QAAQ,MAAM,EAAE,CAAC;gBACf,KAAK,eAAe;oBAClB,OAAO,YAAY,CAAC,aAAa,CAAC,IAAkB,CAAC,CAAC;gBACxD,KAAK,aAAa;oBAChB,OAAO,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,KAAc,CAAC,CAAC;gBACjE,KAAK,eAAe;oBAClB,OAAO,YAAY,CAAC,aAAa,CAAC,IAAkB,CAAC,CAAC;gBACxD,KAAK,KAAK;oBACR,OAAO,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,KAAc,CAAC,CAAC;gBACzD,KAAK,OAAO;oBACV,OAAO,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,KAAc,CAAC,CAAC;gBAC3D,KAAK,WAAW;oBACd,OAAO,YAAY,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,SAAkB,EAAE,IAAI,CAAC,OAAgB,CAAC,CAAC;gBAC1F,KAAK,WAAW;oBACd,OAAO,YAAY,CAAC,SAAS,EAAE,CAAC;gBAClC,KAAK,aAAa;oBAChB,OAAO,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,KAAc,CAAC,CAAC;gBACvD,KAAK,mBAAmB;oBACtB,OAAO,YAAY,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAc,CAAC,CAAC;gBAC7D,KAAK,eAAe;oBAClB,OAAO,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,KAAc,CAAC,CAAC;gBACzD,KAAK,kBAAkB;oBACrB,OAAO,YAAY,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAc,CAAC,CAAC;gBAC5D;oBACE,MAAM,IAAI,KAAK,CAAC,wBAAwB,MAAM,EAAE,CAAC,CAAC;YACtD,CAAC;QACH,CAAC;KACF,CAAC;IAEF,OAAO,CAAC,GAAG,KAAK,EAAE,QAAQ,CAAC,CAAC;AAC9B,CAAC;AAGD,2CAA0C;AAAjC,wGAAA,UAAU,OAAA;AACnB,2CAAiD;AAAxC,+GAAA,iBAAiB,OAAA;AAC1B,0CAAwB;AAExB,kCAAkC;AAClC,+BAAqC;AAA5B,mGAAA,WAAW,OAAA"}

================
File: dist-scripts/src/ipfsClient.d.ts
================
import { PipeRecord, Scope, PipeIpfsOptions } from './types';
export declare class IpfsClient {
    private localNode?;
    private publicNode?;
    private isRunning;
    constructor(config?: PipeIpfsOptions);
    init(localNodeEndpoint?: string, publicNodeEndpoint?: string): Promise<void>;
    private getNodeForScope;
    publish(record: PipeRecord): Promise<PipeRecord>;
    fetch(cid: string, scope: Scope): Promise<PipeRecord | null>;
    pin(cid: string, scope: Scope): Promise<void>;
    unpin(cid: string, scope: Scope): Promise<void>;
    replicate(cid: string, fromScope: Scope, toScope: Scope): Promise<void>;
    stop(): Promise<void>;
    getStatus(): boolean;
    getNodeInfo(scope: Scope): Promise<any>;
    getStorageMetrics(scope: Scope): Promise<any>;
    getPinnedCids(scope: Scope): Promise<string[]>;
    getConfiguration(scope: Scope): any;
}
//# sourceMappingURL=ipfsClient.d.ts.map

================
File: dist-scripts/src/ipfsClient.d.ts.map
================
{"version":3,"file":"ipfsClient.d.ts","sourceRoot":"","sources":["../../src/ipfsClient.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,UAAU,EAAE,KAAK,EAAE,eAAe,EAAE,MAAM,SAAS,CAAC;AAI7D,qBAAa,UAAU;IACrB,OAAO,CAAC,SAAS,CAAC,CAAiB;IACnC,OAAO,CAAC,UAAU,CAAC,CAAiB;IACpC,OAAO,CAAC,SAAS,CAAkB;gBAEvB,MAAM,GAAE,eAAoB;IAS3B,IAAI,CAAC,iBAAiB,CAAC,EAAE,MAAM,EAAE,kBAAkB,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAwBzF,OAAO,CAAC,eAAe;IAmBjB,OAAO,CAAC,MAAM,EAAE,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;IAqBhD,KAAK,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;IAqC5D,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;IAK7C,KAAK,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;IAK/C,SAAS,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;IAWvE,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC;IAa3B,SAAS,IAAI,OAAO;IAId,WAAW,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;IAKvC,iBAAiB,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;IAU7C,aAAa,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;IAYpD,gBAAgB,CAAC,KAAK,EAAE,KAAK,GAAG,GAAG;CAOpC"}

================
File: dist-scripts/src/ipfsClient.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IpfsClient = void 0;
const ipfs_http_client_1 = require("ipfs-http-client");
const dotenv_1 = require("dotenv");
(0, dotenv_1.config)();
class IpfsClient {
    constructor(config = {}) {
        this.isRunning = false;
        const { endpoint, options } = config;
        if (endpoint) {
            this.localNode = (0, ipfs_http_client_1.create)({ url: endpoint, ...options });
            this.publicNode = (0, ipfs_http_client_1.create)({ url: endpoint, ...options });
        }
    }
    async init(localNodeEndpoint, publicNodeEndpoint) {
        if (localNodeEndpoint) {
            this.localNode = (0, ipfs_http_client_1.create)({ url: localNodeEndpoint });
        }
        if (publicNodeEndpoint) {
            this.publicNode = (0, ipfs_http_client_1.create)({ url: publicNodeEndpoint });
        }
        this.isRunning = true;
        // Test connections
        try {
            if (!this.localNode || !this.publicNode) {
                throw new Error('IPFS nodes not initialized');
            }
            await Promise.all([
                this.localNode.id(),
                this.publicNode.id()
            ]);
        }
        catch (error) {
            console.error('Failed to initialize IPFS nodes:', error);
            throw error;
        }
    }
    getNodeForScope(scope) {
        if (!this.isRunning) {
            throw new Error('IPFS client is not running');
        }
        switch (scope) {
            case 'private':
            case 'machine':
                if (!this.localNode)
                    throw new Error('Local node not initialized');
                return this.localNode;
            case 'public':
            case 'user':
                if (!this.publicNode)
                    throw new Error('Public node not initialized');
                return this.publicNode;
            default:
                throw new Error(`Invalid scope: ${scope}`);
        }
    }
    async publish(record) {
        if (!this.isRunning) {
            throw new Error('IPFS client is not running');
        }
        const node = this.getNodeForScope(record.scope);
        try {
            // Store the entire record
            const result = await node.add(JSON.stringify(record));
            return {
                ...record,
                cid: result.path
            };
        }
        catch (error) {
            console.error('Error publishing to IPFS:', error);
            throw error;
        }
    }
    async fetch(cid, scope) {
        if (!this.isRunning) {
            throw new Error('IPFS client is not running');
        }
        const node = this.getNodeForScope(scope);
        try {
            const chunks = [];
            for await (const chunk of node.cat(cid)) {
                chunks.push(chunk);
            }
            const rawContent = Buffer.concat(chunks).toString();
            let record;
            try {
                record = JSON.parse(rawContent);
            }
            catch {
                // If we can't parse the content as a record, assume it's just the content
                record = {
                    cid,
                    content: rawContent,
                    type: 'data',
                    scope,
                    accessPolicy: { hiddenFromLLM: false },
                    encryption: { enabled: false }
                };
            }
            return record;
        }
        catch (error) {
            console.error('Error fetching from IPFS:', error);
            return null;
        }
    }
    async pin(cid, scope) {
        const node = this.getNodeForScope(scope);
        await node.pin.add(cid);
    }
    async unpin(cid, scope) {
        const node = this.getNodeForScope(scope);
        await node.pin.rm(cid);
    }
    async replicate(cid, fromScope, toScope) {
        const content = await this.fetch(cid, fromScope);
        if (!content) {
            throw new Error(`Content not found for CID: ${cid}`);
        }
        await this.publish({
            ...content,
            scope: toScope
        });
    }
    async stop() {
        if (this.isRunning) {
            try {
                if (this.localNode)
                    await this.localNode.stop();
                if (this.publicNode)
                    await this.publicNode.stop();
                this.isRunning = false;
            }
            catch (error) {
                console.error('Error stopping IPFS client:', error);
                throw error;
            }
        }
    }
    getStatus() {
        return this.isRunning;
    }
    async getNodeInfo(scope) {
        const node = this.getNodeForScope(scope);
        return node.id();
    }
    async getStorageMetrics(scope) {
        const node = this.getNodeForScope(scope);
        const stats = await node.stats.repo();
        return {
            repoSize: stats.repoSize,
            storageMax: stats.storageMax,
            numObjects: stats.numObjects
        };
    }
    async getPinnedCids(scope) {
        const node = this.getNodeForScope(scope);
        const pins = node.pin.ls();
        const cids = [];
        for await (const pin of pins) {
            cids.push(pin.cid.toString());
        }
        return cids;
    }
    getConfiguration(scope) {
        const node = this.getNodeForScope(scope);
        return {
            endpoint: node.getEndpointConfig(),
            scope
        };
    }
}
exports.IpfsClient = IpfsClient;
//# sourceMappingURL=ipfsClient.js.map

================
File: dist-scripts/src/ipfsClient.js.map
================
{"version":3,"file":"ipfsClient.js","sourceRoot":"","sources":["../../src/ipfsClient.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/src/pipe.d.ts
================
import { PipeRecord, PipeBundle, Scope, PipeHook, StoreOptions, Tool, PipeOptions } from './types';
export declare class PipeProtocol {
    private ipfs;
    private encryption;
    private hooks;
    private currentTool;
    private initialized;
    constructor(options?: PipeOptions);
    private init;
    processHooks(trigger: 'pre-store' | 'post-store', data: any, metadata: Record<string, any>): Promise<any>;
    addHook(hook: PipeHook): void;
    storeData(data: any, options?: StoreOptions): Promise<{
        cid: string;
        schemaCid: string | null | undefined;
        timestamp: string;
    }>;
    private generateSchema;
    publishRecord(record: PipeRecord): Promise<PipeRecord>;
    publishBundle(bundle: PipeBundle): Promise<PipeBundle>;
    fetchRecord(cid: string, scope: Scope): Promise<PipeRecord | null>;
    stop(): Promise<void>;
    getStatus(): Promise<boolean>;
    getNodeInfo(scope: Scope): Promise<any>;
    getStorageMetrics(scope: Scope): Promise<any>;
    getPinnedCids(scope: Scope): Promise<string[]>;
    getConfiguration(scope: Scope): Promise<any>;
    pin(cid: string, scope: Scope): Promise<void>;
    unpin(cid: string, scope: Scope): Promise<void>;
    replicate(cid: string, fromScope: Scope, toScope: Scope): Promise<void>;
    wrap(tools: Tool[]): any[];
    private wrapTool;
    private enhanceParameters;
    private getReturnSchema;
}
export declare const summaryHook: PipeHook;
//# sourceMappingURL=pipe.d.ts.map

================
File: dist-scripts/src/pipe.d.ts.map
================
{"version":3,"file":"pipe.d.ts","sourceRoot":"","sources":["../../src/pipe.ts"],"names":[],"mappings":"AAEA,OAAO,EACL,UAAU,EACV,UAAU,EACV,KAAK,EACL,QAAQ,EACR,YAAY,EACZ,IAAI,EACJ,WAAW,EAEZ,MAAM,SAAS,CAAC;AAGjB,qBAAa,YAAY;IACvB,OAAO,CAAC,IAAI,CAAa;IACzB,OAAO,CAAC,UAAU,CAAoB;IACtC,OAAO,CAAC,KAAK,CAAkB;IAC/B,OAAO,CAAC,WAAW,CAAqB;IACxC,OAAO,CAAC,WAAW,CAAgB;gBAEvB,OAAO,GAAE,WAAgB;YA4BvB,IAAI;IAIZ,YAAY,CAAC,OAAO,EAAE,WAAW,GAAG,YAAY,EAAE,IAAI,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC;IAUhG,OAAO,CAAC,IAAI,EAAE,QAAQ;IAIhB,SAAS,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,GAAE,YAAiB;;;;;IA2CrD,OAAO,CAAC,cAAc;IAWT,aAAa,CAAC,MAAM,EAAE,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;IAkCtD,aAAa,CAAC,MAAM,EAAE,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;IAetD,WAAW,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;IA2ClE,IAAI;IAKJ,SAAS;IAKT,WAAW,CAAC,KAAK,EAAE,KAAK;IAKxB,iBAAiB,CAAC,KAAK,EAAE,KAAK;IAK9B,aAAa,CAAC,KAAK,EAAE,KAAK;IAK1B,gBAAgB,CAAC,KAAK,EAAE,KAAK;IAM7B,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;IAK7C,KAAK,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;IAK/C,SAAS,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;IAMpF,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,GAAG,GAAG,EAAE;IAI1B,OAAO,CAAC,QAAQ;IAoChB,OAAO,CAAC,iBAAiB;IA+BzB,OAAO,CAAC,eAAe;CAYxB;AAGD,eAAO,MAAM,WAAW,EAAE,QAazB,CAAC"}

================
File: dist-scripts/src/pipe.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.summaryHook = exports.PipeProtocol = void 0;
const ipfsClient_1 = require("./ipfsClient");
const encryption_1 = require("./encryption");
const utils_1 = require("./utils");
class PipeProtocol {
    constructor(options = {}) {
        this.hooks = [];
        try {
            this.encryption = new encryption_1.EncryptionService();
            // Map PipeOptions to PipeIpfsOptions
            const ipfsConfig = {
                endpoint: options.localNodeEndpoint,
                options: {}
            };
            this.ipfs = new ipfsClient_1.IpfsClient(ipfsConfig);
            this.hooks = options.hooks || [];
            this.initialized = this.init(options.localNodeEndpoint, options.publicNodeEndpoint).catch(error => {
                console.error('Error during IPFS initialization:', error);
                if (error instanceof Error) {
                    console.error('Error stack:', error.stack);
                }
                throw error;
            });
        }
        catch (error) {
            console.error('Error during PipeProtocol initialization:', error);
            if (error instanceof Error) {
                console.error('Error stack:', error.stack);
            }
            throw error;
        }
    }
    async init(localNodeEndpoint, publicNodeEndpoint) {
        await this.ipfs.init(localNodeEndpoint, publicNodeEndpoint);
    }
    async processHooks(trigger, data, metadata) {
        let processed = data;
        for (const hook of this.hooks) {
            if (hook.trigger === trigger) {
                processed = await hook.handler(processed, metadata);
            }
        }
        return processed;
    }
    addHook(hook) {
        this.hooks.push(hook);
    }
    async storeData(data, options = {}) {
        await this.initialized;
        const generateSchema = options.generateSchema !== false;
        const schema = generateSchema ? this.generateSchema(data) : null;
        // Process pre-store hooks
        const processedData = await this.processHooks('pre-store', data, {
            tool: this.currentTool,
            timestamp: (0, utils_1.generateTimestamp)()
        });
        const [dataCid, schemaCid] = await Promise.all([
            this.publishRecord({
                type: 'data',
                content: processedData,
                scope: options.scope || 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            }),
            schema ? this.publishRecord({
                type: 'schema',
                content: schema,
                scope: options.scope || 'private',
                accessPolicy: { hiddenFromLLM: false },
                encryption: { enabled: false }
            }) : Promise.resolve(null)
        ]);
        const result = {
            cid: dataCid.cid,
            schemaCid: schemaCid ? schemaCid.cid : null,
            timestamp: (0, utils_1.generateTimestamp)()
        };
        // Process post-store hooks
        await this.processHooks('post-store', result, {
            tool: this.currentTool,
            timestamp: (0, utils_1.generateTimestamp)()
        });
        return result;
    }
    generateSchema(data) {
        return {
            $schema: 'http://json-schema.org/draft-07/schema#',
            type: 'object',
            properties: Object.keys(data).reduce((acc, key) => {
                acc[key] = { type: typeof data[key] };
                return acc;
            }, {})
        };
    }
    async publishRecord(record) {
        await this.initialized;
        const validRecord = (0, utils_1.deepClone)(record);
        if (validRecord.encryption?.enabled && !validRecord.encryption?.ciphertext && validRecord.content) {
            const method = validRecord.encryption?.method || 'AES-GCM';
            const keyRef = validRecord.encryption?.keyRef || 'defaultKey';
            const isJson = typeof validRecord.content !== 'string';
            // Always stringify content for encryption
            const plaintext = isJson ? JSON.stringify(validRecord.content) : validRecord.content;
            const encrypted = await this.encryption.encrypt(plaintext, method, keyRef, process.env.NODE_ENV === 'test');
            // Create a new record with encrypted content and updated encryption info
            const encryptedRecord = {
                ...validRecord,
                content: encrypted,
                encryption: {
                    ...validRecord.encryption,
                    enabled: true,
                    ciphertext: true,
                    method,
                    keyRef,
                    contentType: isJson ? 'json' : 'string'
                }
            };
            return this.ipfs.publish(encryptedRecord);
        }
        return this.ipfs.publish(validRecord);
    }
    async publishBundle(bundle) {
        await this.initialized;
        const validBundle = (0, utils_1.deepClone)(bundle);
        const publishedSchema = await this.publishRecord(validBundle.schemaRecord);
        const publishedData = await this.publishRecord(validBundle.dataRecord);
        return {
            ...validBundle,
            schemaRecord: publishedSchema,
            dataRecord: publishedData,
            timestamp: (0, utils_1.generateTimestamp)()
        };
    }
    async fetchRecord(cid, scope) {
        await this.initialized;
        const record = await this.ipfs.fetch(cid, scope);
        if (!record)
            return null;
        if (record.encryption?.enabled && record.encryption?.ciphertext) {
            const decrypted = await this.encryption.decrypt(record.content, record.encryption.method || 'AES-GCM', record.encryption.keyRef || 'defaultKey', process.env.NODE_ENV === 'test');
            // Parse content based on the original content type
            if (record.encryption.contentType === 'json') {
                try {
                    record.content = JSON.parse(decrypted);
                }
                catch (error) {
                    console.error('Failed to parse decrypted JSON:', error);
                    throw new Error('Failed to parse decrypted content as JSON');
                }
            }
            else {
                record.content = decrypted;
            }
            record.encryption = {
                ...record.encryption,
                enabled: true,
                ciphertext: false
            };
        }
        else if (typeof record.content === 'string' && !record.encryption?.contentType) {
            // Only try to parse non-encrypted content as JSON if it's not explicitly marked as a string
            try {
                record.content = JSON.parse(record.content);
            }
            catch {
                // Keep content as is if it's not valid JSON
            }
        }
        return record;
    }
    // IPFS Node Management Methods
    async stop() {
        await this.initialized;
        await this.ipfs.stop();
    }
    async getStatus() {
        await this.initialized;
        return this.ipfs.getStatus();
    }
    async getNodeInfo(scope) {
        await this.initialized;
        return this.ipfs.getNodeInfo(scope);
    }
    async getStorageMetrics(scope) {
        await this.initialized;
        return this.ipfs.getStorageMetrics(scope);
    }
    async getPinnedCids(scope) {
        await this.initialized;
        return this.ipfs.getPinnedCids(scope);
    }
    async getConfiguration(scope) {
        await this.initialized;
        return this.ipfs.getConfiguration(scope);
    }
    // Pin Management Methods
    async pin(cid, scope) {
        await this.initialized;
        return this.ipfs.pin(cid, scope);
    }
    async unpin(cid, scope) {
        await this.initialized;
        return this.ipfs.unpin(cid, scope);
    }
    async replicate(cid, fromScope, toScope) {
        await this.initialized;
        return this.ipfs.replicate(cid, fromScope, toScope);
    }
    // Tool Wrapping Methods
    wrap(tools) {
        return tools.map(tool => this.wrapTool(tool));
    }
    wrapTool(tool) {
        return {
            originalTool: tool,
            wrappedDefinition: {
                ...tool,
                parameters: this.enhanceParameters(tool.parameters),
                returns: this.getReturnSchema()
            },
            execute: async (args) => {
                this.currentTool = tool.name;
                // Execute original tool
                const result = await tool.call(args);
                // Process hooks
                const metadata = { tool: tool.name, timestamp: (0, utils_1.generateTimestamp)() };
                const processed = await this.processHooks('pre-store', result, metadata);
                // Store in IPFS
                const options = args?.pipeOptions || {};
                const { cid, schemaCid } = await this.storeData(processed, options);
                // Post-store hooks
                await this.processHooks('post-store', { cid, data: processed }, metadata);
                return {
                    cid,
                    schemaCid,
                    description: tool.description,
                    type: tool.returns?.type || typeof result,
                    metadata
                };
            }
        };
    }
    enhanceParameters(originalParams) {
        return {
            ...originalParams,
            properties: {
                ...originalParams.properties,
                pipeOptions: {
                    type: 'object',
                    properties: {
                        scope: {
                            type: 'string',
                            enum: ['private', 'public', 'machine', 'user'],
                            default: 'private'
                        },
                        storeResult: {
                            type: 'boolean',
                            default: true
                        },
                        generateSchema: {
                            type: 'boolean',
                            default: true
                        },
                        pin: {
                            type: 'boolean',
                            default: true
                        }
                    }
                }
            }
        };
    }
    getReturnSchema() {
        return {
            type: 'object',
            properties: {
                cid: { type: 'string', description: 'IPFS Content Identifier' },
                schemaCid: { type: 'string', description: 'CID for JSON schema of returned data' },
                description: { type: 'string' },
                type: { type: 'string' },
                metadata: { type: 'object' }
            }
        };
    }
}
exports.PipeProtocol = PipeProtocol;
// Example Summary Hook
exports.summaryHook = {
    name: 'data-summarizer',
    trigger: 'pre-store',
    async handler(data, metadata) {
        const summary = await (0, utils_1.generateSummary)(data);
        return {
            ...data,
            metadata: {
                ...metadata,
                summary
            }
        };
    }
};
//# sourceMappingURL=pipe.js.map

================
File: dist-scripts/src/pipe.js.map
================
{"version":3,"file":"pipe.js","sourceRoot":"","sources":["../../src/pipe.ts"],"names":[],"mappings":"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"}

================
File: dist-scripts/src/schema.d.ts
================
import { z } from 'zod';
import { AccessPolicy } from './types';
declare const AccessPolicySchema: z.ZodSchema<AccessPolicy>;
declare const PipeRecordSchema: z.ZodObject<{
    cid: z.ZodOptional<z.ZodString>;
    content: z.ZodAny;
    type: z.ZodEnum<["data", "schema"]>;
    scope: z.ZodEnum<["private", "public", "machine", "user"]>;
    accessPolicy: z.ZodType<AccessPolicy, z.ZodTypeDef, AccessPolicy>;
    encryption: z.ZodObject<{
        enabled: z.ZodBoolean;
        method: z.ZodOptional<z.ZodString>;
        keyRef: z.ZodOptional<z.ZodString>;
        ciphertext: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        enabled: boolean;
        method?: string | undefined;
        keyRef?: string | undefined;
        ciphertext?: boolean | undefined;
    }, {
        enabled: boolean;
        method?: string | undefined;
        keyRef?: string | undefined;
        ciphertext?: boolean | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: "data" | "schema";
    scope: "private" | "public" | "machine" | "user";
    accessPolicy: AccessPolicy;
    encryption: {
        enabled: boolean;
        method?: string | undefined;
        keyRef?: string | undefined;
        ciphertext?: boolean | undefined;
    };
    cid?: string | undefined;
    content?: any;
}, {
    type: "data" | "schema";
    scope: "private" | "public" | "machine" | "user";
    accessPolicy: AccessPolicy;
    encryption: {
        enabled: boolean;
        method?: string | undefined;
        keyRef?: string | undefined;
        ciphertext?: boolean | undefined;
    };
    cid?: string | undefined;
    content?: any;
}>;
declare const PipeBundleSchema: z.ZodObject<{
    schemaRecord: z.ZodObject<{
        cid: z.ZodOptional<z.ZodString>;
        content: z.ZodAny;
        type: z.ZodEnum<["data", "schema"]>;
        scope: z.ZodEnum<["private", "public", "machine", "user"]>;
        accessPolicy: z.ZodType<AccessPolicy, z.ZodTypeDef, AccessPolicy>;
        encryption: z.ZodObject<{
            enabled: z.ZodBoolean;
            method: z.ZodOptional<z.ZodString>;
            keyRef: z.ZodOptional<z.ZodString>;
            ciphertext: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        }, {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        }>;
    }, "strip", z.ZodTypeAny, {
        type: "data" | "schema";
        scope: "private" | "public" | "machine" | "user";
        accessPolicy: AccessPolicy;
        encryption: {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        };
        cid?: string | undefined;
        content?: any;
    }, {
        type: "data" | "schema";
        scope: "private" | "public" | "machine" | "user";
        accessPolicy: AccessPolicy;
        encryption: {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        };
        cid?: string | undefined;
        content?: any;
    }>;
    dataRecord: z.ZodObject<{
        cid: z.ZodOptional<z.ZodString>;
        content: z.ZodAny;
        type: z.ZodEnum<["data", "schema"]>;
        scope: z.ZodEnum<["private", "public", "machine", "user"]>;
        accessPolicy: z.ZodType<AccessPolicy, z.ZodTypeDef, AccessPolicy>;
        encryption: z.ZodObject<{
            enabled: z.ZodBoolean;
            method: z.ZodOptional<z.ZodString>;
            keyRef: z.ZodOptional<z.ZodString>;
            ciphertext: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        }, {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        }>;
    }, "strip", z.ZodTypeAny, {
        type: "data" | "schema";
        scope: "private" | "public" | "machine" | "user";
        accessPolicy: AccessPolicy;
        encryption: {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        };
        cid?: string | undefined;
        content?: any;
    }, {
        type: "data" | "schema";
        scope: "private" | "public" | "machine" | "user";
        accessPolicy: AccessPolicy;
        encryption: {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        };
        cid?: string | undefined;
        content?: any;
    }>;
    timestamp: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    schemaRecord: {
        type: "data" | "schema";
        scope: "private" | "public" | "machine" | "user";
        accessPolicy: AccessPolicy;
        encryption: {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        };
        cid?: string | undefined;
        content?: any;
    };
    dataRecord: {
        type: "data" | "schema";
        scope: "private" | "public" | "machine" | "user";
        accessPolicy: AccessPolicy;
        encryption: {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        };
        cid?: string | undefined;
        content?: any;
    };
    timestamp?: string | undefined;
}, {
    schemaRecord: {
        type: "data" | "schema";
        scope: "private" | "public" | "machine" | "user";
        accessPolicy: AccessPolicy;
        encryption: {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        };
        cid?: string | undefined;
        content?: any;
    };
    dataRecord: {
        type: "data" | "schema";
        scope: "private" | "public" | "machine" | "user";
        accessPolicy: AccessPolicy;
        encryption: {
            enabled: boolean;
            method?: string | undefined;
            keyRef?: string | undefined;
            ciphertext?: boolean | undefined;
        };
        cid?: string | undefined;
        content?: any;
    };
    timestamp?: string | undefined;
}>;
export { AccessPolicySchema, PipeRecordSchema, PipeBundleSchema };
//# sourceMappingURL=schema.d.ts.map

================
File: dist-scripts/src/schema.d.ts.map
================
{"version":3,"file":"schema.d.ts","sourceRoot":"","sources":["../../src/schema.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AACxB,OAAO,EAAE,YAAY,EAA0C,MAAM,SAAS,CAAC;AAU/E,QAAA,MAAM,kBAAkB,EAAE,CAAC,CAAC,SAAS,CAAC,YAAY,CAIhD,CAAC;AAEH,QAAA,MAAM,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAYpB,CAAC;AAEH,QAAA,MAAM,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAIpB,CAAC;AAEH,OAAO,EAAE,kBAAkB,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,CAAC"}

================
File: dist-scripts/src/schema.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PipeBundleSchema = exports.PipeRecordSchema = exports.AccessPolicySchema = void 0;
const zod_1 = require("zod");
const EncryptionSchema = zod_1.z.object({
    enabled: zod_1.z.boolean(),
    method: zod_1.z.string().optional(),
    keyRef: zod_1.z.string().optional(),
    nonce: zod_1.z.string().optional(),
    ciphertext: zod_1.z.boolean().optional(),
});
const AccessPolicySchema = zod_1.z.object({
    hiddenFromLLM: zod_1.z.boolean(),
    allowedTools: zod_1.z.array(zod_1.z.string()).optional(),
    allowedUsers: zod_1.z.array(zod_1.z.string()).optional()
});
exports.AccessPolicySchema = AccessPolicySchema;
const PipeRecordSchema = zod_1.z.object({
    cid: zod_1.z.string().optional(),
    content: zod_1.z.any(),
    type: zod_1.z.enum(['data', 'schema']),
    scope: zod_1.z.enum(['private', 'public', 'machine', 'user']),
    accessPolicy: AccessPolicySchema,
    encryption: zod_1.z.object({
        enabled: zod_1.z.boolean(),
        method: zod_1.z.string().optional(),
        keyRef: zod_1.z.string().optional(),
        ciphertext: zod_1.z.boolean().optional()
    })
});
exports.PipeRecordSchema = PipeRecordSchema;
const PipeBundleSchema = zod_1.z.object({
    schemaRecord: PipeRecordSchema,
    dataRecord: PipeRecordSchema,
    timestamp: zod_1.z.string().optional()
});
exports.PipeBundleSchema = PipeBundleSchema;
//# sourceMappingURL=schema.js.map

================
File: dist-scripts/src/schema.js.map
================
{"version":3,"file":"schema.js","sourceRoot":"","sources":["../../src/schema.ts"],"names":[],"mappings":";;;AAAA,6BAAwB;AAGxB,MAAM,gBAAgB,GAAgC,OAAC,CAAC,MAAM,CAAC;IAC7D,OAAO,EAAE,OAAC,CAAC,OAAO,EAAE;IACpB,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IAC7B,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IAC7B,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IAC5B,UAAU,EAAE,OAAC,CAAC,OAAO,EAAE,CAAC,QAAQ,EAAE;CACnC,CAAC,CAAC;AAEH,MAAM,kBAAkB,GAA8B,OAAC,CAAC,MAAM,CAAC;IAC7D,aAAa,EAAE,OAAC,CAAC,OAAO,EAAE;IAC1B,YAAY,EAAE,OAAC,CAAC,KAAK,CAAC,OAAC,CAAC,MAAM,EAAE,CAAC,CAAC,QAAQ,EAAE;IAC5C,YAAY,EAAE,OAAC,CAAC,KAAK,CAAC,OAAC,CAAC,MAAM,EAAE,CAAC,CAAC,QAAQ,EAAE;CAC7C,CAAC,CAAC;AAsBM,gDAAkB;AApB3B,MAAM,gBAAgB,GAAG,OAAC,CAAC,MAAM,CAAC;IAChC,GAAG,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IAC1B,OAAO,EAAE,OAAC,CAAC,GAAG,EAAE;IAChB,IAAI,EAAE,OAAC,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAChC,KAAK,EAAE,OAAC,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;IACvD,YAAY,EAAE,kBAAkB;IAChC,UAAU,EAAE,OAAC,CAAC,MAAM,CAAC;QACnB,OAAO,EAAE,OAAC,CAAC,OAAO,EAAE;QACpB,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;QAC7B,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;QAC7B,UAAU,EAAE,OAAC,CAAC,OAAO,EAAE,CAAC,QAAQ,EAAE;KACnC,CAAC;CACH,CAAC,CAAC;AAQ0B,4CAAgB;AAN7C,MAAM,gBAAgB,GAAG,OAAC,CAAC,MAAM,CAAC;IAChC,YAAY,EAAE,gBAAgB;IAC9B,UAAU,EAAE,gBAAgB;IAC5B,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;CACjC,CAAC,CAAC;AAE4C,4CAAgB"}

================
File: dist-scripts/src/types.d.ts
================
export interface EncryptionInfo {
    enabled: boolean;
    method?: string;
    keyRef?: string;
    nonce?: string;
    ciphertext?: boolean;
    contentType?: 'string' | 'json';
}
export interface AccessPolicy {
    hiddenFromLLM: boolean;
    allowedTools?: string[];
    allowedUsers?: string[];
}
export type Scope = 'private' | 'public' | 'machine' | 'user';
export interface PipeRecord {
    cid?: string;
    content: any;
    type: 'data' | 'schema';
    scope: Scope;
    accessPolicy: AccessPolicy;
    encryption: EncryptionInfo;
}
export interface PipeBundle {
    schemaRecord: PipeRecord;
    dataRecord: PipeRecord;
    timestamp?: string;
}
export interface PipeOptions {
    localNodeEndpoint?: string;
    publicNodeEndpoint?: string;
    hooks?: PipeHook[];
}
export interface PipeIpfsOptions {
    endpoint?: string;
    options?: Record<string, any>;
    localNodeEndpoint?: string;
    publicNodeEndpoint?: string;
}
export interface PipeHook {
    name: string;
    trigger: 'pre-store' | 'post-store';
    handler: (data: any, metadata: Record<string, any>) => Promise<any>;
}
export interface StoreOptions {
    scope?: Scope;
    generateSchema?: boolean;
    pin?: boolean;
}
export interface Tool {
    name: string;
    description: string;
    parameters: {
        type: 'object';
        properties: Record<string, any>;
        required?: string[];
    };
    returns?: {
        type: string;
        description?: string;
    };
    call: (args: any) => Promise<any>;
}
export interface IpfsNodeConfig {
    endpoint?: string;
    options?: Record<string, any>;
}
//# sourceMappingURL=types.d.ts.map

================
File: dist-scripts/src/types.d.ts.map
================
{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"AAAA,MAAM,WAAW,cAAc;IAC7B,OAAO,EAAE,OAAO,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,UAAU,CAAC,EAAE,OAAO,CAAC;IACrB,WAAW,CAAC,EAAE,QAAQ,GAAG,MAAM,CAAC;CACjC;AAED,MAAM,WAAW,YAAY;IAC3B,aAAa,EAAE,OAAO,CAAC;IACvB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;CACzB;AAED,MAAM,MAAM,KAAK,GAAG,SAAS,GAAG,QAAQ,GAAG,SAAS,GAAG,MAAM,CAAC;AAE9D,MAAM,WAAW,UAAU;IACzB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,GAAG,CAAC;IACb,IAAI,EAAE,MAAM,GAAG,QAAQ,CAAC;IACxB,KAAK,EAAE,KAAK,CAAC;IACb,YAAY,EAAE,YAAY,CAAC;IAC3B,UAAU,EAAE,cAAc,CAAC;CAC5B;AAED,MAAM,WAAW,UAAU;IACzB,YAAY,EAAE,UAAU,CAAC;IACzB,UAAU,EAAE,UAAU,CAAC;IACvB,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,MAAM,WAAW,WAAW;IAC1B,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B,KAAK,CAAC,EAAE,QAAQ,EAAE,CAAC;CACpB;AAED,MAAM,WAAW,eAAe;IAC9B,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC9B,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,kBAAkB,CAAC,EAAE,MAAM,CAAC;CAC7B;AAED,MAAM,WAAW,QAAQ;IACvB,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,WAAW,GAAG,YAAY,CAAC;IACpC,OAAO,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,OAAO,CAAC,GAAG,CAAC,CAAC;CACrE;AAED,MAAM,WAAW,YAAY;IAC3B,KAAK,CAAC,EAAE,KAAK,CAAC;IACd,cAAc,CAAC,EAAE,OAAO,CAAC;IACzB,GAAG,CAAC,EAAE,OAAO,CAAC;CACf;AAED,MAAM,WAAW,IAAI;IACnB,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,UAAU,EAAE;QACV,IAAI,EAAE,QAAQ,CAAC;QACf,UAAU,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAChC,QAAQ,CAAC,EAAE,MAAM,EAAE,CAAC;KACrB,CAAC;IACF,OAAO,CAAC,EAAE;QACR,IAAI,EAAE,MAAM,CAAC;QACb,WAAW,CAAC,EAAE,MAAM,CAAC;KACtB,CAAC;IACF,IAAI,EAAE,CAAC,IAAI,EAAE,GAAG,KAAK,OAAO,CAAC,GAAG,CAAC,CAAC;CACnC;AAED,MAAM,WAAW,cAAc;IAC7B,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;CAC/B"}

================
File: dist-scripts/src/types.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map

================
File: dist-scripts/src/types.js.map
================
{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":""}

================
File: pipe-core/package.json
================
{
  "name": "pipe-core",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.13.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "helia": "^5.2.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "typescript": "^5.7.3",
    "zod": "^3.24.1"
  }
}

================
File: pipe-core/tsconfig.json
================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2016",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-archive-f05.json
================
{"archive":{"blogPosts":[{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-26-welcome/index.md","source":"@site/blog/2021-08-26-welcome/index.md","title":"Welcome","description":"Docusaurus blogging features are powered by the blog plugin.","date":"2021-08-26T00:00:00.000Z","tags":[{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description"},{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.465,"hasTruncateMarker":true,"authors":[{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["slorber","yangshun"],"tags":["facebook","hello","docusaurus"]},"unlisted":false,"nextItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"}},"content":"[Docusaurus blogging features](https://docusaurus.io/docs/blog) are powered by the [blog plugin](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).\n\nHere are a few tips you might find useful.\n\n<!-- truncate -->\n\nSimply add Markdown files (or folders) to the `blog` directory.\n\nRegular blog authors can be added to `authors.yml`.\n\nThe blog post date can be extracted from filenames, such as:\n\n- `2019-05-30-welcome.md`\n- `2019-05-30-welcome/index.md`\n\nA blog post folder can be convenient to co-locate blog post images:\n\n![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)\n\nThe blog supports tags as well!\n\n**And if you don't want a blog**: just delete this directory, and use `blog: false` in your Docusaurus config."},{"id":"mdx-blog-post","metadata":{"permalink":"/blog/mdx-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-01-mdx-blog-post.mdx","source":"@site/blog/2021-08-01-mdx-blog-post.mdx","title":"MDX Blog Post","description":"Blog posts support Docusaurus Markdown features, such as MDX.","date":"2021-08-01T00:00:00.000Z","tags":[{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.235,"hasTruncateMarker":true,"authors":[{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"}],"frontMatter":{"slug":"mdx-blog-post","title":"MDX Blog Post","authors":["slorber"],"tags":["docusaurus"]},"unlisted":false,"prevItem":{"title":"Welcome","permalink":"/blog/welcome"},"nextItem":{"title":"Long Blog Post","permalink":"/blog/long-blog-post"}},"content":"Blog posts support [Docusaurus Markdown features](https://docusaurus.io/docs/markdown-features), such as [MDX](https://mdxjs.com/).\n\n:::tip\n\nUse the power of React to create interactive blog posts.\n\n:::\n\n{/* truncate */}\n\nFor example, use JSX to create an interactive button:\n\n```js\n<button onClick={() => alert('button clicked!')}>Click me!</button>\n```\n\n<button onClick={() => alert('button clicked!')}>Click me!</button>"},{"id":"long-blog-post","metadata":{"permalink":"/blog/long-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-29-long-blog-post.md","source":"@site/blog/2019-05-29-long-blog-post.md","title":"Long Blog Post","description":"This is the summary of a very long blog post,","date":"2019-05-29T00:00:00.000Z","tags":[{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":2.06,"hasTruncateMarker":true,"authors":[{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"long-blog-post","title":"Long Blog Post","authors":"yangshun","tags":["hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"},"nextItem":{"title":"First Blog Post","permalink":"/blog/first-blog-post"}},"content":"This is the summary of a very long blog post,\n\nUse a `<!--` `truncate` `-->` comment to limit blog post size in the list view.\n\n<!-- truncate -->\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet"},{"id":"first-blog-post","metadata":{"permalink":"/blog/first-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-28-first-blog-post.md","source":"@site/blog/2019-05-28-first-blog-post.md","title":"First Blog Post","description":"Lorem ipsum dolor sit amet...","date":"2019-05-28T00:00:00.000Z","tags":[{"inline":false,"label":"Hola","permalink":"/blog/tags/hola","description":"Hola tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.135,"hasTruncateMarker":true,"authors":[{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"first-blog-post","title":"First Blog Post","authors":["slorber","yangshun"],"tags":["hola","docusaurus"]},"unlisted":false,"prevItem":{"title":"Long Blog Post","permalink":"/blog/long-blog-post"}},"content":"Lorem ipsum dolor sit amet...\n\n<!-- truncate -->\n\n...consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet"}]}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-authors-790.json
================
{"authors":[{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun","count":3},{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber","count":3}]}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-authors-all-sebastien-lorber-articles-6eb.json
================
{"author":{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber","count":3},"listMetadata":{"permalink":"/blog/authors/all-sebastien-lorber-articles","page":1,"postsPerPage":10,"totalPages":1,"totalCount":3,"blogDescription":"Blog","blogTitle":"Blog"}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-authors-yangshun-af2.json
================
{"author":{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun","count":3},"listMetadata":{"permalink":"/blog/authors/yangshun","page":1,"postsPerPage":10,"totalPages":1,"totalCount":3,"blogDescription":"Blog","blogTitle":"Blog"}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-bd9.json
================
{"metadata":{"permalink":"/blog","page":1,"postsPerPage":10,"totalPages":1,"totalCount":4,"blogDescription":"Blog","blogTitle":"Blog"}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-tags-df9.json
================
{"tags":[{"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description","count":1},{"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description","count":2},{"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description","count":4},{"label":"Hola","permalink":"/blog/tags/hola","description":"Hola tag description","count":1}]}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-tags-docusaurus-f20.json
================
{"tag":{"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description","allTagsPath":"/blog/tags","count":4,"unlisted":false},"listMetadata":{"permalink":"/blog/tags/docusaurus","page":1,"postsPerPage":10,"totalPages":1,"totalCount":4,"blogDescription":"Blog","blogTitle":"Blog"}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-tags-facebook-f47.json
================
{"tag":{"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description","allTagsPath":"/blog/tags","count":1,"unlisted":false},"listMetadata":{"permalink":"/blog/tags/facebook","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-tags-hello-f96.json
================
{"tag":{"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description","allTagsPath":"/blog/tags","count":2,"unlisted":false},"listMetadata":{"permalink":"/blog/tags/hello","page":1,"postsPerPage":10,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/p/blog-tags-hola-73f.json
================
{"tag":{"label":"Hola","permalink":"/blog/tags/hola","description":"Hola tag description","allTagsPath":"/blog/tags","count":1,"unlisted":false},"listMetadata":{"permalink":"/blog/tags/hola","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/__plugin.json
================
{
  "name": "docusaurus-plugin-content-blog",
  "id": "default"
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/blog-post-list-prop-default.json
================
{
  "title": "Recent posts",
  "items": [
    {
      "title": "Welcome",
      "permalink": "/blog/welcome",
      "unlisted": false,
      "date": "2021-08-26T00:00:00.000Z"
    },
    {
      "title": "MDX Blog Post",
      "permalink": "/blog/mdx-blog-post",
      "unlisted": false,
      "date": "2021-08-01T00:00:00.000Z"
    },
    {
      "title": "Long Blog Post",
      "permalink": "/blog/long-blog-post",
      "unlisted": false,
      "date": "2019-05-29T00:00:00.000Z"
    },
    {
      "title": "First Blog Post",
      "permalink": "/blog/first-blog-post",
      "unlisted": false,
      "date": "2019-05-28T00:00:00.000Z"
    }
  ]
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/blogMetadata-default.json
================
{
  "blogBasePath": "/blog",
  "blogTitle": "Blog",
  "authorsListPath": "/blog/authors"
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/site-blog-2019-05-28-first-blog-post-md-e27.json
================
{
  "permalink": "/blog/first-blog-post",
  "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-28-first-blog-post.md",
  "source": "@site/blog/2019-05-28-first-blog-post.md",
  "title": "First Blog Post",
  "description": "Lorem ipsum dolor sit amet...",
  "date": "2019-05-28T00:00:00.000Z",
  "tags": [
    {
      "inline": false,
      "label": "Hola",
      "permalink": "/blog/tags/hola",
      "description": "Hola tag description"
    },
    {
      "inline": false,
      "label": "Docusaurus",
      "permalink": "/blog/tags/docusaurus",
      "description": "Docusaurus tag description"
    }
  ],
  "readingTime": 0.135,
  "hasTruncateMarker": true,
  "authors": [
    {
      "name": "Sébastien Lorber",
      "title": "Docusaurus maintainer",
      "url": "https://sebastienlorber.com",
      "page": {
        "permalink": "/blog/authors/all-sebastien-lorber-articles"
      },
      "socials": {
        "x": "https://x.com/sebastienlorber",
        "linkedin": "https://www.linkedin.com/in/sebastienlorber/",
        "github": "https://github.com/slorber",
        "newsletter": "https://thisweekinreact.com"
      },
      "imageURL": "https://github.com/slorber.png",
      "key": "slorber"
    },
    {
      "name": "Yangshun Tay",
      "title": "Front End Engineer @ Facebook",
      "url": "https://github.com/yangshun",
      "page": {
        "permalink": "/blog/authors/yangshun"
      },
      "socials": {
        "x": "https://x.com/yangshunz",
        "github": "https://github.com/yangshun"
      },
      "imageURL": "https://github.com/yangshun.png",
      "key": "yangshun"
    }
  ],
  "frontMatter": {
    "slug": "first-blog-post",
    "title": "First Blog Post",
    "authors": [
      "slorber",
      "yangshun"
    ],
    "tags": [
      "hola",
      "docusaurus"
    ]
  },
  "unlisted": false,
  "prevItem": {
    "title": "Long Blog Post",
    "permalink": "/blog/long-blog-post"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/site-blog-2019-05-29-long-blog-post-md-736.json
================
{
  "permalink": "/blog/long-blog-post",
  "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-29-long-blog-post.md",
  "source": "@site/blog/2019-05-29-long-blog-post.md",
  "title": "Long Blog Post",
  "description": "This is the summary of a very long blog post,",
  "date": "2019-05-29T00:00:00.000Z",
  "tags": [
    {
      "inline": false,
      "label": "Hello",
      "permalink": "/blog/tags/hello",
      "description": "Hello tag description"
    },
    {
      "inline": false,
      "label": "Docusaurus",
      "permalink": "/blog/tags/docusaurus",
      "description": "Docusaurus tag description"
    }
  ],
  "readingTime": 2.06,
  "hasTruncateMarker": true,
  "authors": [
    {
      "name": "Yangshun Tay",
      "title": "Front End Engineer @ Facebook",
      "url": "https://github.com/yangshun",
      "page": {
        "permalink": "/blog/authors/yangshun"
      },
      "socials": {
        "x": "https://x.com/yangshunz",
        "github": "https://github.com/yangshun"
      },
      "imageURL": "https://github.com/yangshun.png",
      "key": "yangshun"
    }
  ],
  "frontMatter": {
    "slug": "long-blog-post",
    "title": "Long Blog Post",
    "authors": "yangshun",
    "tags": [
      "hello",
      "docusaurus"
    ]
  },
  "unlisted": false,
  "prevItem": {
    "title": "MDX Blog Post",
    "permalink": "/blog/mdx-blog-post"
  },
  "nextItem": {
    "title": "First Blog Post",
    "permalink": "/blog/first-blog-post"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/site-blog-2021-08-01-mdx-blog-post-mdx-593.json
================
{
  "permalink": "/blog/mdx-blog-post",
  "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-01-mdx-blog-post.mdx",
  "source": "@site/blog/2021-08-01-mdx-blog-post.mdx",
  "title": "MDX Blog Post",
  "description": "Blog posts support Docusaurus Markdown features, such as MDX.",
  "date": "2021-08-01T00:00:00.000Z",
  "tags": [
    {
      "inline": false,
      "label": "Docusaurus",
      "permalink": "/blog/tags/docusaurus",
      "description": "Docusaurus tag description"
    }
  ],
  "readingTime": 0.235,
  "hasTruncateMarker": true,
  "authors": [
    {
      "name": "Sébastien Lorber",
      "title": "Docusaurus maintainer",
      "url": "https://sebastienlorber.com",
      "page": {
        "permalink": "/blog/authors/all-sebastien-lorber-articles"
      },
      "socials": {
        "x": "https://x.com/sebastienlorber",
        "linkedin": "https://www.linkedin.com/in/sebastienlorber/",
        "github": "https://github.com/slorber",
        "newsletter": "https://thisweekinreact.com"
      },
      "imageURL": "https://github.com/slorber.png",
      "key": "slorber"
    }
  ],
  "frontMatter": {
    "slug": "mdx-blog-post",
    "title": "MDX Blog Post",
    "authors": [
      "slorber"
    ],
    "tags": [
      "docusaurus"
    ]
  },
  "unlisted": false,
  "prevItem": {
    "title": "Welcome",
    "permalink": "/blog/welcome"
  },
  "nextItem": {
    "title": "Long Blog Post",
    "permalink": "/blog/long-blog-post"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-blog/default/site-blog-2021-08-26-welcome-index-md-d9f.json
================
{
  "permalink": "/blog/welcome",
  "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-26-welcome/index.md",
  "source": "@site/blog/2021-08-26-welcome/index.md",
  "title": "Welcome",
  "description": "Docusaurus blogging features are powered by the blog plugin.",
  "date": "2021-08-26T00:00:00.000Z",
  "tags": [
    {
      "inline": false,
      "label": "Facebook",
      "permalink": "/blog/tags/facebook",
      "description": "Facebook tag description"
    },
    {
      "inline": false,
      "label": "Hello",
      "permalink": "/blog/tags/hello",
      "description": "Hello tag description"
    },
    {
      "inline": false,
      "label": "Docusaurus",
      "permalink": "/blog/tags/docusaurus",
      "description": "Docusaurus tag description"
    }
  ],
  "readingTime": 0.465,
  "hasTruncateMarker": true,
  "authors": [
    {
      "name": "Sébastien Lorber",
      "title": "Docusaurus maintainer",
      "url": "https://sebastienlorber.com",
      "page": {
        "permalink": "/blog/authors/all-sebastien-lorber-articles"
      },
      "socials": {
        "x": "https://x.com/sebastienlorber",
        "linkedin": "https://www.linkedin.com/in/sebastienlorber/",
        "github": "https://github.com/slorber",
        "newsletter": "https://thisweekinreact.com"
      },
      "imageURL": "https://github.com/slorber.png",
      "key": "slorber"
    },
    {
      "name": "Yangshun Tay",
      "title": "Front End Engineer @ Facebook",
      "url": "https://github.com/yangshun",
      "page": {
        "permalink": "/blog/authors/yangshun"
      },
      "socials": {
        "x": "https://x.com/yangshunz",
        "github": "https://github.com/yangshun"
      },
      "imageURL": "https://github.com/yangshun.png",
      "key": "yangshun"
    }
  ],
  "frontMatter": {
    "slug": "welcome",
    "title": "Welcome",
    "authors": [
      "slorber",
      "yangshun"
    ],
    "tags": [
      "facebook",
      "hello",
      "docusaurus"
    ]
  },
  "unlisted": false,
  "nextItem": {
    "title": "MDX Blog Post",
    "permalink": "/blog/mdx-blog-post"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/p/docs-175.json
================
{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"category","label":"Introduction","items":[{"type":"link","label":"Tutorial Intro","href":"/docs/intro","docId":"intro","unlisted":false},{"type":"link","label":"Pipe Protocol Overview","href":"/docs/introduction/overview","docId":"introduction/overview","unlisted":false},{"type":"link","label":"The Problem Pipe Solves","href":"/docs/introduction/problem","docId":"introduction/problem","unlisted":false},{"type":"link","label":"How Pipe Solves the Problem","href":"/docs/introduction/solution","docId":"introduction/solution","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Core Concepts","items":[{"type":"link","label":"Terminology","href":"/docs/core-concepts/terminology","docId":"core-concepts/terminology","unlisted":false},{"type":"link","label":"Scopes","href":"/docs/core-concepts/scopes","docId":"core-concepts/scopes","unlisted":false},{"type":"link","label":"PipeRecord","href":"/docs/core-concepts/piperecord","docId":"core-concepts/piperecord","unlisted":false},{"type":"link","label":"PipeBundle","href":"/docs/core-concepts/pipebundle","docId":"core-concepts/pipebundle","unlisted":false},{"type":"link","label":"Encryption and Hidden-from-LLM Data","href":"/docs/core-concepts/encryption","docId":"core-concepts/encryption","unlisted":false},{"type":"link","label":"Inline vs. Referenced Content","href":"/docs/core-concepts/inline-referenced","docId":"core-concepts/inline-referenced","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Usage Examples","items":[{"type":"link","label":"Fetching Data and Schema","href":"/docs/usage-examples/fetch-data","docId":"usage-examples/fetch-data","unlisted":false},{"type":"link","label":"Working with Bundles","href":"/docs/usage-examples/work-bundles","docId":"usage-examples/work-bundles","unlisted":false},{"type":"link","label":"Publishing Hidden Data","href":"/docs/usage-examples/publish-hidden-data","docId":"usage-examples/publish-hidden-data","unlisted":false},{"type":"link","label":"Managing Pinned Content","href":"/docs/usage-examples/pin-unpin","docId":"usage-examples/pin-unpin","unlisted":false},{"type":"link","label":"Replicating Data","href":"/docs/usage-examples/replicate-data","docId":"usage-examples/replicate-data","unlisted":false},{"type":"link","label":"Publishing Data and Schema","href":"/docs/usage-examples/publish-data","docId":"usage-examples/publish-data","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Reference","items":[{"type":"link","label":"GET /node-status","href":"/docs/api-reference/node-status","docId":"api-reference/node-status","unlisted":false},{"type":"link","label":"GET /node-info","href":"/docs/api-reference/node-info","docId":"api-reference/node-info","unlisted":false},{"type":"link","label":"GET /storage-metrics","href":"/docs/api-reference/storage-metrics","docId":"api-reference/storage-metrics","unlisted":false},{"type":"link","label":"GET /pinned-cids","href":"/docs/api-reference/pinned-cids","docId":"api-reference/pinned-cids","unlisted":false},{"type":"link","label":"GET /configuration","href":"/docs/api-reference/configuration","docId":"api-reference/configuration","unlisted":false},{"type":"link","label":"GET /fetch","href":"/docs/api-reference/fetch","docId":"api-reference/fetch","unlisted":false},{"type":"link","label":"POST /publish","href":"/docs/api-reference/publish","docId":"api-reference/publish","unlisted":false},{"type":"link","label":"POST /publish-bundle","href":"/docs/api-reference/publish-bundle","docId":"api-reference/publish-bundle","unlisted":false},{"type":"link","label":"POST /pin","href":"/docs/api-reference/pin","docId":"api-reference/pin","unlisted":false},{"type":"link","label":"POST /unpin","href":"/docs/api-reference/unpin","docId":"api-reference/unpin","unlisted":false},{"type":"link","label":"POST /replicate","href":"/docs/api-reference/replicate","docId":"api-reference/replicate","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"api-reference/configuration":{"id":"api-reference/configuration","title":"GET /configuration","description":"Returns the current configuration of a specified IPFS node. This endpoint provides detailed information about node settings, network configuration, and runtime parameters.","sidebar":"docs"},"api-reference/fetch":{"id":"api-reference/fetch","title":"GET /fetch","description":"Fetches a PipeRecord by its CID from a specified scope. This endpoint retrieves both the record metadata and its content, if available.","sidebar":"docs"},"api-reference/node-info":{"id":"api-reference/node-info","title":"GET /node-info","description":"Returns detailed information about a specific IPFS node managed by the Pipe protocol. This endpoint provides configuration and identity information for either the private or public node.","sidebar":"docs"},"api-reference/node-status":{"id":"api-reference/node-status","title":"GET /node-status","description":"Returns the status of the IPFS nodes managed by the Pipe protocol. This endpoint provides information about the availability and health of both private and public nodes.","sidebar":"docs"},"api-reference/pin":{"id":"api-reference/pin","title":"POST /pin","description":"Pins a CID in a specified scope, preventing it from being garbage collected. Pinned content remains available until explicitly unpinned.","sidebar":"docs"},"api-reference/pinned-cids":{"id":"api-reference/pinned-cids","title":"GET /pinned-cids","description":"Returns a list of Content Identifiers (CIDs) that are currently pinned in a specified scope. This endpoint provides information about pinned content and their metadata.","sidebar":"docs"},"api-reference/publish":{"id":"api-reference/publish","title":"POST /publish","description":"Publishes a single PipeRecord to IPFS. This endpoint handles both inline content and referenced data, with support for encryption and access control.","sidebar":"docs"},"api-reference/publish-bundle":{"id":"api-reference/publish-bundle","title":"POST /publish-bundle","description":"Publishes a PipeBundle containing both schema and data records. This endpoint handles the creation and storage of related schema and data content as a single unit.","sidebar":"docs"},"api-reference/replicate":{"id":"api-reference/replicate","title":"POST /replicate","description":"Replicates content from one scope to another. This endpoint is primarily used to move content between private and public scopes, enabling controlled sharing of data.","sidebar":"docs"},"api-reference/storage-metrics":{"id":"api-reference/storage-metrics","title":"GET /storage-metrics","description":"Returns storage usage metrics for a specified IPFS node. This endpoint provides detailed information about storage consumption, including repository size, content distribution, and pinned data metrics.","sidebar":"docs"},"api-reference/unpin":{"id":"api-reference/unpin","title":"POST /unpin","description":"Unpins a CID from a specified scope, allowing it to be garbage collected if no other pins exist. This endpoint is used to manage storage by removing pins from content that is no longer needed.","sidebar":"docs"},"core-concepts/encryption":{"id":"core-concepts/encryption","title":"Encryption and Hidden-from-LLM Data","description":"The Pipe protocol provides robust encryption capabilities, allowing data to be securely stored and optionally hidden from LLMs. This document explains the encryption features and how to use them effectively.","sidebar":"docs"},"core-concepts/inline-referenced":{"id":"core-concepts/inline-referenced","title":"Inline vs. Referenced Content","description":"The Pipe protocol supports two methods of storing content: inline and referenced. Each approach has its own advantages and use cases.","sidebar":"docs"},"core-concepts/pipebundle":{"id":"core-concepts/pipebundle","title":"PipeBundle","description":"A PipeBundle combines a schema and data record, providing a way to package related schema and data together. This is particularly useful when a piece of data has a defined schema that describes its structure.","sidebar":"docs"},"core-concepts/piperecord":{"id":"core-concepts/piperecord","title":"PipeRecord","description":"A PipeRecord is the fundamental data structure in the Pipe protocol. It represents a single piece of content—either data or schema—that can be referenced by a CID or optionally stored inline.","sidebar":"docs"},"core-concepts/scopes":{"id":"core-concepts/scopes","title":"Scopes","description":"In the Pipe protocol, scopes determine how and where data is stored and accessed. Each scope has specific characteristics and use cases.","sidebar":"docs"},"core-concepts/terminology":{"id":"core-concepts/terminology","title":"Terminology","description":"This section defines key terms used throughout the Pipe protocol documentation.","sidebar":"docs"},"intro":{"id":"intro","title":"Tutorial Intro","description":"Let's discover Docusaurus in less than 5 minutes.","sidebar":"docs"},"introduction/overview":{"id":"introduction/overview","title":"Pipe Protocol Overview","description":"Pipe is a protocol designed for efficient data handling in multi-agent Large Language Model (LLM) systems. It allows agents to share and reference large or structured data through IPFS (InterPlanetary File System), minimizing context overload and improving scalability.","sidebar":"docs"},"introduction/problem":{"id":"introduction/problem","title":"The Problem Pipe Solves","description":"In multi-agent LLM systems, agents often exchange state by directly passing large data inline. This approach leads to several critical issues:","sidebar":"docs"},"introduction/solution":{"id":"introduction/solution","title":"How Pipe Solves the Problem","description":"Pipe provides a comprehensive solution to the challenges of data handling in multi-agent LLM systems through several key mechanisms:","sidebar":"docs"},"tutorial-basics/congratulations":{"id":"tutorial-basics/congratulations","title":"Congratulations!","description":"You have just learned the basics of Docusaurus and made some changes to the initial template."},"tutorial-basics/create-a-blog-post":{"id":"tutorial-basics/create-a-blog-post","title":"Create a Blog Post","description":"Docusaurus creates a page for each blog post, but also a blog index page, a tag system, an RSS feed..."},"tutorial-basics/create-a-document":{"id":"tutorial-basics/create-a-document","title":"Create a Document","description":"Documents are groups of pages connected through:"},"tutorial-basics/create-a-page":{"id":"tutorial-basics/create-a-page","title":"Create a Page","description":"Add Markdown or React files to src/pages to create a standalone page:"},"tutorial-basics/deploy-your-site":{"id":"tutorial-basics/deploy-your-site","title":"Deploy your site","description":"Docusaurus is a static-site-generator (also called Jamstack)."},"tutorial-basics/markdown-features":{"id":"tutorial-basics/markdown-features","title":"Markdown Features","description":"Docusaurus supports Markdown and a few additional features."},"tutorial-extras/manage-docs-versions":{"id":"tutorial-extras/manage-docs-versions","title":"Manage Docs Versions","description":"Docusaurus can manage multiple versions of your docs."},"tutorial-extras/translate-your-site":{"id":"tutorial-extras/translate-your-site","title":"Translate your site","description":"Let's translate docs/intro.md to French."},"usage-examples/fetch-data":{"id":"usage-examples/fetch-data","title":"Fetching Data and Schema","description":"This guide demonstrates how to fetch data and schema records using the Pipe protocol. We'll cover various scenarios including inline content, referenced content, and encrypted data.","sidebar":"docs"},"usage-examples/pin-unpin":{"id":"usage-examples/pin-unpin","title":"Managing Pinned Content","description":"This guide demonstrates how to manage pinned content in the Pipe protocol. We'll cover pinning, unpinning, and various strategies for content retention.","sidebar":"docs"},"usage-examples/publish-data":{"id":"usage-examples/publish-data","title":"Publishing Data and Schema","description":"This guide demonstrates how to publish data and schema records using the Pipe protocol.","sidebar":"docs"},"usage-examples/publish-hidden-data":{"id":"usage-examples/publish-hidden-data","title":"Publishing Hidden Data","description":"This guide demonstrates how to publish data that should be hidden from Large Language Models (LLMs) using the Pipe protocol. We'll cover various scenarios including encryption, access policies, and tool-specific access.","sidebar":"docs"},"usage-examples/replicate-data":{"id":"usage-examples/replicate-data","title":"Replicating Data","description":"This guide demonstrates how to replicate data between different scopes in the Pipe protocol. We'll cover various replication scenarios and best practices for data distribution.","sidebar":"docs"},"usage-examples/work-bundles":{"id":"usage-examples/work-bundles","title":"Working with Bundles","description":"This guide demonstrates how to work with PipeBundle objects in the Pipe protocol. We'll cover creating, publishing, and fetching bundles that combine schema and data records.","sidebar":"docs"}}}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/p/docs-category-tutorial-basics-ea4.json
================
{"categoryGeneratedIndex":{"title":"Tutorial - Basics","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/tutorial---basics","permalink":"/docs/category/tutorial---basics","sidebar":"tutorialSidebar","navigation":{"previous":{"title":"Tutorial Intro","permalink":"/docs/intro"},"next":{"title":"Create a Page","permalink":"/docs/tutorial-basics/create-a-page"}}}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/p/docs-category-tutorial-extras-128.json
================
{"categoryGeneratedIndex":{"title":"Tutorial - Extras","slug":"/category/tutorial---extras","permalink":"/docs/category/tutorial---extras","sidebar":"tutorialSidebar","navigation":{"previous":{"title":"Congratulations!","permalink":"/docs/tutorial-basics/congratulations"},"next":{"title":"Manage Docs Versions","permalink":"/docs/tutorial-extras/manage-docs-versions"}}}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/p/index-466.json
================
{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"category","label":"Introduction","items":[{"type":"link","label":"Tutorial Intro","href":"/intro","docId":"intro","unlisted":false},{"type":"link","label":"Pipe Protocol Overview","href":"/introduction/overview","docId":"introduction/overview","unlisted":false},{"type":"link","label":"The Problem Pipe Solves","href":"/introduction/problem","docId":"introduction/problem","unlisted":false},{"type":"link","label":"How Pipe Solves the Problem","href":"/introduction/solution","docId":"introduction/solution","unlisted":false}],"collapsed":false,"collapsible":true},{"type":"category","label":"Core Concepts","items":[{"type":"link","label":"Terminology","href":"/core-concepts/terminology","docId":"core-concepts/terminology","unlisted":false},{"type":"link","label":"Scopes","href":"/core-concepts/scopes","docId":"core-concepts/scopes","unlisted":false},{"type":"link","label":"PipeRecord","href":"/core-concepts/piperecord","docId":"core-concepts/piperecord","unlisted":false},{"type":"link","label":"PipeBundle","href":"/core-concepts/pipebundle","docId":"core-concepts/pipebundle","unlisted":false},{"type":"link","label":"Encryption and Hidden-from-LLM Data","href":"/core-concepts/encryption","docId":"core-concepts/encryption","unlisted":false},{"type":"link","label":"Inline vs. Referenced Content","href":"/core-concepts/inline-referenced","docId":"core-concepts/inline-referenced","unlisted":false}],"collapsed":false,"collapsible":true},{"type":"category","label":"Usage Examples","items":[{"type":"link","label":"Fetching Data and Schema","href":"/usage-examples/fetch-data","docId":"usage-examples/fetch-data","unlisted":false},{"type":"link","label":"Working with Bundles","href":"/usage-examples/work-bundles","docId":"usage-examples/work-bundles","unlisted":false},{"type":"link","label":"Publishing Hidden Data","href":"/usage-examples/publish-hidden-data","docId":"usage-examples/publish-hidden-data","unlisted":false},{"type":"link","label":"Managing Pinned Content","href":"/usage-examples/pin-unpin","docId":"usage-examples/pin-unpin","unlisted":false},{"type":"link","label":"Replicating Data","href":"/usage-examples/replicate-data","docId":"usage-examples/replicate-data","unlisted":false},{"type":"link","label":"Publishing Data and Schema","href":"/usage-examples/publish-data","docId":"usage-examples/publish-data","unlisted":false}],"collapsed":false,"collapsible":true},{"type":"category","label":"API Reference","items":[{"type":"link","label":"GET /node-status","href":"/api-reference/node-status","docId":"api-reference/node-status","unlisted":false},{"type":"link","label":"GET /node-info","href":"/api-reference/node-info","docId":"api-reference/node-info","unlisted":false},{"type":"link","label":"GET /storage-metrics","href":"/api-reference/storage-metrics","docId":"api-reference/storage-metrics","unlisted":false},{"type":"link","label":"GET /pinned-cids","href":"/api-reference/pinned-cids","docId":"api-reference/pinned-cids","unlisted":false},{"type":"link","label":"GET /configuration","href":"/api-reference/configuration","docId":"api-reference/configuration","unlisted":false},{"type":"link","label":"GET /fetch","href":"/api-reference/fetch","docId":"api-reference/fetch","unlisted":false},{"type":"link","label":"POST /publish","href":"/api-reference/publish","docId":"api-reference/publish","unlisted":false},{"type":"link","label":"POST /publish-bundle","href":"/api-reference/publish-bundle","docId":"api-reference/publish-bundle","unlisted":false},{"type":"link","label":"POST /pin","href":"/api-reference/pin","docId":"api-reference/pin","unlisted":false},{"type":"link","label":"POST /unpin","href":"/api-reference/unpin","docId":"api-reference/unpin","unlisted":false},{"type":"link","label":"POST /replicate","href":"/api-reference/replicate","docId":"api-reference/replicate","unlisted":false}],"collapsed":false,"collapsible":true}]},"docs":{"api-reference/configuration":{"id":"api-reference/configuration","title":"GET /configuration","description":"Returns the current configuration of a specified IPFS node. This endpoint provides detailed information about node settings, network configuration, and runtime parameters.","sidebar":"docs"},"api-reference/fetch":{"id":"api-reference/fetch","title":"GET /fetch","description":"Fetches a PipeRecord by its CID from a specified scope. This endpoint retrieves both the record metadata and its content, if available.","sidebar":"docs"},"api-reference/node-info":{"id":"api-reference/node-info","title":"GET /node-info","description":"Returns detailed information about a specific IPFS node managed by the Pipe protocol. This endpoint provides configuration and identity information for either the private or public node.","sidebar":"docs"},"api-reference/node-status":{"id":"api-reference/node-status","title":"GET /node-status","description":"Returns the status of the IPFS nodes managed by the Pipe protocol. This endpoint provides information about the availability and health of both private and public nodes.","sidebar":"docs"},"api-reference/pin":{"id":"api-reference/pin","title":"POST /pin","description":"Pins a CID in a specified scope, preventing it from being garbage collected. Pinned content remains available until explicitly unpinned.","sidebar":"docs"},"api-reference/pinned-cids":{"id":"api-reference/pinned-cids","title":"GET /pinned-cids","description":"Returns a list of Content Identifiers (CIDs) that are currently pinned in a specified scope. This endpoint provides information about pinned content and their metadata.","sidebar":"docs"},"api-reference/publish":{"id":"api-reference/publish","title":"POST /publish","description":"Publishes a single PipeRecord to IPFS. This endpoint handles both inline content and referenced data, with support for encryption and access control.","sidebar":"docs"},"api-reference/publish-bundle":{"id":"api-reference/publish-bundle","title":"POST /publish-bundle","description":"Publishes a PipeBundle containing both schema and data records. This endpoint handles the creation and storage of related schema and data content as a single unit.","sidebar":"docs"},"api-reference/replicate":{"id":"api-reference/replicate","title":"POST /replicate","description":"Replicates content from one scope to another. This endpoint is primarily used to move content between private and public scopes, enabling controlled sharing of data.","sidebar":"docs"},"api-reference/storage-metrics":{"id":"api-reference/storage-metrics","title":"GET /storage-metrics","description":"Returns storage usage metrics for a specified IPFS node. This endpoint provides detailed information about storage consumption, including repository size, content distribution, and pinned data metrics.","sidebar":"docs"},"api-reference/unpin":{"id":"api-reference/unpin","title":"POST /unpin","description":"Unpins a CID from a specified scope, allowing it to be garbage collected if no other pins exist. This endpoint is used to manage storage by removing pins from content that is no longer needed.","sidebar":"docs"},"core-concepts/encryption":{"id":"core-concepts/encryption","title":"Encryption and Hidden-from-LLM Data","description":"The Pipe protocol provides robust encryption capabilities, allowing data to be securely stored and optionally hidden from LLMs. This document explains the encryption features and how to use them effectively.","sidebar":"docs"},"core-concepts/inline-referenced":{"id":"core-concepts/inline-referenced","title":"Inline vs. Referenced Content","description":"The Pipe protocol supports two methods of storing content: inline and referenced. Each approach has its own advantages and use cases.","sidebar":"docs"},"core-concepts/pipebundle":{"id":"core-concepts/pipebundle","title":"PipeBundle","description":"A PipeBundle combines a schema and data record, providing a way to package related schema and data together. This is particularly useful when a piece of data has a defined schema that describes its structure.","sidebar":"docs"},"core-concepts/piperecord":{"id":"core-concepts/piperecord","title":"PipeRecord","description":"A PipeRecord is the fundamental data structure in the Pipe protocol. It represents a single piece of content—either data or schema—that can be referenced by a CID or optionally stored inline.","sidebar":"docs"},"core-concepts/scopes":{"id":"core-concepts/scopes","title":"Scopes","description":"In the Pipe protocol, scopes determine how and where data is stored and accessed. Each scope has specific characteristics and use cases.","sidebar":"docs"},"core-concepts/terminology":{"id":"core-concepts/terminology","title":"Terminology","description":"This section defines key terms used throughout the Pipe protocol documentation.","sidebar":"docs"},"intro":{"id":"intro","title":"Tutorial Intro","description":"Let's discover Docusaurus in less than 5 minutes.","sidebar":"docs"},"introduction/overview":{"id":"introduction/overview","title":"Pipe Protocol Overview","description":"Pipe is a protocol designed for efficient data handling in multi-agent Large Language Model (LLM) systems. It allows agents to share and reference large or structured data through IPFS (InterPlanetary File System), minimizing context overload and improving scalability.","sidebar":"docs"},"introduction/problem":{"id":"introduction/problem","title":"The Problem Pipe Solves","description":"In multi-agent LLM systems, agents often exchange state by directly passing large data inline. This approach leads to several critical issues:","sidebar":"docs"},"introduction/solution":{"id":"introduction/solution","title":"How Pipe Solves the Problem","description":"Pipe provides a comprehensive solution to the challenges of data handling in multi-agent LLM systems through several key mechanisms:","sidebar":"docs"},"tutorial-basics/congratulations":{"id":"tutorial-basics/congratulations","title":"Congratulations!","description":"You have just learned the basics of Docusaurus and made some changes to the initial template."},"tutorial-basics/create-a-blog-post":{"id":"tutorial-basics/create-a-blog-post","title":"Create a Blog Post","description":"Docusaurus creates a page for each blog post, but also a blog index page, a tag system, an RSS feed..."},"tutorial-basics/create-a-document":{"id":"tutorial-basics/create-a-document","title":"Create a Document","description":"Documents are groups of pages connected through:"},"tutorial-basics/create-a-page":{"id":"tutorial-basics/create-a-page","title":"Create a Page","description":"Add Markdown or React files to src/pages to create a standalone page:"},"tutorial-basics/deploy-your-site":{"id":"tutorial-basics/deploy-your-site","title":"Deploy your site","description":"Docusaurus is a static-site-generator (also called Jamstack)."},"tutorial-basics/markdown-features":{"id":"tutorial-basics/markdown-features","title":"Markdown Features","description":"Docusaurus supports Markdown and a few additional features."},"tutorial-extras/manage-docs-versions":{"id":"tutorial-extras/manage-docs-versions","title":"Manage Docs Versions","description":"Docusaurus can manage multiple versions of your docs."},"tutorial-extras/translate-your-site":{"id":"tutorial-extras/translate-your-site","title":"Translate your site","description":"Let's translate docs/intro.md to French."},"usage-examples/fetch-data":{"id":"usage-examples/fetch-data","title":"Fetching Data and Schema","description":"This guide demonstrates how to fetch data and schema records using the Pipe protocol. We'll cover various scenarios including inline content, referenced content, and encrypted data.","sidebar":"docs"},"usage-examples/pin-unpin":{"id":"usage-examples/pin-unpin","title":"Managing Pinned Content","description":"This guide demonstrates how to manage pinned content in the Pipe protocol. We'll cover pinning, unpinning, and various strategies for content retention.","sidebar":"docs"},"usage-examples/publish-data":{"id":"usage-examples/publish-data","title":"Publishing Data and Schema","description":"This guide demonstrates how to publish data and schema records using the Pipe protocol.","sidebar":"docs"},"usage-examples/publish-hidden-data":{"id":"usage-examples/publish-hidden-data","title":"Publishing Hidden Data","description":"This guide demonstrates how to publish data that should be hidden from Large Language Models (LLMs) using the Pipe protocol. We'll cover various scenarios including encryption, access policies, and tool-specific access.","sidebar":"docs"},"usage-examples/replicate-data":{"id":"usage-examples/replicate-data","title":"Replicating Data","description":"This guide demonstrates how to replicate data between different scopes in the Pipe protocol. We'll cover various replication scenarios and best practices for data distribution.","sidebar":"docs"},"usage-examples/work-bundles":{"id":"usage-examples/work-bundles","title":"Working with Bundles","description":"This guide demonstrates how to work with PipeBundle objects in the Pipe protocol. We'll cover creating, publishing, and fetching bundles that combine schema and data records.","sidebar":"docs"}}}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/__plugin.json
================
{
  "name": "docusaurus-plugin-content-docs",
  "id": "default"
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-configuration-md-4f2.json
================
{
  "id": "api-reference/configuration",
  "title": "GET /configuration",
  "description": "Returns the current configuration of a specified IPFS node. This endpoint provides detailed information about node settings, network configuration, and runtime parameters.",
  "source": "@site/docs/api-reference/configuration.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/configuration",
  "permalink": "/api-reference/configuration",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "GET /pinned-cids",
    "permalink": "/api-reference/pinned-cids"
  },
  "next": {
    "title": "GET /fetch",
    "permalink": "/api-reference/fetch"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-fetch-md-72c.json
================
{
  "id": "api-reference/fetch",
  "title": "GET /fetch",
  "description": "Fetches a PipeRecord by its CID from a specified scope. This endpoint retrieves both the record metadata and its content, if available.",
  "source": "@site/docs/api-reference/fetch.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/fetch",
  "permalink": "/api-reference/fetch",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "GET /configuration",
    "permalink": "/api-reference/configuration"
  },
  "next": {
    "title": "POST /publish",
    "permalink": "/api-reference/publish"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-node-info-md-cc6.json
================
{
  "id": "api-reference/node-info",
  "title": "GET /node-info",
  "description": "Returns detailed information about a specific IPFS node managed by the Pipe protocol. This endpoint provides configuration and identity information for either the private or public node.",
  "source": "@site/docs/api-reference/node-info.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/node-info",
  "permalink": "/api-reference/node-info",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "GET /node-status",
    "permalink": "/api-reference/node-status"
  },
  "next": {
    "title": "GET /storage-metrics",
    "permalink": "/api-reference/storage-metrics"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-node-status-md-213.json
================
{
  "id": "api-reference/node-status",
  "title": "GET /node-status",
  "description": "Returns the status of the IPFS nodes managed by the Pipe protocol. This endpoint provides information about the availability and health of both private and public nodes.",
  "source": "@site/docs/api-reference/node-status.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/node-status",
  "permalink": "/api-reference/node-status",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Publishing Data and Schema",
    "permalink": "/usage-examples/publish-data"
  },
  "next": {
    "title": "GET /node-info",
    "permalink": "/api-reference/node-info"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-pin-md-e40.json
================
{
  "id": "api-reference/pin",
  "title": "POST /pin",
  "description": "Pins a CID in a specified scope, preventing it from being garbage collected. Pinned content remains available until explicitly unpinned.",
  "source": "@site/docs/api-reference/pin.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/pin",
  "permalink": "/api-reference/pin",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "POST /publish-bundle",
    "permalink": "/api-reference/publish-bundle"
  },
  "next": {
    "title": "POST /unpin",
    "permalink": "/api-reference/unpin"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-pinned-cids-md-567.json
================
{
  "id": "api-reference/pinned-cids",
  "title": "GET /pinned-cids",
  "description": "Returns a list of Content Identifiers (CIDs) that are currently pinned in a specified scope. This endpoint provides information about pinned content and their metadata.",
  "source": "@site/docs/api-reference/pinned-cids.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/pinned-cids",
  "permalink": "/api-reference/pinned-cids",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "GET /storage-metrics",
    "permalink": "/api-reference/storage-metrics"
  },
  "next": {
    "title": "GET /configuration",
    "permalink": "/api-reference/configuration"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-publish-bundle-md-98e.json
================
{
  "id": "api-reference/publish-bundle",
  "title": "POST /publish-bundle",
  "description": "Publishes a PipeBundle containing both schema and data records. This endpoint handles the creation and storage of related schema and data content as a single unit.",
  "source": "@site/docs/api-reference/publish-bundle.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/publish-bundle",
  "permalink": "/api-reference/publish-bundle",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "POST /publish",
    "permalink": "/api-reference/publish"
  },
  "next": {
    "title": "POST /pin",
    "permalink": "/api-reference/pin"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-publish-md-c40.json
================
{
  "id": "api-reference/publish",
  "title": "POST /publish",
  "description": "Publishes a single PipeRecord to IPFS. This endpoint handles both inline content and referenced data, with support for encryption and access control.",
  "source": "@site/docs/api-reference/publish.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/publish",
  "permalink": "/api-reference/publish",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "GET /fetch",
    "permalink": "/api-reference/fetch"
  },
  "next": {
    "title": "POST /publish-bundle",
    "permalink": "/api-reference/publish-bundle"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-replicate-md-c5d.json
================
{
  "id": "api-reference/replicate",
  "title": "POST /replicate",
  "description": "Replicates content from one scope to another. This endpoint is primarily used to move content between private and public scopes, enabling controlled sharing of data.",
  "source": "@site/docs/api-reference/replicate.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/replicate",
  "permalink": "/api-reference/replicate",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "POST /unpin",
    "permalink": "/api-reference/unpin"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-storage-metrics-md-37d.json
================
{
  "id": "api-reference/storage-metrics",
  "title": "GET /storage-metrics",
  "description": "Returns storage usage metrics for a specified IPFS node. This endpoint provides detailed information about storage consumption, including repository size, content distribution, and pinned data metrics.",
  "source": "@site/docs/api-reference/storage-metrics.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/storage-metrics",
  "permalink": "/api-reference/storage-metrics",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "GET /node-info",
    "permalink": "/api-reference/node-info"
  },
  "next": {
    "title": "GET /pinned-cids",
    "permalink": "/api-reference/pinned-cids"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-api-reference-unpin-md-df6.json
================
{
  "id": "api-reference/unpin",
  "title": "POST /unpin",
  "description": "Unpins a CID from a specified scope, allowing it to be garbage collected if no other pins exist. This endpoint is used to manage storage by removing pins from content that is no longer needed.",
  "source": "@site/docs/api-reference/unpin.md",
  "sourceDirName": "api-reference",
  "slug": "/api-reference/unpin",
  "permalink": "/api-reference/unpin",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "POST /pin",
    "permalink": "/api-reference/pin"
  },
  "next": {
    "title": "POST /replicate",
    "permalink": "/api-reference/replicate"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-core-concepts-encryption-md-3be.json
================
{
  "id": "core-concepts/encryption",
  "title": "Encryption and Hidden-from-LLM Data",
  "description": "The Pipe protocol provides robust encryption capabilities, allowing data to be securely stored and optionally hidden from LLMs. This document explains the encryption features and how to use them effectively.",
  "source": "@site/docs/core-concepts/encryption.md",
  "sourceDirName": "core-concepts",
  "slug": "/core-concepts/encryption",
  "permalink": "/core-concepts/encryption",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "PipeBundle",
    "permalink": "/core-concepts/pipebundle"
  },
  "next": {
    "title": "Inline vs. Referenced Content",
    "permalink": "/core-concepts/inline-referenced"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-core-concepts-inline-referenced-md-231.json
================
{
  "id": "core-concepts/inline-referenced",
  "title": "Inline vs. Referenced Content",
  "description": "The Pipe protocol supports two methods of storing content: inline and referenced. Each approach has its own advantages and use cases.",
  "source": "@site/docs/core-concepts/inline-referenced.md",
  "sourceDirName": "core-concepts",
  "slug": "/core-concepts/inline-referenced",
  "permalink": "/core-concepts/inline-referenced",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Encryption and Hidden-from-LLM Data",
    "permalink": "/core-concepts/encryption"
  },
  "next": {
    "title": "Fetching Data and Schema",
    "permalink": "/usage-examples/fetch-data"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-core-concepts-pipebundle-md-6a7.json
================
{
  "id": "core-concepts/pipebundle",
  "title": "PipeBundle",
  "description": "A PipeBundle combines a schema and data record, providing a way to package related schema and data together. This is particularly useful when a piece of data has a defined schema that describes its structure.",
  "source": "@site/docs/core-concepts/pipebundle.md",
  "sourceDirName": "core-concepts",
  "slug": "/core-concepts/pipebundle",
  "permalink": "/core-concepts/pipebundle",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "PipeRecord",
    "permalink": "/core-concepts/piperecord"
  },
  "next": {
    "title": "Encryption and Hidden-from-LLM Data",
    "permalink": "/core-concepts/encryption"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-core-concepts-piperecord-md-f4d.json
================
{
  "id": "core-concepts/piperecord",
  "title": "PipeRecord",
  "description": "A PipeRecord is the fundamental data structure in the Pipe protocol. It represents a single piece of content—either data or schema—that can be referenced by a CID or optionally stored inline.",
  "source": "@site/docs/core-concepts/piperecord.md",
  "sourceDirName": "core-concepts",
  "slug": "/core-concepts/piperecord",
  "permalink": "/core-concepts/piperecord",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Scopes",
    "permalink": "/core-concepts/scopes"
  },
  "next": {
    "title": "PipeBundle",
    "permalink": "/core-concepts/pipebundle"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-core-concepts-scopes-md-417.json
================
{
  "id": "core-concepts/scopes",
  "title": "Scopes",
  "description": "In the Pipe protocol, scopes determine how and where data is stored and accessed. Each scope has specific characteristics and use cases.",
  "source": "@site/docs/core-concepts/scopes.md",
  "sourceDirName": "core-concepts",
  "slug": "/core-concepts/scopes",
  "permalink": "/core-concepts/scopes",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Terminology",
    "permalink": "/core-concepts/terminology"
  },
  "next": {
    "title": "PipeRecord",
    "permalink": "/core-concepts/piperecord"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-core-concepts-terminology-md-7d7.json
================
{
  "id": "core-concepts/terminology",
  "title": "Terminology",
  "description": "This section defines key terms used throughout the Pipe protocol documentation.",
  "source": "@site/docs/core-concepts/terminology.md",
  "sourceDirName": "core-concepts",
  "slug": "/core-concepts/terminology",
  "permalink": "/core-concepts/terminology",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "How Pipe Solves the Problem",
    "permalink": "/introduction/solution"
  },
  "next": {
    "title": "Scopes",
    "permalink": "/core-concepts/scopes"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-intro-md-0e3.json
================
{
  "id": "intro",
  "title": "Tutorial Intro",
  "description": "Let's discover Docusaurus in less than 5 minutes.",
  "source": "@site/docs/intro.md",
  "sourceDirName": ".",
  "slug": "/intro",
  "permalink": "/intro",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 1,
  "frontMatter": {
    "sidebar_position": 1
  },
  "sidebar": "docs",
  "next": {
    "title": "Pipe Protocol Overview",
    "permalink": "/introduction/overview"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-introduction-overview-md-761.json
================
{
  "id": "introduction/overview",
  "title": "Pipe Protocol Overview",
  "description": "Pipe is a protocol designed for efficient data handling in multi-agent Large Language Model (LLM) systems. It allows agents to share and reference large or structured data through IPFS (InterPlanetary File System), minimizing context overload and improving scalability.",
  "source": "@site/docs/introduction/overview.md",
  "sourceDirName": "introduction",
  "slug": "/introduction/overview",
  "permalink": "/introduction/overview",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Tutorial Intro",
    "permalink": "/intro"
  },
  "next": {
    "title": "The Problem Pipe Solves",
    "permalink": "/introduction/problem"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-introduction-problem-md-20e.json
================
{
  "id": "introduction/problem",
  "title": "The Problem Pipe Solves",
  "description": "In multi-agent LLM systems, agents often exchange state by directly passing large data inline. This approach leads to several critical issues:",
  "source": "@site/docs/introduction/problem.md",
  "sourceDirName": "introduction",
  "slug": "/introduction/problem",
  "permalink": "/introduction/problem",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Pipe Protocol Overview",
    "permalink": "/introduction/overview"
  },
  "next": {
    "title": "How Pipe Solves the Problem",
    "permalink": "/introduction/solution"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-introduction-solution-md-167.json
================
{
  "id": "introduction/solution",
  "title": "How Pipe Solves the Problem",
  "description": "Pipe provides a comprehensive solution to the challenges of data handling in multi-agent LLM systems through several key mechanisms:",
  "source": "@site/docs/introduction/solution.md",
  "sourceDirName": "introduction",
  "slug": "/introduction/solution",
  "permalink": "/introduction/solution",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "The Problem Pipe Solves",
    "permalink": "/introduction/problem"
  },
  "next": {
    "title": "Terminology",
    "permalink": "/core-concepts/terminology"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-tutorial-basics-congratulations-md-822.json
================
{
  "id": "tutorial-basics/congratulations",
  "title": "Congratulations!",
  "description": "You have just learned the basics of Docusaurus and made some changes to the initial template.",
  "source": "@site/docs/tutorial-basics/congratulations.md",
  "sourceDirName": "tutorial-basics",
  "slug": "/tutorial-basics/congratulations",
  "permalink": "/tutorial-basics/congratulations",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 6,
  "frontMatter": {
    "sidebar_position": 6
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-tutorial-basics-create-a-blog-post-md-533.json
================
{
  "id": "tutorial-basics/create-a-blog-post",
  "title": "Create a Blog Post",
  "description": "Docusaurus creates a page for each blog post, but also a blog index page, a tag system, an RSS feed...",
  "source": "@site/docs/tutorial-basics/create-a-blog-post.md",
  "sourceDirName": "tutorial-basics",
  "slug": "/tutorial-basics/create-a-blog-post",
  "permalink": "/tutorial-basics/create-a-blog-post",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 3,
  "frontMatter": {
    "sidebar_position": 3
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-tutorial-basics-create-a-document-md-1e4.json
================
{
  "id": "tutorial-basics/create-a-document",
  "title": "Create a Document",
  "description": "Documents are groups of pages connected through:",
  "source": "@site/docs/tutorial-basics/create-a-document.md",
  "sourceDirName": "tutorial-basics",
  "slug": "/tutorial-basics/create-a-document",
  "permalink": "/tutorial-basics/create-a-document",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 2,
  "frontMatter": {
    "sidebar_position": 2
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-tutorial-basics-create-a-page-md-5c8.json
================
{
  "id": "tutorial-basics/create-a-page",
  "title": "Create a Page",
  "description": "Add Markdown or React files to src/pages to create a standalone page:",
  "source": "@site/docs/tutorial-basics/create-a-page.md",
  "sourceDirName": "tutorial-basics",
  "slug": "/tutorial-basics/create-a-page",
  "permalink": "/tutorial-basics/create-a-page",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 1,
  "frontMatter": {
    "sidebar_position": 1
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-tutorial-basics-deploy-your-site-md-f55.json
================
{
  "id": "tutorial-basics/deploy-your-site",
  "title": "Deploy your site",
  "description": "Docusaurus is a static-site-generator (also called Jamstack).",
  "source": "@site/docs/tutorial-basics/deploy-your-site.md",
  "sourceDirName": "tutorial-basics",
  "slug": "/tutorial-basics/deploy-your-site",
  "permalink": "/tutorial-basics/deploy-your-site",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 5,
  "frontMatter": {
    "sidebar_position": 5
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-tutorial-basics-markdown-features-mdx-18c.json
================
{
  "id": "tutorial-basics/markdown-features",
  "title": "Markdown Features",
  "description": "Docusaurus supports Markdown and a few additional features.",
  "source": "@site/docs/tutorial-basics/markdown-features.mdx",
  "sourceDirName": "tutorial-basics",
  "slug": "/tutorial-basics/markdown-features",
  "permalink": "/tutorial-basics/markdown-features",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 4,
  "frontMatter": {
    "sidebar_position": 4
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-tutorial-extras-manage-docs-versions-md-dff.json
================
{
  "id": "tutorial-extras/manage-docs-versions",
  "title": "Manage Docs Versions",
  "description": "Docusaurus can manage multiple versions of your docs.",
  "source": "@site/docs/tutorial-extras/manage-docs-versions.md",
  "sourceDirName": "tutorial-extras",
  "slug": "/tutorial-extras/manage-docs-versions",
  "permalink": "/tutorial-extras/manage-docs-versions",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 1,
  "frontMatter": {
    "sidebar_position": 1
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-tutorial-extras-translate-your-site-md-e44.json
================
{
  "id": "tutorial-extras/translate-your-site",
  "title": "Translate your site",
  "description": "Let's translate docs/intro.md to French.",
  "source": "@site/docs/tutorial-extras/translate-your-site.md",
  "sourceDirName": "tutorial-extras",
  "slug": "/tutorial-extras/translate-your-site",
  "permalink": "/tutorial-extras/translate-your-site",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "sidebarPosition": 2,
  "frontMatter": {
    "sidebar_position": 2
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-usage-examples-fetch-data-md-513.json
================
{
  "id": "usage-examples/fetch-data",
  "title": "Fetching Data and Schema",
  "description": "This guide demonstrates how to fetch data and schema records using the Pipe protocol. We'll cover various scenarios including inline content, referenced content, and encrypted data.",
  "source": "@site/docs/usage-examples/fetch-data.md",
  "sourceDirName": "usage-examples",
  "slug": "/usage-examples/fetch-data",
  "permalink": "/usage-examples/fetch-data",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Inline vs. Referenced Content",
    "permalink": "/core-concepts/inline-referenced"
  },
  "next": {
    "title": "Working with Bundles",
    "permalink": "/usage-examples/work-bundles"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-usage-examples-pin-unpin-md-8de.json
================
{
  "id": "usage-examples/pin-unpin",
  "title": "Managing Pinned Content",
  "description": "This guide demonstrates how to manage pinned content in the Pipe protocol. We'll cover pinning, unpinning, and various strategies for content retention.",
  "source": "@site/docs/usage-examples/pin-unpin.md",
  "sourceDirName": "usage-examples",
  "slug": "/usage-examples/pin-unpin",
  "permalink": "/usage-examples/pin-unpin",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Publishing Hidden Data",
    "permalink": "/usage-examples/publish-hidden-data"
  },
  "next": {
    "title": "Replicating Data",
    "permalink": "/usage-examples/replicate-data"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-usage-examples-publish-data-md-b8d.json
================
{
  "id": "usage-examples/publish-data",
  "title": "Publishing Data and Schema",
  "description": "This guide demonstrates how to publish data and schema records using the Pipe protocol.",
  "source": "@site/docs/usage-examples/publish-data.md",
  "sourceDirName": "usage-examples",
  "slug": "/usage-examples/publish-data",
  "permalink": "/usage-examples/publish-data",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Replicating Data",
    "permalink": "/usage-examples/replicate-data"
  },
  "next": {
    "title": "GET /node-status",
    "permalink": "/api-reference/node-status"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-usage-examples-publish-hidden-data-md-7d3.json
================
{
  "id": "usage-examples/publish-hidden-data",
  "title": "Publishing Hidden Data",
  "description": "This guide demonstrates how to publish data that should be hidden from Large Language Models (LLMs) using the Pipe protocol. We'll cover various scenarios including encryption, access policies, and tool-specific access.",
  "source": "@site/docs/usage-examples/publish-hidden-data.md",
  "sourceDirName": "usage-examples",
  "slug": "/usage-examples/publish-hidden-data",
  "permalink": "/usage-examples/publish-hidden-data",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Working with Bundles",
    "permalink": "/usage-examples/work-bundles"
  },
  "next": {
    "title": "Managing Pinned Content",
    "permalink": "/usage-examples/pin-unpin"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-usage-examples-replicate-data-md-d94.json
================
{
  "id": "usage-examples/replicate-data",
  "title": "Replicating Data",
  "description": "This guide demonstrates how to replicate data between different scopes in the Pipe protocol. We'll cover various replication scenarios and best practices for data distribution.",
  "source": "@site/docs/usage-examples/replicate-data.md",
  "sourceDirName": "usage-examples",
  "slug": "/usage-examples/replicate-data",
  "permalink": "/usage-examples/replicate-data",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Managing Pinned Content",
    "permalink": "/usage-examples/pin-unpin"
  },
  "next": {
    "title": "Publishing Data and Schema",
    "permalink": "/usage-examples/publish-data"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-usage-examples-work-bundles-md-16e.json
================
{
  "id": "usage-examples/work-bundles",
  "title": "Working with Bundles",
  "description": "This guide demonstrates how to work with PipeBundle objects in the Pipe protocol. We'll cover creating, publishing, and fetching bundles that combine schema and data records.",
  "source": "@site/docs/usage-examples/work-bundles.md",
  "sourceDirName": "usage-examples",
  "slug": "/usage-examples/work-bundles",
  "permalink": "/usage-examples/work-bundles",
  "draft": false,
  "unlisted": false,
  "tags": [],
  "version": "current",
  "lastUpdatedAt": 1539502055000,
  "frontMatter": {},
  "sidebar": "docs",
  "previous": {
    "title": "Fetching Data and Schema",
    "permalink": "/usage-examples/fetch-data"
  },
  "next": {
    "title": "Publishing Hidden Data",
    "permalink": "/usage-examples/publish-hidden-data"
  }
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-pages/default/__plugin.json
================
{
  "name": "docusaurus-plugin-content-pages",
  "id": "default"
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-content-pages/default/site-src-pages-markdown-page-md-393.json
================
{
  "type": "mdx",
  "permalink": "/markdown-page",
  "source": "@site/src/pages/markdown-page.md",
  "title": "Markdown page example",
  "description": "You don't need React to write simple standalone pages.",
  "frontMatter": {
    "title": "Markdown page example"
  },
  "unlisted": false
}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-debug/default/p/docusaurus-debug-content-0d5.json
================
{"allContent":{"docusaurus-plugin-content-docs":{"default":{"loadedVersions":[{"versionName":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","path":"/","tagsPath":"/tags","isLast":true,"routePriority":-1,"sidebarFilePath":"/Users/dennisonbertram/Develop/pipe/pipe-docs/website/sidebars.ts","contentPath":"/Users/dennisonbertram/Develop/pipe/pipe-docs/website/docs","contentPathLocalized":"/Users/dennisonbertram/Develop/pipe/pipe-docs/website/i18n/en/docusaurus-plugin-content-docs/current","docs":[{"id":"api-reference/configuration","title":"GET /configuration","description":"Returns the current configuration of a specified IPFS node. This endpoint provides detailed information about node settings, network configuration, and runtime parameters.","source":"@site/docs/api-reference/configuration.md","sourceDirName":"api-reference","slug":"/api-reference/configuration","permalink":"/api-reference/configuration","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"GET /pinned-cids","permalink":"/api-reference/pinned-cids"},"next":{"title":"GET /fetch","permalink":"/api-reference/fetch"}},{"id":"api-reference/fetch","title":"GET /fetch","description":"Fetches a PipeRecord by its CID from a specified scope. This endpoint retrieves both the record metadata and its content, if available.","source":"@site/docs/api-reference/fetch.md","sourceDirName":"api-reference","slug":"/api-reference/fetch","permalink":"/api-reference/fetch","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"GET /configuration","permalink":"/api-reference/configuration"},"next":{"title":"POST /publish","permalink":"/api-reference/publish"}},{"id":"api-reference/node-info","title":"GET /node-info","description":"Returns detailed information about a specific IPFS node managed by the Pipe protocol. This endpoint provides configuration and identity information for either the private or public node.","source":"@site/docs/api-reference/node-info.md","sourceDirName":"api-reference","slug":"/api-reference/node-info","permalink":"/api-reference/node-info","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"GET /node-status","permalink":"/api-reference/node-status"},"next":{"title":"GET /storage-metrics","permalink":"/api-reference/storage-metrics"}},{"id":"api-reference/node-status","title":"GET /node-status","description":"Returns the status of the IPFS nodes managed by the Pipe protocol. This endpoint provides information about the availability and health of both private and public nodes.","source":"@site/docs/api-reference/node-status.md","sourceDirName":"api-reference","slug":"/api-reference/node-status","permalink":"/api-reference/node-status","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Publishing Data and Schema","permalink":"/usage-examples/publish-data"},"next":{"title":"GET /node-info","permalink":"/api-reference/node-info"}},{"id":"api-reference/pin","title":"POST /pin","description":"Pins a CID in a specified scope, preventing it from being garbage collected. Pinned content remains available until explicitly unpinned.","source":"@site/docs/api-reference/pin.md","sourceDirName":"api-reference","slug":"/api-reference/pin","permalink":"/api-reference/pin","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"POST /publish-bundle","permalink":"/api-reference/publish-bundle"},"next":{"title":"POST /unpin","permalink":"/api-reference/unpin"}},{"id":"api-reference/pinned-cids","title":"GET /pinned-cids","description":"Returns a list of Content Identifiers (CIDs) that are currently pinned in a specified scope. This endpoint provides information about pinned content and their metadata.","source":"@site/docs/api-reference/pinned-cids.md","sourceDirName":"api-reference","slug":"/api-reference/pinned-cids","permalink":"/api-reference/pinned-cids","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"GET /storage-metrics","permalink":"/api-reference/storage-metrics"},"next":{"title":"GET /configuration","permalink":"/api-reference/configuration"}},{"id":"api-reference/publish","title":"POST /publish","description":"Publishes a single PipeRecord to IPFS. This endpoint handles both inline content and referenced data, with support for encryption and access control.","source":"@site/docs/api-reference/publish.md","sourceDirName":"api-reference","slug":"/api-reference/publish","permalink":"/api-reference/publish","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"GET /fetch","permalink":"/api-reference/fetch"},"next":{"title":"POST /publish-bundle","permalink":"/api-reference/publish-bundle"}},{"id":"api-reference/publish-bundle","title":"POST /publish-bundle","description":"Publishes a PipeBundle containing both schema and data records. This endpoint handles the creation and storage of related schema and data content as a single unit.","source":"@site/docs/api-reference/publish-bundle.md","sourceDirName":"api-reference","slug":"/api-reference/publish-bundle","permalink":"/api-reference/publish-bundle","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"POST /publish","permalink":"/api-reference/publish"},"next":{"title":"POST /pin","permalink":"/api-reference/pin"}},{"id":"api-reference/replicate","title":"POST /replicate","description":"Replicates content from one scope to another. This endpoint is primarily used to move content between private and public scopes, enabling controlled sharing of data.","source":"@site/docs/api-reference/replicate.md","sourceDirName":"api-reference","slug":"/api-reference/replicate","permalink":"/api-reference/replicate","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"POST /unpin","permalink":"/api-reference/unpin"}},{"id":"api-reference/storage-metrics","title":"GET /storage-metrics","description":"Returns storage usage metrics for a specified IPFS node. This endpoint provides detailed information about storage consumption, including repository size, content distribution, and pinned data metrics.","source":"@site/docs/api-reference/storage-metrics.md","sourceDirName":"api-reference","slug":"/api-reference/storage-metrics","permalink":"/api-reference/storage-metrics","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"GET /node-info","permalink":"/api-reference/node-info"},"next":{"title":"GET /pinned-cids","permalink":"/api-reference/pinned-cids"}},{"id":"api-reference/unpin","title":"POST /unpin","description":"Unpins a CID from a specified scope, allowing it to be garbage collected if no other pins exist. This endpoint is used to manage storage by removing pins from content that is no longer needed.","source":"@site/docs/api-reference/unpin.md","sourceDirName":"api-reference","slug":"/api-reference/unpin","permalink":"/api-reference/unpin","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"POST /pin","permalink":"/api-reference/pin"},"next":{"title":"POST /replicate","permalink":"/api-reference/replicate"}},{"id":"core-concepts/encryption","title":"Encryption and Hidden-from-LLM Data","description":"The Pipe protocol provides robust encryption capabilities, allowing data to be securely stored and optionally hidden from LLMs. This document explains the encryption features and how to use them effectively.","source":"@site/docs/core-concepts/encryption.md","sourceDirName":"core-concepts","slug":"/core-concepts/encryption","permalink":"/core-concepts/encryption","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"PipeBundle","permalink":"/core-concepts/pipebundle"},"next":{"title":"Inline vs. Referenced Content","permalink":"/core-concepts/inline-referenced"}},{"id":"core-concepts/inline-referenced","title":"Inline vs. Referenced Content","description":"The Pipe protocol supports two methods of storing content: inline and referenced. Each approach has its own advantages and use cases.","source":"@site/docs/core-concepts/inline-referenced.md","sourceDirName":"core-concepts","slug":"/core-concepts/inline-referenced","permalink":"/core-concepts/inline-referenced","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Encryption and Hidden-from-LLM Data","permalink":"/core-concepts/encryption"},"next":{"title":"Fetching Data and Schema","permalink":"/usage-examples/fetch-data"}},{"id":"core-concepts/pipebundle","title":"PipeBundle","description":"A PipeBundle combines a schema and data record, providing a way to package related schema and data together. This is particularly useful when a piece of data has a defined schema that describes its structure.","source":"@site/docs/core-concepts/pipebundle.md","sourceDirName":"core-concepts","slug":"/core-concepts/pipebundle","permalink":"/core-concepts/pipebundle","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"PipeRecord","permalink":"/core-concepts/piperecord"},"next":{"title":"Encryption and Hidden-from-LLM Data","permalink":"/core-concepts/encryption"}},{"id":"core-concepts/piperecord","title":"PipeRecord","description":"A PipeRecord is the fundamental data structure in the Pipe protocol. It represents a single piece of content—either data or schema—that can be referenced by a CID or optionally stored inline.","source":"@site/docs/core-concepts/piperecord.md","sourceDirName":"core-concepts","slug":"/core-concepts/piperecord","permalink":"/core-concepts/piperecord","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Scopes","permalink":"/core-concepts/scopes"},"next":{"title":"PipeBundle","permalink":"/core-concepts/pipebundle"}},{"id":"core-concepts/scopes","title":"Scopes","description":"In the Pipe protocol, scopes determine how and where data is stored and accessed. Each scope has specific characteristics and use cases.","source":"@site/docs/core-concepts/scopes.md","sourceDirName":"core-concepts","slug":"/core-concepts/scopes","permalink":"/core-concepts/scopes","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Terminology","permalink":"/core-concepts/terminology"},"next":{"title":"PipeRecord","permalink":"/core-concepts/piperecord"}},{"id":"core-concepts/terminology","title":"Terminology","description":"This section defines key terms used throughout the Pipe protocol documentation.","source":"@site/docs/core-concepts/terminology.md","sourceDirName":"core-concepts","slug":"/core-concepts/terminology","permalink":"/core-concepts/terminology","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"How Pipe Solves the Problem","permalink":"/introduction/solution"},"next":{"title":"Scopes","permalink":"/core-concepts/scopes"}},{"id":"intro","title":"Tutorial Intro","description":"Let's discover Docusaurus in less than 5 minutes.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/intro","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docs","next":{"title":"Pipe Protocol Overview","permalink":"/introduction/overview"}},{"id":"introduction/overview","title":"Pipe Protocol Overview","description":"Pipe is a protocol designed for efficient data handling in multi-agent Large Language Model (LLM) systems. It allows agents to share and reference large or structured data through IPFS (InterPlanetary File System), minimizing context overload and improving scalability.","source":"@site/docs/introduction/overview.md","sourceDirName":"introduction","slug":"/introduction/overview","permalink":"/introduction/overview","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Tutorial Intro","permalink":"/intro"},"next":{"title":"The Problem Pipe Solves","permalink":"/introduction/problem"}},{"id":"introduction/problem","title":"The Problem Pipe Solves","description":"In multi-agent LLM systems, agents often exchange state by directly passing large data inline. This approach leads to several critical issues:","source":"@site/docs/introduction/problem.md","sourceDirName":"introduction","slug":"/introduction/problem","permalink":"/introduction/problem","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Pipe Protocol Overview","permalink":"/introduction/overview"},"next":{"title":"How Pipe Solves the Problem","permalink":"/introduction/solution"}},{"id":"introduction/solution","title":"How Pipe Solves the Problem","description":"Pipe provides a comprehensive solution to the challenges of data handling in multi-agent LLM systems through several key mechanisms:","source":"@site/docs/introduction/solution.md","sourceDirName":"introduction","slug":"/introduction/solution","permalink":"/introduction/solution","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"The Problem Pipe Solves","permalink":"/introduction/problem"},"next":{"title":"Terminology","permalink":"/core-concepts/terminology"}},{"id":"tutorial-basics/congratulations","title":"Congratulations!","description":"You have just learned the basics of Docusaurus and made some changes to the initial template.","source":"@site/docs/tutorial-basics/congratulations.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/congratulations","permalink":"/tutorial-basics/congratulations","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6}},{"id":"tutorial-basics/create-a-blog-post","title":"Create a Blog Post","description":"Docusaurus creates a page for each blog post, but also a blog index page, a tag system, an RSS feed...","source":"@site/docs/tutorial-basics/create-a-blog-post.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/create-a-blog-post","permalink":"/tutorial-basics/create-a-blog-post","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3}},{"id":"tutorial-basics/create-a-document","title":"Create a Document","description":"Documents are groups of pages connected through:","source":"@site/docs/tutorial-basics/create-a-document.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/create-a-document","permalink":"/tutorial-basics/create-a-document","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2}},{"id":"tutorial-basics/create-a-page","title":"Create a Page","description":"Add Markdown or React files to src/pages to create a standalone page:","source":"@site/docs/tutorial-basics/create-a-page.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/create-a-page","permalink":"/tutorial-basics/create-a-page","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1}},{"id":"tutorial-basics/deploy-your-site","title":"Deploy your site","description":"Docusaurus is a static-site-generator (also called Jamstack).","source":"@site/docs/tutorial-basics/deploy-your-site.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/deploy-your-site","permalink":"/tutorial-basics/deploy-your-site","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5}},{"id":"tutorial-basics/markdown-features","title":"Markdown Features","description":"Docusaurus supports Markdown and a few additional features.","source":"@site/docs/tutorial-basics/markdown-features.mdx","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/markdown-features","permalink":"/tutorial-basics/markdown-features","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4}},{"id":"tutorial-extras/manage-docs-versions","title":"Manage Docs Versions","description":"Docusaurus can manage multiple versions of your docs.","source":"@site/docs/tutorial-extras/manage-docs-versions.md","sourceDirName":"tutorial-extras","slug":"/tutorial-extras/manage-docs-versions","permalink":"/tutorial-extras/manage-docs-versions","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1}},{"id":"tutorial-extras/translate-your-site","title":"Translate your site","description":"Let's translate docs/intro.md to French.","source":"@site/docs/tutorial-extras/translate-your-site.md","sourceDirName":"tutorial-extras","slug":"/tutorial-extras/translate-your-site","permalink":"/tutorial-extras/translate-your-site","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2}},{"id":"usage-examples/fetch-data","title":"Fetching Data and Schema","description":"This guide demonstrates how to fetch data and schema records using the Pipe protocol. We'll cover various scenarios including inline content, referenced content, and encrypted data.","source":"@site/docs/usage-examples/fetch-data.md","sourceDirName":"usage-examples","slug":"/usage-examples/fetch-data","permalink":"/usage-examples/fetch-data","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Inline vs. Referenced Content","permalink":"/core-concepts/inline-referenced"},"next":{"title":"Working with Bundles","permalink":"/usage-examples/work-bundles"}},{"id":"usage-examples/pin-unpin","title":"Managing Pinned Content","description":"This guide demonstrates how to manage pinned content in the Pipe protocol. We'll cover pinning, unpinning, and various strategies for content retention.","source":"@site/docs/usage-examples/pin-unpin.md","sourceDirName":"usage-examples","slug":"/usage-examples/pin-unpin","permalink":"/usage-examples/pin-unpin","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Publishing Hidden Data","permalink":"/usage-examples/publish-hidden-data"},"next":{"title":"Replicating Data","permalink":"/usage-examples/replicate-data"}},{"id":"usage-examples/publish-data","title":"Publishing Data and Schema","description":"This guide demonstrates how to publish data and schema records using the Pipe protocol.","source":"@site/docs/usage-examples/publish-data.md","sourceDirName":"usage-examples","slug":"/usage-examples/publish-data","permalink":"/usage-examples/publish-data","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Replicating Data","permalink":"/usage-examples/replicate-data"},"next":{"title":"GET /node-status","permalink":"/api-reference/node-status"}},{"id":"usage-examples/publish-hidden-data","title":"Publishing Hidden Data","description":"This guide demonstrates how to publish data that should be hidden from Large Language Models (LLMs) using the Pipe protocol. We'll cover various scenarios including encryption, access policies, and tool-specific access.","source":"@site/docs/usage-examples/publish-hidden-data.md","sourceDirName":"usage-examples","slug":"/usage-examples/publish-hidden-data","permalink":"/usage-examples/publish-hidden-data","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Working with Bundles","permalink":"/usage-examples/work-bundles"},"next":{"title":"Managing Pinned Content","permalink":"/usage-examples/pin-unpin"}},{"id":"usage-examples/replicate-data","title":"Replicating Data","description":"This guide demonstrates how to replicate data between different scopes in the Pipe protocol. We'll cover various replication scenarios and best practices for data distribution.","source":"@site/docs/usage-examples/replicate-data.md","sourceDirName":"usage-examples","slug":"/usage-examples/replicate-data","permalink":"/usage-examples/replicate-data","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Managing Pinned Content","permalink":"/usage-examples/pin-unpin"},"next":{"title":"Publishing Data and Schema","permalink":"/usage-examples/publish-data"}},{"id":"usage-examples/work-bundles","title":"Working with Bundles","description":"This guide demonstrates how to work with PipeBundle objects in the Pipe protocol. We'll cover creating, publishing, and fetching bundles that combine schema and data records.","source":"@site/docs/usage-examples/work-bundles.md","sourceDirName":"usage-examples","slug":"/usage-examples/work-bundles","permalink":"/usage-examples/work-bundles","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1539502055000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Fetching Data and Schema","permalink":"/usage-examples/fetch-data"},"next":{"title":"Publishing Hidden Data","permalink":"/usage-examples/publish-hidden-data"}}],"drafts":[],"sidebars":{"docs":[{"type":"category","label":"Introduction","items":[{"type":"doc","id":"intro"},{"type":"doc","id":"introduction/overview"},{"type":"doc","id":"introduction/problem"},{"type":"doc","id":"introduction/solution"}],"collapsed":false,"collapsible":true},{"type":"category","label":"Core Concepts","items":[{"type":"doc","id":"core-concepts/terminology"},{"type":"doc","id":"core-concepts/scopes"},{"type":"doc","id":"core-concepts/piperecord"},{"type":"doc","id":"core-concepts/pipebundle"},{"type":"doc","id":"core-concepts/encryption"},{"type":"doc","id":"core-concepts/inline-referenced"}],"collapsed":false,"collapsible":true},{"type":"category","label":"Usage Examples","items":[{"type":"doc","id":"usage-examples/fetch-data"},{"type":"doc","id":"usage-examples/work-bundles"},{"type":"doc","id":"usage-examples/publish-hidden-data"},{"type":"doc","id":"usage-examples/pin-unpin"},{"type":"doc","id":"usage-examples/replicate-data"},{"type":"doc","id":"usage-examples/publish-data"}],"collapsed":false,"collapsible":true},{"type":"category","label":"API Reference","items":[{"type":"doc","id":"api-reference/node-status"},{"type":"doc","id":"api-reference/node-info"},{"type":"doc","id":"api-reference/storage-metrics"},{"type":"doc","id":"api-reference/pinned-cids"},{"type":"doc","id":"api-reference/configuration"},{"type":"doc","id":"api-reference/fetch"},{"type":"doc","id":"api-reference/publish"},{"type":"doc","id":"api-reference/publish-bundle"},{"type":"doc","id":"api-reference/pin"},{"type":"doc","id":"api-reference/unpin"},{"type":"doc","id":"api-reference/replicate"}],"collapsed":false,"collapsible":true}]}}]}},"docusaurus-plugin-content-pages":{"default":[{"type":"jsx","permalink":"/","source":"@site/src/pages/index.tsx"},{"type":"mdx","permalink":"/markdown-page","source":"@site/src/pages/markdown-page.md","title":"Markdown page example","description":"You don't need React to write simple standalone pages.","frontMatter":{"title":"Markdown page example"},"unlisted":false}]},"docusaurus-plugin-debug":{},"docusaurus-plugin-svgr":{},"docusaurus-theme-classic":{},"docusaurus-bootstrap-plugin":{},"docusaurus-mdx-fallback-plugin":{}}}

================
File: pipe-docs/website/.docusaurus/docusaurus-plugin-debug/default/__plugin.json
================
{
  "name": "docusaurus-plugin-debug",
  "id": "default"
}

================
File: pipe-docs/website/.docusaurus/client-modules.js
================
export default [
  require("/Users/dennisonbertram/Develop/pipe/pipe-docs/website/node_modules/infima/dist/css/default/default.css"),
  require("/Users/dennisonbertram/Develop/pipe/pipe-docs/website/node_modules/@docusaurus/theme-classic/lib/prism-include-languages"),
  require("/Users/dennisonbertram/Develop/pipe/pipe-docs/website/node_modules/@docusaurus/theme-classic/lib/nprogress"),
  require("/Users/dennisonbertram/Develop/pipe/pipe-docs/website/src/css/custom.css"),
];

================
File: pipe-docs/website/.docusaurus/codeTranslations.json
================
{}

================
File: pipe-docs/website/.docusaurus/docusaurus.config.mjs
================
/*
 * AUTOGENERATED - DON'T EDIT
 * Your edits in this file will be overwritten in the next build!
 * Modify the docusaurus.config.js file at your site's root instead.
 */
export default {
  "title": "Pipe Protocol",
  "tagline": "A protocol for secure, decentralized data management",
  "favicon": "img/favicon.ico",
  "url": "https://pipe-protocol.io",
  "baseUrl": "/",
  "organizationName": "pipe",
  "projectName": "pipe",
  "onBrokenLinks": "throw",
  "onBrokenMarkdownLinks": "warn",
  "i18n": {
    "defaultLocale": "en",
    "locales": [
      "en"
    ],
    "path": "i18n",
    "localeConfigs": {}
  },
  "presets": [
    [
      "classic",
      {
        "docs": {
          "sidebarPath": "./sidebars.ts",
          "routeBasePath": "/",
          "breadcrumbs": true,
          "showLastUpdateTime": true,
          "sidebarCollapsed": false,
          "sidebarCollapsible": true
        },
        "blog": false,
        "theme": {
          "customCss": "./src/css/custom.css"
        }
      }
    ]
  ],
  "themeConfig": {
    "colorMode": {
      "defaultMode": "light",
      "disableSwitch": false,
      "respectPrefersColorScheme": true
    },
    "docs": {
      "sidebar": {
        "hideable": true,
        "autoCollapseCategories": false
      },
      "versionPersistence": "localStorage"
    },
    "navbar": {
      "hideOnScroll": true,
      "style": "primary",
      "title": "Pipe Protocol",
      "logo": {
        "alt": "Pipe Protocol Logo",
        "src": "img/logo.svg",
        "srcDark": "img/logo_dark.svg"
      },
      "items": [
        {
          "type": "docSidebar",
          "sidebarId": "docs",
          "position": "left",
          "label": "Documentation"
        },
        {
          "href": "https://github.com/pipe/pipe",
          "position": "right",
          "className": "header-github-link",
          "aria-label": "GitHub repository"
        }
      ]
    },
    "footer": {
      "style": "light",
      "links": [
        {
          "title": "Documentation",
          "items": [
            {
              "label": "Introduction",
              "to": "/intro"
            },
            {
              "label": "Core Concepts",
              "to": "/core-concepts/terminology"
            },
            {
              "label": "Usage Examples",
              "to": "/usage-examples/publish-data"
            }
          ]
        },
        {
          "title": "Community",
          "items": [
            {
              "label": "GitHub",
              "href": "https://github.com/pipe/pipe"
            }
          ]
        }
      ],
      "copyright": "Copyright © 2025 Pipe Protocol. Built with Docusaurus."
    },
    "prism": {
      "theme": {
        "plain": {
          "color": "#393A34",
          "backgroundColor": "#f6f8fa"
        },
        "styles": [
          {
            "types": [
              "comment",
              "prolog",
              "doctype",
              "cdata"
            ],
            "style": {
              "color": "#999988",
              "fontStyle": "italic"
            }
          },
          {
            "types": [
              "namespace"
            ],
            "style": {
              "opacity": 0.7
            }
          },
          {
            "types": [
              "string",
              "attr-value"
            ],
            "style": {
              "color": "#e3116c"
            }
          },
          {
            "types": [
              "punctuation",
              "operator"
            ],
            "style": {
              "color": "#393A34"
            }
          },
          {
            "types": [
              "entity",
              "url",
              "symbol",
              "number",
              "boolean",
              "variable",
              "constant",
              "property",
              "regex",
              "inserted"
            ],
            "style": {
              "color": "#36acaa"
            }
          },
          {
            "types": [
              "atrule",
              "keyword",
              "attr-name",
              "selector"
            ],
            "style": {
              "color": "#00a4db"
            }
          },
          {
            "types": [
              "function",
              "deleted",
              "tag"
            ],
            "style": {
              "color": "#d73a49"
            }
          },
          {
            "types": [
              "function-variable"
            ],
            "style": {
              "color": "#6f42c1"
            }
          },
          {
            "types": [
              "tag",
              "selector",
              "keyword"
            ],
            "style": {
              "color": "#00009f"
            }
          }
        ]
      },
      "darkTheme": {
        "plain": {
          "color": "#F8F8F2",
          "backgroundColor": "#282A36"
        },
        "styles": [
          {
            "types": [
              "prolog",
              "constant",
              "builtin"
            ],
            "style": {
              "color": "rgb(189, 147, 249)"
            }
          },
          {
            "types": [
              "inserted",
              "function"
            ],
            "style": {
              "color": "rgb(80, 250, 123)"
            }
          },
          {
            "types": [
              "deleted"
            ],
            "style": {
              "color": "rgb(255, 85, 85)"
            }
          },
          {
            "types": [
              "changed"
            ],
            "style": {
              "color": "rgb(255, 184, 108)"
            }
          },
          {
            "types": [
              "punctuation",
              "symbol"
            ],
            "style": {
              "color": "rgb(248, 248, 242)"
            }
          },
          {
            "types": [
              "string",
              "char",
              "tag",
              "selector"
            ],
            "style": {
              "color": "rgb(255, 121, 198)"
            }
          },
          {
            "types": [
              "keyword",
              "variable"
            ],
            "style": {
              "color": "rgb(189, 147, 249)",
              "fontStyle": "italic"
            }
          },
          {
            "types": [
              "comment"
            ],
            "style": {
              "color": "rgb(98, 114, 164)"
            }
          },
          {
            "types": [
              "attr-name"
            ],
            "style": {
              "color": "rgb(241, 250, 140)"
            }
          }
        ]
      },
      "additionalLanguages": [
        "bash",
        "diff",
        "json",
        "yaml"
      ],
      "magicComments": [
        {
          "className": "theme-code-block-highlighted-line",
          "line": "highlight-next-line",
          "block": {
            "start": "highlight-start",
            "end": "highlight-end"
          }
        }
      ]
    },
    "tableOfContents": {
      "minHeadingLevel": 2,
      "maxHeadingLevel": 4
    },
    "blog": {
      "sidebar": {
        "groupByYear": true
      }
    },
    "metadata": []
  },
  "baseUrlIssueBanner": true,
  "future": {
    "experimental_faster": {
      "swcJsLoader": false,
      "swcJsMinimizer": false,
      "swcHtmlMinimizer": false,
      "lightningCssMinimizer": false,
      "mdxCrossCompilerCache": false,
      "rspackBundler": false
    },
    "experimental_storage": {
      "type": "localStorage",
      "namespace": false
    },
    "experimental_router": "browser"
  },
  "onBrokenAnchors": "warn",
  "onDuplicateRoutes": "warn",
  "staticDirectories": [
    "static"
  ],
  "customFields": {},
  "plugins": [],
  "themes": [],
  "scripts": [],
  "headTags": [],
  "stylesheets": [],
  "clientModules": [],
  "titleDelimiter": "|",
  "noIndex": false,
  "markdown": {
    "format": "mdx",
    "mermaid": false,
    "mdx1Compat": {
      "comments": true,
      "admonitions": true,
      "headingIds": true
    },
    "anchors": {
      "maintainCase": false
    }
  }
};

================
File: pipe-docs/website/.docusaurus/DONT-EDIT-THIS-FOLDER
================
This folder stores temp files that Docusaurus' client bundler accesses.

DO NOT hand-modify files in this folder because they will be overwritten in the
next build. You can clear all build artifacts (including this folder) with the
`docusaurus clear` command.

================
File: pipe-docs/website/.docusaurus/globalData.json
================
{
  "docusaurus-plugin-content-docs": {
    "default": {
      "path": "/",
      "versions": [
        {
          "name": "current",
          "label": "Next",
          "isLast": true,
          "path": "/",
          "mainDocId": "intro",
          "docs": [
            {
              "id": "api-reference/configuration",
              "path": "/api-reference/configuration",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/fetch",
              "path": "/api-reference/fetch",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/node-info",
              "path": "/api-reference/node-info",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/node-status",
              "path": "/api-reference/node-status",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/pin",
              "path": "/api-reference/pin",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/pinned-cids",
              "path": "/api-reference/pinned-cids",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/publish",
              "path": "/api-reference/publish",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/publish-bundle",
              "path": "/api-reference/publish-bundle",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/replicate",
              "path": "/api-reference/replicate",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/storage-metrics",
              "path": "/api-reference/storage-metrics",
              "sidebar": "docs"
            },
            {
              "id": "api-reference/unpin",
              "path": "/api-reference/unpin",
              "sidebar": "docs"
            },
            {
              "id": "core-concepts/encryption",
              "path": "/core-concepts/encryption",
              "sidebar": "docs"
            },
            {
              "id": "core-concepts/inline-referenced",
              "path": "/core-concepts/inline-referenced",
              "sidebar": "docs"
            },
            {
              "id": "core-concepts/pipebundle",
              "path": "/core-concepts/pipebundle",
              "sidebar": "docs"
            },
            {
              "id": "core-concepts/piperecord",
              "path": "/core-concepts/piperecord",
              "sidebar": "docs"
            },
            {
              "id": "core-concepts/scopes",
              "path": "/core-concepts/scopes",
              "sidebar": "docs"
            },
            {
              "id": "core-concepts/terminology",
              "path": "/core-concepts/terminology",
              "sidebar": "docs"
            },
            {
              "id": "intro",
              "path": "/intro",
              "sidebar": "docs"
            },
            {
              "id": "introduction/overview",
              "path": "/introduction/overview",
              "sidebar": "docs"
            },
            {
              "id": "introduction/problem",
              "path": "/introduction/problem",
              "sidebar": "docs"
            },
            {
              "id": "introduction/solution",
              "path": "/introduction/solution",
              "sidebar": "docs"
            },
            {
              "id": "tutorial-basics/congratulations",
              "path": "/tutorial-basics/congratulations"
            },
            {
              "id": "tutorial-basics/create-a-blog-post",
              "path": "/tutorial-basics/create-a-blog-post"
            },
            {
              "id": "tutorial-basics/create-a-document",
              "path": "/tutorial-basics/create-a-document"
            },
            {
              "id": "tutorial-basics/create-a-page",
              "path": "/tutorial-basics/create-a-page"
            },
            {
              "id": "tutorial-basics/deploy-your-site",
              "path": "/tutorial-basics/deploy-your-site"
            },
            {
              "id": "tutorial-basics/markdown-features",
              "path": "/tutorial-basics/markdown-features"
            },
            {
              "id": "tutorial-extras/manage-docs-versions",
              "path": "/tutorial-extras/manage-docs-versions"
            },
            {
              "id": "tutorial-extras/translate-your-site",
              "path": "/tutorial-extras/translate-your-site"
            },
            {
              "id": "usage-examples/fetch-data",
              "path": "/usage-examples/fetch-data",
              "sidebar": "docs"
            },
            {
              "id": "usage-examples/pin-unpin",
              "path": "/usage-examples/pin-unpin",
              "sidebar": "docs"
            },
            {
              "id": "usage-examples/publish-data",
              "path": "/usage-examples/publish-data",
              "sidebar": "docs"
            },
            {
              "id": "usage-examples/publish-hidden-data",
              "path": "/usage-examples/publish-hidden-data",
              "sidebar": "docs"
            },
            {
              "id": "usage-examples/replicate-data",
              "path": "/usage-examples/replicate-data",
              "sidebar": "docs"
            },
            {
              "id": "usage-examples/work-bundles",
              "path": "/usage-examples/work-bundles",
              "sidebar": "docs"
            }
          ],
          "draftIds": [],
          "sidebars": {
            "docs": {
              "link": {
                "path": "/intro",
                "label": "intro"
              }
            }
          }
        }
      ],
      "breadcrumbs": true
    }
  }
}

================
File: pipe-docs/website/.docusaurus/i18n.json
================
{
  "defaultLocale": "en",
  "locales": [
    "en"
  ],
  "path": "i18n",
  "currentLocale": "en",
  "localeConfigs": {
    "en": {
      "label": "English",
      "direction": "ltr",
      "htmlLang": "en",
      "calendar": "gregory",
      "path": "en"
    }
  }
}

================
File: pipe-docs/website/.docusaurus/registry.js
================
export default {
  "__comp---site-src-pages-index-tsx-1-df-d3e": [() => import(/* webpackChunkName: "__comp---site-src-pages-index-tsx-1-df-d3e" */ "@site/src/pages/index.tsx"), "@site/src/pages/index.tsx", require.resolveWeak("@site/src/pages/index.tsx")],
  "__comp---theme-debug-config-23-a-2ff": [() => import(/* webpackChunkName: "__comp---theme-debug-config-23-a-2ff" */ "@theme/DebugConfig"), "@theme/DebugConfig", require.resolveWeak("@theme/DebugConfig")],
  "__comp---theme-debug-contentba-8-ce7": [() => import(/* webpackChunkName: "__comp---theme-debug-contentba-8-ce7" */ "@theme/DebugContent"), "@theme/DebugContent", require.resolveWeak("@theme/DebugContent")],
  "__comp---theme-debug-global-dataede-0fa": [() => import(/* webpackChunkName: "__comp---theme-debug-global-dataede-0fa" */ "@theme/DebugGlobalData"), "@theme/DebugGlobalData", require.resolveWeak("@theme/DebugGlobalData")],
  "__comp---theme-debug-registry-679-501": [() => import(/* webpackChunkName: "__comp---theme-debug-registry-679-501" */ "@theme/DebugRegistry"), "@theme/DebugRegistry", require.resolveWeak("@theme/DebugRegistry")],
  "__comp---theme-debug-routes-946-699": [() => import(/* webpackChunkName: "__comp---theme-debug-routes-946-699" */ "@theme/DebugRoutes"), "@theme/DebugRoutes", require.resolveWeak("@theme/DebugRoutes")],
  "__comp---theme-debug-site-metadata-68-e-3d4": [() => import(/* webpackChunkName: "__comp---theme-debug-site-metadata-68-e-3d4" */ "@theme/DebugSiteMetadata"), "@theme/DebugSiteMetadata", require.resolveWeak("@theme/DebugSiteMetadata")],
  "__comp---theme-doc-item-178-a40": [() => import(/* webpackChunkName: "__comp---theme-doc-item-178-a40" */ "@theme/DocItem"), "@theme/DocItem", require.resolveWeak("@theme/DocItem")],
  "__comp---theme-doc-roota-94-67a": [() => import(/* webpackChunkName: "__comp---theme-doc-roota-94-67a" */ "@theme/DocRoot"), "@theme/DocRoot", require.resolveWeak("@theme/DocRoot")],
  "__comp---theme-doc-version-roota-7-b-5de": [() => import(/* webpackChunkName: "__comp---theme-doc-version-roota-7-b-5de" */ "@theme/DocVersionRoot"), "@theme/DocVersionRoot", require.resolveWeak("@theme/DocVersionRoot")],
  "__comp---theme-docs-root-5-e-9-0b6": [() => import(/* webpackChunkName: "__comp---theme-docs-root-5-e-9-0b6" */ "@theme/DocsRoot"), "@theme/DocsRoot", require.resolveWeak("@theme/DocsRoot")],
  "__comp---theme-mdx-page-1-f-3-b90": [() => import(/* webpackChunkName: "__comp---theme-mdx-page-1-f-3-b90" */ "@theme/MDXPage"), "@theme/MDXPage", require.resolveWeak("@theme/MDXPage")],
  "__props---22-d-307": [() => import(/* webpackChunkName: "__props---22-d-307" */ "@generated/docusaurus-plugin-content-docs/default/p/index-466.json"), "@generated/docusaurus-plugin-content-docs/default/p/index-466.json", require.resolveWeak("@generated/docusaurus-plugin-content-docs/default/p/index-466.json")],
  "__props---docusaurus-debug-content-3-c-0-be2": [() => import(/* webpackChunkName: "__props---docusaurus-debug-content-3-c-0-be2" */ "@generated/docusaurus-plugin-debug/default/p/docusaurus-debug-content-0d5.json"), "@generated/docusaurus-plugin-debug/default/p/docusaurus-debug-content-0d5.json", require.resolveWeak("@generated/docusaurus-plugin-debug/default/p/docusaurus-debug-content-0d5.json")],
  "config---5-e-9-4f3": [() => import(/* webpackChunkName: "config---5-e-9-4f3" */ "@generated/docusaurus.config"), "@generated/docusaurus.config", require.resolveWeak("@generated/docusaurus.config")],
  "content---api-reference-configuration-4-f-2-191": [() => import(/* webpackChunkName: "content---api-reference-configuration-4-f-2-191" */ "@site/docs/api-reference/configuration.md"), "@site/docs/api-reference/configuration.md", require.resolveWeak("@site/docs/api-reference/configuration.md")],
  "content---api-reference-fetch-72-c-a35": [() => import(/* webpackChunkName: "content---api-reference-fetch-72-c-a35" */ "@site/docs/api-reference/fetch.md"), "@site/docs/api-reference/fetch.md", require.resolveWeak("@site/docs/api-reference/fetch.md")],
  "content---api-reference-node-infocc-6-6f4": [() => import(/* webpackChunkName: "content---api-reference-node-infocc-6-6f4" */ "@site/docs/api-reference/node-info.md"), "@site/docs/api-reference/node-info.md", require.resolveWeak("@site/docs/api-reference/node-info.md")],
  "content---api-reference-node-status-213-470": [() => import(/* webpackChunkName: "content---api-reference-node-status-213-470" */ "@site/docs/api-reference/node-status.md"), "@site/docs/api-reference/node-status.md", require.resolveWeak("@site/docs/api-reference/node-status.md")],
  "content---api-reference-pine-40-647": [() => import(/* webpackChunkName: "content---api-reference-pine-40-647" */ "@site/docs/api-reference/pin.md"), "@site/docs/api-reference/pin.md", require.resolveWeak("@site/docs/api-reference/pin.md")],
  "content---api-reference-pinned-cids-567-c36": [() => import(/* webpackChunkName: "content---api-reference-pinned-cids-567-c36" */ "@site/docs/api-reference/pinned-cids.md"), "@site/docs/api-reference/pinned-cids.md", require.resolveWeak("@site/docs/api-reference/pinned-cids.md")],
  "content---api-reference-publish-bundle-98-e-27a": [() => import(/* webpackChunkName: "content---api-reference-publish-bundle-98-e-27a" */ "@site/docs/api-reference/publish-bundle.md"), "@site/docs/api-reference/publish-bundle.md", require.resolveWeak("@site/docs/api-reference/publish-bundle.md")],
  "content---api-reference-publishc-40-bcd": [() => import(/* webpackChunkName: "content---api-reference-publishc-40-bcd" */ "@site/docs/api-reference/publish.md"), "@site/docs/api-reference/publish.md", require.resolveWeak("@site/docs/api-reference/publish.md")],
  "content---api-reference-replicatec-5-d-4fa": [() => import(/* webpackChunkName: "content---api-reference-replicatec-5-d-4fa" */ "@site/docs/api-reference/replicate.md"), "@site/docs/api-reference/replicate.md", require.resolveWeak("@site/docs/api-reference/replicate.md")],
  "content---api-reference-storage-metrics-37-d-4c8": [() => import(/* webpackChunkName: "content---api-reference-storage-metrics-37-d-4c8" */ "@site/docs/api-reference/storage-metrics.md"), "@site/docs/api-reference/storage-metrics.md", require.resolveWeak("@site/docs/api-reference/storage-metrics.md")],
  "content---api-reference-unpindf-6-770": [() => import(/* webpackChunkName: "content---api-reference-unpindf-6-770" */ "@site/docs/api-reference/unpin.md"), "@site/docs/api-reference/unpin.md", require.resolveWeak("@site/docs/api-reference/unpin.md")],
  "content---core-concepts-encryption-3-be-7a0": [() => import(/* webpackChunkName: "content---core-concepts-encryption-3-be-7a0" */ "@site/docs/core-concepts/encryption.md"), "@site/docs/core-concepts/encryption.md", require.resolveWeak("@site/docs/core-concepts/encryption.md")],
  "content---core-concepts-inline-referenced-231-046": [() => import(/* webpackChunkName: "content---core-concepts-inline-referenced-231-046" */ "@site/docs/core-concepts/inline-referenced.md"), "@site/docs/core-concepts/inline-referenced.md", require.resolveWeak("@site/docs/core-concepts/inline-referenced.md")],
  "content---core-concepts-pipebundle-6-a-7-d41": [() => import(/* webpackChunkName: "content---core-concepts-pipebundle-6-a-7-d41" */ "@site/docs/core-concepts/pipebundle.md"), "@site/docs/core-concepts/pipebundle.md", require.resolveWeak("@site/docs/core-concepts/pipebundle.md")],
  "content---core-concepts-piperecordf-4-d-986": [() => import(/* webpackChunkName: "content---core-concepts-piperecordf-4-d-986" */ "@site/docs/core-concepts/piperecord.md"), "@site/docs/core-concepts/piperecord.md", require.resolveWeak("@site/docs/core-concepts/piperecord.md")],
  "content---core-concepts-scopes-417-ff1": [() => import(/* webpackChunkName: "content---core-concepts-scopes-417-ff1" */ "@site/docs/core-concepts/scopes.md"), "@site/docs/core-concepts/scopes.md", require.resolveWeak("@site/docs/core-concepts/scopes.md")],
  "content---core-concepts-terminology-7-d-7-80d": [() => import(/* webpackChunkName: "content---core-concepts-terminology-7-d-7-80d" */ "@site/docs/core-concepts/terminology.md"), "@site/docs/core-concepts/terminology.md", require.resolveWeak("@site/docs/core-concepts/terminology.md")],
  "content---intro-0-e-3-7b8": [() => import(/* webpackChunkName: "content---intro-0-e-3-7b8" */ "@site/docs/intro.md"), "@site/docs/intro.md", require.resolveWeak("@site/docs/intro.md")],
  "content---introduction-overview-761-824": [() => import(/* webpackChunkName: "content---introduction-overview-761-824" */ "@site/docs/introduction/overview.md"), "@site/docs/introduction/overview.md", require.resolveWeak("@site/docs/introduction/overview.md")],
  "content---introduction-problem-20-e-178": [() => import(/* webpackChunkName: "content---introduction-problem-20-e-178" */ "@site/docs/introduction/problem.md"), "@site/docs/introduction/problem.md", require.resolveWeak("@site/docs/introduction/problem.md")],
  "content---introduction-solution-167-e90": [() => import(/* webpackChunkName: "content---introduction-solution-167-e90" */ "@site/docs/introduction/solution.md"), "@site/docs/introduction/solution.md", require.resolveWeak("@site/docs/introduction/solution.md")],
  "content---markdown-page-393-028": [() => import(/* webpackChunkName: "content---markdown-page-393-028" */ "@site/src/pages/markdown-page.md"), "@site/src/pages/markdown-page.md", require.resolveWeak("@site/src/pages/markdown-page.md")],
  "content---tutorial-basics-congratulations-822-79f": [() => import(/* webpackChunkName: "content---tutorial-basics-congratulations-822-79f" */ "@site/docs/tutorial-basics/congratulations.md"), "@site/docs/tutorial-basics/congratulations.md", require.resolveWeak("@site/docs/tutorial-basics/congratulations.md")],
  "content---tutorial-basics-create-a-blog-post-533-8b3": [() => import(/* webpackChunkName: "content---tutorial-basics-create-a-blog-post-533-8b3" */ "@site/docs/tutorial-basics/create-a-blog-post.md"), "@site/docs/tutorial-basics/create-a-blog-post.md", require.resolveWeak("@site/docs/tutorial-basics/create-a-blog-post.md")],
  "content---tutorial-basics-create-a-document-1-e-4-f30": [() => import(/* webpackChunkName: "content---tutorial-basics-create-a-document-1-e-4-f30" */ "@site/docs/tutorial-basics/create-a-document.md"), "@site/docs/tutorial-basics/create-a-document.md", require.resolveWeak("@site/docs/tutorial-basics/create-a-document.md")],
  "content---tutorial-basics-create-a-page-5-c-8-d8b": [() => import(/* webpackChunkName: "content---tutorial-basics-create-a-page-5-c-8-d8b" */ "@site/docs/tutorial-basics/create-a-page.md"), "@site/docs/tutorial-basics/create-a-page.md", require.resolveWeak("@site/docs/tutorial-basics/create-a-page.md")],
  "content---tutorial-basics-deploy-your-sitef-55-bcd": [() => import(/* webpackChunkName: "content---tutorial-basics-deploy-your-sitef-55-bcd" */ "@site/docs/tutorial-basics/deploy-your-site.md"), "@site/docs/tutorial-basics/deploy-your-site.md", require.resolveWeak("@site/docs/tutorial-basics/deploy-your-site.md")],
  "content---tutorial-basics-markdown-features-18-c-d7b": [() => import(/* webpackChunkName: "content---tutorial-basics-markdown-features-18-c-d7b" */ "@site/docs/tutorial-basics/markdown-features.mdx"), "@site/docs/tutorial-basics/markdown-features.mdx", require.resolveWeak("@site/docs/tutorial-basics/markdown-features.mdx")],
  "content---tutorial-extras-manage-docs-versionsdff-033": [() => import(/* webpackChunkName: "content---tutorial-extras-manage-docs-versionsdff-033" */ "@site/docs/tutorial-extras/manage-docs-versions.md"), "@site/docs/tutorial-extras/manage-docs-versions.md", require.resolveWeak("@site/docs/tutorial-extras/manage-docs-versions.md")],
  "content---tutorial-extras-translate-your-sitee-44-f13": [() => import(/* webpackChunkName: "content---tutorial-extras-translate-your-sitee-44-f13" */ "@site/docs/tutorial-extras/translate-your-site.md"), "@site/docs/tutorial-extras/translate-your-site.md", require.resolveWeak("@site/docs/tutorial-extras/translate-your-site.md")],
  "content---usage-examples-fetch-data-513-c31": [() => import(/* webpackChunkName: "content---usage-examples-fetch-data-513-c31" */ "@site/docs/usage-examples/fetch-data.md"), "@site/docs/usage-examples/fetch-data.md", require.resolveWeak("@site/docs/usage-examples/fetch-data.md")],
  "content---usage-examples-pin-unpin-8-de-4ad": [() => import(/* webpackChunkName: "content---usage-examples-pin-unpin-8-de-4ad" */ "@site/docs/usage-examples/pin-unpin.md"), "@site/docs/usage-examples/pin-unpin.md", require.resolveWeak("@site/docs/usage-examples/pin-unpin.md")],
  "content---usage-examples-publish-datab-8-d-142": [() => import(/* webpackChunkName: "content---usage-examples-publish-datab-8-d-142" */ "@site/docs/usage-examples/publish-data.md"), "@site/docs/usage-examples/publish-data.md", require.resolveWeak("@site/docs/usage-examples/publish-data.md")],
  "content---usage-examples-publish-hidden-data-7-d-3-607": [() => import(/* webpackChunkName: "content---usage-examples-publish-hidden-data-7-d-3-607" */ "@site/docs/usage-examples/publish-hidden-data.md"), "@site/docs/usage-examples/publish-hidden-data.md", require.resolveWeak("@site/docs/usage-examples/publish-hidden-data.md")],
  "content---usage-examples-replicate-datad-94-d97": [() => import(/* webpackChunkName: "content---usage-examples-replicate-datad-94-d97" */ "@site/docs/usage-examples/replicate-data.md"), "@site/docs/usage-examples/replicate-data.md", require.resolveWeak("@site/docs/usage-examples/replicate-data.md")],
  "content---usage-examples-work-bundles-16-e-7db": [() => import(/* webpackChunkName: "content---usage-examples-work-bundles-16-e-7db" */ "@site/docs/usage-examples/work-bundles.md"), "@site/docs/usage-examples/work-bundles.md", require.resolveWeak("@site/docs/usage-examples/work-bundles.md")],
  "plugin---aba-d70": [() => import(/* webpackChunkName: "plugin---aba-d70" */ "@generated/docusaurus-plugin-content-docs/default/__plugin.json"), "@generated/docusaurus-plugin-content-docs/default/__plugin.json", require.resolveWeak("@generated/docusaurus-plugin-content-docs/default/__plugin.json")],
  "plugin---docusaurus-debugb-38-ad3": [() => import(/* webpackChunkName: "plugin---docusaurus-debugb-38-ad3" */ "@generated/docusaurus-plugin-debug/default/__plugin.json"), "@generated/docusaurus-plugin-debug/default/__plugin.json", require.resolveWeak("@generated/docusaurus-plugin-debug/default/__plugin.json")],
  "plugin---markdown-pagea-74-7b5": [() => import(/* webpackChunkName: "plugin---markdown-pagea-74-7b5" */ "@generated/docusaurus-plugin-content-pages/default/__plugin.json"), "@generated/docusaurus-plugin-content-pages/default/__plugin.json", require.resolveWeak("@generated/docusaurus-plugin-content-pages/default/__plugin.json")],};

================
File: pipe-docs/website/.docusaurus/routes.js
================
import React from 'react';
import ComponentCreator from '@docusaurus/ComponentCreator';

export default [
  {
    path: '/__docusaurus/debug',
    component: ComponentCreator('/__docusaurus/debug', '5ff'),
    exact: true
  },
  {
    path: '/__docusaurus/debug/config',
    component: ComponentCreator('/__docusaurus/debug/config', '5ba'),
    exact: true
  },
  {
    path: '/__docusaurus/debug/content',
    component: ComponentCreator('/__docusaurus/debug/content', 'a2b'),
    exact: true
  },
  {
    path: '/__docusaurus/debug/globalData',
    component: ComponentCreator('/__docusaurus/debug/globalData', 'c3c'),
    exact: true
  },
  {
    path: '/__docusaurus/debug/metadata',
    component: ComponentCreator('/__docusaurus/debug/metadata', '156'),
    exact: true
  },
  {
    path: '/__docusaurus/debug/registry',
    component: ComponentCreator('/__docusaurus/debug/registry', '88c'),
    exact: true
  },
  {
    path: '/__docusaurus/debug/routes',
    component: ComponentCreator('/__docusaurus/debug/routes', '000'),
    exact: true
  },
  {
    path: '/markdown-page',
    component: ComponentCreator('/markdown-page', '3d7'),
    exact: true
  },
  {
    path: '/',
    component: ComponentCreator('/', 'e5f'),
    exact: true
  },
  {
    path: '/',
    component: ComponentCreator('/', '6c5'),
    routes: [
      {
        path: '/',
        component: ComponentCreator('/', '842'),
        routes: [
          {
            path: '/',
            component: ComponentCreator('/', 'a85'),
            routes: [
              {
                path: '/api-reference/configuration',
                component: ComponentCreator('/api-reference/configuration', '947'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/fetch',
                component: ComponentCreator('/api-reference/fetch', 'eb6'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/node-info',
                component: ComponentCreator('/api-reference/node-info', '63d'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/node-status',
                component: ComponentCreator('/api-reference/node-status', 'fbc'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/pin',
                component: ComponentCreator('/api-reference/pin', 'cd0'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/pinned-cids',
                component: ComponentCreator('/api-reference/pinned-cids', '4aa'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/publish',
                component: ComponentCreator('/api-reference/publish', 'a94'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/publish-bundle',
                component: ComponentCreator('/api-reference/publish-bundle', '5bb'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/replicate',
                component: ComponentCreator('/api-reference/replicate', 'de2'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/storage-metrics',
                component: ComponentCreator('/api-reference/storage-metrics', '75b'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/api-reference/unpin',
                component: ComponentCreator('/api-reference/unpin', '074'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/core-concepts/encryption',
                component: ComponentCreator('/core-concepts/encryption', 'b35'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/core-concepts/inline-referenced',
                component: ComponentCreator('/core-concepts/inline-referenced', '921'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/core-concepts/pipebundle',
                component: ComponentCreator('/core-concepts/pipebundle', '289'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/core-concepts/piperecord',
                component: ComponentCreator('/core-concepts/piperecord', 'bf2'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/core-concepts/scopes',
                component: ComponentCreator('/core-concepts/scopes', 'c93'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/core-concepts/terminology',
                component: ComponentCreator('/core-concepts/terminology', '02d'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/intro',
                component: ComponentCreator('/intro', 'd0c'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/introduction/overview',
                component: ComponentCreator('/introduction/overview', '2e5'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/introduction/problem',
                component: ComponentCreator('/introduction/problem', 'a0f'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/introduction/solution',
                component: ComponentCreator('/introduction/solution', '313'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/tutorial-basics/congratulations',
                component: ComponentCreator('/tutorial-basics/congratulations', '58f'),
                exact: true
              },
              {
                path: '/tutorial-basics/create-a-blog-post',
                component: ComponentCreator('/tutorial-basics/create-a-blog-post', 'b9d'),
                exact: true
              },
              {
                path: '/tutorial-basics/create-a-document',
                component: ComponentCreator('/tutorial-basics/create-a-document', 'c74'),
                exact: true
              },
              {
                path: '/tutorial-basics/create-a-page',
                component: ComponentCreator('/tutorial-basics/create-a-page', '913'),
                exact: true
              },
              {
                path: '/tutorial-basics/deploy-your-site',
                component: ComponentCreator('/tutorial-basics/deploy-your-site', 'ca5'),
                exact: true
              },
              {
                path: '/tutorial-basics/markdown-features',
                component: ComponentCreator('/tutorial-basics/markdown-features', 'b4e'),
                exact: true
              },
              {
                path: '/tutorial-extras/manage-docs-versions',
                component: ComponentCreator('/tutorial-extras/manage-docs-versions', 'b1f'),
                exact: true
              },
              {
                path: '/tutorial-extras/translate-your-site',
                component: ComponentCreator('/tutorial-extras/translate-your-site', '4d4'),
                exact: true
              },
              {
                path: '/usage-examples/fetch-data',
                component: ComponentCreator('/usage-examples/fetch-data', 'f62'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/usage-examples/pin-unpin',
                component: ComponentCreator('/usage-examples/pin-unpin', 'fb9'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/usage-examples/publish-data',
                component: ComponentCreator('/usage-examples/publish-data', '84c'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/usage-examples/publish-hidden-data',
                component: ComponentCreator('/usage-examples/publish-hidden-data', '245'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/usage-examples/replicate-data',
                component: ComponentCreator('/usage-examples/replicate-data', '7ce'),
                exact: true,
                sidebar: "docs"
              },
              {
                path: '/usage-examples/work-bundles',
                component: ComponentCreator('/usage-examples/work-bundles', '90f'),
                exact: true,
                sidebar: "docs"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    path: '*',
    component: ComponentCreator('*'),
  },
];

================
File: pipe-docs/website/.docusaurus/routesChunkNames.json
================
{
  "/__docusaurus/debug-5ff": {
    "__comp": "__comp---theme-debug-config-23-a-2ff",
    "__context": {
      "plugin": "plugin---docusaurus-debugb-38-ad3"
    }
  },
  "/__docusaurus/debug/config-5ba": {
    "__comp": "__comp---theme-debug-config-23-a-2ff",
    "__context": {
      "plugin": "plugin---docusaurus-debugb-38-ad3"
    }
  },
  "/__docusaurus/debug/content-a2b": {
    "__comp": "__comp---theme-debug-contentba-8-ce7",
    "__context": {
      "plugin": "plugin---docusaurus-debugb-38-ad3"
    },
    "__props": "__props---docusaurus-debug-content-3-c-0-be2"
  },
  "/__docusaurus/debug/globalData-c3c": {
    "__comp": "__comp---theme-debug-global-dataede-0fa",
    "__context": {
      "plugin": "plugin---docusaurus-debugb-38-ad3"
    }
  },
  "/__docusaurus/debug/metadata-156": {
    "__comp": "__comp---theme-debug-site-metadata-68-e-3d4",
    "__context": {
      "plugin": "plugin---docusaurus-debugb-38-ad3"
    }
  },
  "/__docusaurus/debug/registry-88c": {
    "__comp": "__comp---theme-debug-registry-679-501",
    "__context": {
      "plugin": "plugin---docusaurus-debugb-38-ad3"
    }
  },
  "/__docusaurus/debug/routes-000": {
    "__comp": "__comp---theme-debug-routes-946-699",
    "__context": {
      "plugin": "plugin---docusaurus-debugb-38-ad3"
    }
  },
  "/markdown-page-3d7": {
    "__comp": "__comp---theme-mdx-page-1-f-3-b90",
    "__context": {
      "plugin": "plugin---markdown-pagea-74-7b5"
    },
    "content": "content---markdown-page-393-028"
  },
  "/-e5f": {
    "__comp": "__comp---site-src-pages-index-tsx-1-df-d3e",
    "__context": {
      "plugin": "plugin---markdown-pagea-74-7b5"
    },
    "config": "config---5-e-9-4f3"
  },
  "/-6c5": {
    "__comp": "__comp---theme-docs-root-5-e-9-0b6",
    "__context": {
      "plugin": "plugin---aba-d70"
    }
  },
  "/-842": {
    "__comp": "__comp---theme-doc-version-roota-7-b-5de",
    "__props": "__props---22-d-307"
  },
  "/-a85": {
    "__comp": "__comp---theme-doc-roota-94-67a"
  },
  "/api-reference/configuration-947": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-configuration-4-f-2-191"
  },
  "/api-reference/fetch-eb6": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-fetch-72-c-a35"
  },
  "/api-reference/node-info-63d": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-node-infocc-6-6f4"
  },
  "/api-reference/node-status-fbc": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-node-status-213-470"
  },
  "/api-reference/pin-cd0": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-pine-40-647"
  },
  "/api-reference/pinned-cids-4aa": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-pinned-cids-567-c36"
  },
  "/api-reference/publish-a94": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-publishc-40-bcd"
  },
  "/api-reference/publish-bundle-5bb": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-publish-bundle-98-e-27a"
  },
  "/api-reference/replicate-de2": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-replicatec-5-d-4fa"
  },
  "/api-reference/storage-metrics-75b": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-storage-metrics-37-d-4c8"
  },
  "/api-reference/unpin-074": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---api-reference-unpindf-6-770"
  },
  "/core-concepts/encryption-b35": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---core-concepts-encryption-3-be-7a0"
  },
  "/core-concepts/inline-referenced-921": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---core-concepts-inline-referenced-231-046"
  },
  "/core-concepts/pipebundle-289": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---core-concepts-pipebundle-6-a-7-d41"
  },
  "/core-concepts/piperecord-bf2": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---core-concepts-piperecordf-4-d-986"
  },
  "/core-concepts/scopes-c93": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---core-concepts-scopes-417-ff1"
  },
  "/core-concepts/terminology-02d": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---core-concepts-terminology-7-d-7-80d"
  },
  "/intro-d0c": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---intro-0-e-3-7b8"
  },
  "/introduction/overview-2e5": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---introduction-overview-761-824"
  },
  "/introduction/problem-a0f": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---introduction-problem-20-e-178"
  },
  "/introduction/solution-313": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---introduction-solution-167-e90"
  },
  "/tutorial-basics/congratulations-58f": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---tutorial-basics-congratulations-822-79f"
  },
  "/tutorial-basics/create-a-blog-post-b9d": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---tutorial-basics-create-a-blog-post-533-8b3"
  },
  "/tutorial-basics/create-a-document-c74": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---tutorial-basics-create-a-document-1-e-4-f30"
  },
  "/tutorial-basics/create-a-page-913": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---tutorial-basics-create-a-page-5-c-8-d8b"
  },
  "/tutorial-basics/deploy-your-site-ca5": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---tutorial-basics-deploy-your-sitef-55-bcd"
  },
  "/tutorial-basics/markdown-features-b4e": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---tutorial-basics-markdown-features-18-c-d7b"
  },
  "/tutorial-extras/manage-docs-versions-b1f": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---tutorial-extras-manage-docs-versionsdff-033"
  },
  "/tutorial-extras/translate-your-site-4d4": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---tutorial-extras-translate-your-sitee-44-f13"
  },
  "/usage-examples/fetch-data-f62": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---usage-examples-fetch-data-513-c31"
  },
  "/usage-examples/pin-unpin-fb9": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---usage-examples-pin-unpin-8-de-4ad"
  },
  "/usage-examples/publish-data-84c": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---usage-examples-publish-datab-8-d-142"
  },
  "/usage-examples/publish-hidden-data-245": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---usage-examples-publish-hidden-data-7-d-3-607"
  },
  "/usage-examples/replicate-data-7ce": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---usage-examples-replicate-datad-94-d97"
  },
  "/usage-examples/work-bundles-90f": {
    "__comp": "__comp---theme-doc-item-178-a40",
    "content": "content---usage-examples-work-bundles-16-e-7db"
  }
}

================
File: pipe-docs/website/.docusaurus/site-metadata.json
================
{
  "docusaurusVersion": "3.7.0",
  "siteVersion": "0.0.0",
  "pluginVersions": {
    "docusaurus-plugin-content-docs": {
      "type": "package",
      "name": "@docusaurus/plugin-content-docs",
      "version": "3.7.0"
    },
    "docusaurus-plugin-content-pages": {
      "type": "package",
      "name": "@docusaurus/plugin-content-pages",
      "version": "3.7.0"
    },
    "docusaurus-plugin-debug": {
      "type": "package",
      "name": "@docusaurus/plugin-debug",
      "version": "3.7.0"
    },
    "docusaurus-plugin-svgr": {
      "type": "package",
      "name": "@docusaurus/plugin-svgr",
      "version": "3.7.0"
    },
    "docusaurus-theme-classic": {
      "type": "package",
      "name": "@docusaurus/theme-classic",
      "version": "3.7.0"
    }
  }
}

================
File: pipe-docs/website/.docusaurus/site-storage.json
================
{
  "type": "localStorage",
  "namespace": ""
}

================
File: scripts/test-api.ts
================
import { PipeProtocol } from '../src/pipe.js';
import { createApi } from '../src/api.js';
import { AddressInfo } from 'net';
import { request } from 'http';
import { Server } from 'http';

async function testApi() {
  console.log('Starting API test...\n');
  
  const pipe = new PipeProtocol({});
  const app = createApi(pipe);
  let server: Server | undefined;

  try {
    // Start the API server
    server = app.listen(0); // Use port 0 to get a random available port
    const address = server.address() as AddressInfo;
    const port = address.port;
    console.log(`API server started on port ${port}\n`);

    // Helper function to make API requests
    async function makeRequest(method: string, path: string, body?: any): Promise<{ status: number; data: any }> {
      return new Promise((resolve, reject) => {
        const options = {
          hostname: 'localhost',
          port: port,
          path: path,
          method: method,
          headers: {
            'Content-Type': 'application/json'
          }
        };

        const req = request(options, (res) => {
          let data = '';
          res.on('data', chunk => data += chunk);
          res.on('end', () => {
            try {
              resolve({
                status: res.statusCode || 500,
                data: data ? JSON.parse(data) : null
              });
            } catch (error) {
              resolve({
                status: res.statusCode || 500,
                data: null
              });
            }
          });
        });

        req.on('error', (error) => {
          console.error('Request error:', error);
          reject(error);
        });

        if (body) {
          req.write(JSON.stringify(body));
        }
        req.end();
      });
    }

    // Test 1: Publish a record via API
    console.log('Test 1: Publishing a record via API...');
    const record = {
      type: 'data' as const,
      content: { message: 'Hello from API!' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const publishResponse = await makeRequest('POST', '/publish', record);
    console.log('Publish response:', {
      status: publishResponse.status,
      data: publishResponse.data
    });

    const publishedCid = publishResponse.data?.cid;

    // Test 2: Fetch the published record
    console.log('\nTest 2: Fetching the published record...');
    const fetchResponse = await makeRequest('GET', `/fetch/${publishedCid}/private`);
    console.log('Fetch response:', {
      status: fetchResponse.status,
      data: fetchResponse.data
    });

    // Verify content matches
    const contentMatches = JSON.stringify(fetchResponse.data?.content) === JSON.stringify(record.content);
    console.log('Content matches original:', contentMatches);

    // Test 3: Get node status
    console.log('\nTest 3: Getting node status...');
    const statusResponse = await makeRequest('GET', '/status');
    console.log('Status response:', {
      status: statusResponse.status,
      data: statusResponse.data
    });

    // Test 4: Pin the record
    console.log('\nTest 4: Pinning the record...');
    const pinResponse = await makeRequest('POST', `/pin/${publishedCid}/private`);
    console.log('Pin response:', {
      status: pinResponse.status,
      data: pinResponse.data
    });

    // Test 5: Get pinned CIDs
    console.log('\nTest 5: Getting pinned CIDs...');
    const pinnedResponse = await makeRequest('GET', '/pins/private');
    console.log('Pinned CIDs response:', {
      status: pinnedResponse.status,
      data: pinnedResponse.data
    });

    // Verify the published CID is in the pinned list
    const isPinned = pinnedResponse.data?.includes(publishedCid);
    console.log('Published CID is pinned:', isPinned);

    // Test 6: Publish a bundle
    console.log('\nTest 6: Publishing a bundle...');
    const bundle = {
      schemaRecord: {
        type: 'schema' as const,
        content: {
          type: 'object',
          properties: {
            name: { type: 'string' }
          }
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
      },
      dataRecord: {
        type: 'data' as const,
        content: { name: 'Test Bundle' },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
      },
      combinedScope: 'private',
      timestamp: new Date().toISOString()
    };

    const bundleResponse = await makeRequest('POST', '/publish/bundle', bundle);
    console.log('Bundle publish response:', {
      status: bundleResponse.status,
      data: bundleResponse.data
    });

    // Test 7: Error handling
    console.log('\nTest 7: Testing error handling...');
    
    // Invalid CID
    const invalidFetchResponse = await makeRequest('GET', '/fetch/invalid-cid/private');
    console.log('Invalid CID fetch response:', {
      status: invalidFetchResponse.status,
      error: invalidFetchResponse.data
    });

    // Invalid scope
    const invalidScopeResponse = await makeRequest('GET', `/fetch/${publishedCid}/invalid`);
    console.log('Invalid scope fetch response:', {
      status: invalidScopeResponse.status,
      error: invalidScopeResponse.data
    });

  } catch (error) {
    console.error('Error during test:', error);
  } finally {
    try {
      if (server) {
        server.close();
      }
      await pipe.stop();
      console.log('\nTest completed, server stopped, and node stopped.');
    } catch (error) {
      console.error('Error stopping server/node:', error);
    }
  }
}

// Run the test
(async () => {
  try {
    await testApi();
  } catch (error) {
    console.error('Test failed:', error);
    process.exit(1);
  }
})();

================
File: scripts/test-basic-operations.ts
================
import { PipeProtocol } from '../src/pipe.js';

async function testBasicOperations() {
  console.log('Starting basic operations test...\n');
  
  let pipe: PipeProtocol | undefined;

  try {
    pipe = new PipeProtocol({});

    // Test 1: Publish a simple record
    console.log('Test 1: Publishing a simple record...');
    const record = {
      type: 'data' as const,
      content: { message: 'Hello, IPFS!' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const published = await pipe.publishRecord(record);
    console.log('Published record:', {
      cid: published.cid,
      content: published.content
    });

    // Test 2: Fetch the published record
    console.log('\nTest 2: Fetching the published record...');
    if (published.cid) {
      const fetched = await pipe.fetchRecord(published.cid, 'private');
      console.log('Fetched record:', fetched);

      // Verify content matches
      const contentMatches = JSON.stringify(fetched?.content) === JSON.stringify(record.content);
      console.log('Content matches original:', contentMatches);
    }

    // Test 3: Pin the record
    console.log('\nTest 3: Pinning the record...');
    if (published.cid) {
      await pipe.pin(published.cid, 'private');
      console.log('Record pinned successfully');
    }

    // Test 4: Get pinned CIDs
    console.log('\nTest 4: Getting pinned CIDs...');
    const pinnedCids = await pipe.getPinnedCids('private');
    console.log('Pinned CIDs:', pinnedCids);

    // Verify the published CID is in the pinned list
    if (published.cid) {
      const isPinned = pinnedCids.includes(published.cid);
      console.log('Published CID is pinned:', isPinned);
    }

    // Test 5: Get node status
    console.log('\nTest 5: Getting node status...');
    const status = await pipe.getStatus();
    console.log('Node status:', status);

  } catch (error) {
    console.error('Error during test:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  } finally {
    try {
      if (pipe) {
        await pipe.stop();
        console.log('\nTest completed and node stopped.');
      }
    } catch (error) {
      console.error('Error stopping node:', error);
      if (error instanceof Error) {
        console.error('Error stack:', error.stack);
      }
      process.exit(1);
    }
  }
}

// Run the test
(async () => {
  try {
    await testBasicOperations();
  } catch (error) {
    console.error('Test failed:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  }
})();

================
File: scripts/test-bundles.ts
================
import { PipeProtocol } from '../src/pipe';
import { PipeBundle } from '../src/types';

async function testBundles() {
  console.log('Starting bundles test...\n');
  
  const pipe = new PipeProtocol({});

  try {
    // Test 1: Create and publish a bundle with schema and data
    console.log('Test 1: Publishing a bundle with schema and data...');
    const bundle: PipeBundle = {
      schemaRecord: {
        type: 'schema' as const,
        content: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            age: { type: 'number' }
          },
          required: ['name', 'age']
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
      },
      dataRecord: {
        type: 'data' as const,
        content: {
          name: 'John Doe',
          age: 30
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false },
        pinned: true
      },
      combinedScope: 'private',
      timestamp: new Date().toISOString()
    };

    const published = await pipe.publishBundle(bundle);
    console.log('Published bundle:', {
      schemaRecord: {
        cid: published.schemaRecord.cid,
        content: published.schemaRecord.content
      },
      dataRecord: {
        cid: published.dataRecord.cid,
        content: published.dataRecord.content
      },
      timestamp: published.timestamp
    });

    // Test 2: Fetch and verify bundle records
    console.log('\nTest 2: Fetching bundle records...');
    if (published.schemaRecord.cid && published.dataRecord.cid) {
      const fetchedSchema = await pipe.fetchRecord(published.schemaRecord.cid, 'private');
      const fetchedData = await pipe.fetchRecord(published.dataRecord.cid, 'private');

      console.log('Fetched schema record:', {
        content: fetchedSchema?.content,
        type: fetchedSchema?.type
      });

      console.log('Fetched data record:', {
        content: fetchedData?.content,
        type: fetchedData?.type
      });

      // Verify content matches
      const schemaMatches = JSON.stringify(fetchedSchema?.content) === JSON.stringify(bundle.schemaRecord.content);
      const dataMatches = JSON.stringify(fetchedData?.content) === JSON.stringify(bundle.dataRecord.content);
      console.log('Content matches original:', {
        schema: schemaMatches,
        data: dataMatches
      });
    }

    // Test 3: Create and publish an encrypted bundle
    console.log('\nTest 3: Publishing an encrypted bundle...');
    const encryptedBundle: PipeBundle = {
      schemaRecord: {
        type: 'schema' as const,
        content: {
          type: 'object',
          properties: {
            secretKey: { type: 'string' },
            value: { type: 'string' }
          },
          required: ['secretKey', 'value']
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: true },
        encryption: { 
          enabled: true,
          method: 'AES-GCM',
          keyRef: 'bundleKey1'
        },
        pinned: true
      },
      dataRecord: {
        type: 'data' as const,
        content: {
          secretKey: 'super-secret',
          value: 'classified-data'
        },
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: true },
        encryption: { 
          enabled: true,
          method: 'AES-GCM',
          keyRef: 'bundleKey1'
        },
        pinned: true
      },
      combinedScope: 'private',
      timestamp: new Date().toISOString()
    };

    const publishedEncrypted = await pipe.publishBundle(encryptedBundle);
    console.log('Published encrypted bundle:', {
      schemaRecord: {
        cid: publishedEncrypted.schemaRecord.cid,
        encryption: publishedEncrypted.schemaRecord.encryption
      },
      dataRecord: {
        cid: publishedEncrypted.dataRecord.cid,
        encryption: publishedEncrypted.dataRecord.encryption
      }
    });

    // Test 4: Verify pinning of bundle records
    console.log('\nTest 4: Verifying pinned bundle records...');
    const pinnedCids = await pipe.getPinnedCids('private');
    
    const schemaPinned = published.schemaRecord.cid && pinnedCids.includes(published.schemaRecord.cid);
    const dataPinned = published.dataRecord.cid && pinnedCids.includes(published.dataRecord.cid);
    const encryptedSchemaPinned = publishedEncrypted.schemaRecord.cid && 
      pinnedCids.includes(publishedEncrypted.schemaRecord.cid);
    const encryptedDataPinned = publishedEncrypted.dataRecord.cid && 
      pinnedCids.includes(publishedEncrypted.dataRecord.cid);

    console.log('Bundle records are pinned:', {
      plainSchema: schemaPinned,
      plainData: dataPinned,
      encryptedSchema: encryptedSchemaPinned,
      encryptedData: encryptedDataPinned
    });

  } catch (error) {
    console.error('Error during test:', error);
  } finally {
    try {
      await pipe.stop();
      console.log('\nTest completed and node stopped.');
    } catch (error) {
      console.error('Error stopping node:', error);
    }
  }
}

// Run the test
(async () => {
  try {
    await testBundles();
  } catch (error) {
    console.error('Test failed:', error);
    process.exit(1);
  }
})();

================
File: scripts/test-encryption.ts
================
import { PipeProtocol } from '../src/pipe';

async function testEncryption() {
  console.log('Starting encryption test...\n');
  
  const pipe = new PipeProtocol({});

  try {
    // Test 1: Publish an encrypted record
    console.log('Test 1: Publishing an encrypted record...');
    const record = {
      type: 'data' as const,
      content: { secretMessage: 'This is a secret!' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: true },
      encryption: { 
        enabled: true,
        method: 'AES-GCM',
        keyRef: 'testKey1'
      },
      pinned: true
    };

    const published = await pipe.publishRecord(record);
    console.log('Published encrypted record:', {
      cid: published.cid,
      content: published.content,
      encryption: published.encryption
    });

    // Verify the content is encrypted (should be different from original)
    const contentChanged = JSON.stringify(published.content) !== JSON.stringify(record.content);
    console.log('Content was encrypted (different from original):', contentChanged);

    // Test 2: Publish a record with different encryption settings
    console.log('\nTest 2: Publishing with different encryption settings...');
    const record2 = {
      type: 'data' as const,
      content: { secretMessage: 'Another secret!' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: true },
      encryption: { 
        enabled: true,
        method: 'AES-GCM',
        keyRef: 'testKey2'
      },
      pinned: true
    };

    const published2 = await pipe.publishRecord(record2);
    console.log('Published second encrypted record:', {
      cid: published2.cid,
      content: published2.content,
      encryption: published2.encryption
    });

    // Test 3: Verify different keys produce different ciphertexts
    console.log('\nTest 3: Verifying different keys produce different ciphertexts...');
    const differentCiphertexts = published.content !== published2.content;
    console.log('Different keys produced different ciphertexts:', differentCiphertexts);

    // Test 4: Publish an unencrypted record
    console.log('\nTest 4: Publishing an unencrypted record...');
    const record3 = {
      type: 'data' as const,
      content: { publicMessage: 'This is public!' },
      scope: 'public' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const published3 = await pipe.publishRecord(record3);
    console.log('Published unencrypted record:', {
      cid: published3.cid,
      content: published3.content,
      encryption: published3.encryption
    });

    // Verify content matches (should be unchanged)
    const contentUnchanged = JSON.stringify(published3.content) === JSON.stringify(record3.content);
    console.log('Unencrypted content matches original:', contentUnchanged);

    // Test 5: Fetch and verify records
    console.log('\nTest 5: Fetching and verifying records...');
    
    if (published.cid && published2.cid && published3.cid) {
      // Fetch encrypted records
      const fetched1 = await pipe.fetchRecord(published.cid, 'private');
      const fetched2 = await pipe.fetchRecord(published2.cid, 'private');
      const fetched3 = await pipe.fetchRecord(published3.cid, 'public');

      console.log('Fetched records have encryption enabled:', {
        record1: fetched1?.encryption?.enabled,
        record2: fetched2?.encryption?.enabled,
        record3: fetched3?.encryption?.enabled
      });

      // Verify encryption settings are preserved
      const encryptionPreserved = 
        fetched1?.encryption?.enabled === record.encryption.enabled &&
        fetched2?.encryption?.enabled === record2.encryption.enabled &&
        fetched3?.encryption?.enabled === record3.encryption.enabled;

      console.log('Encryption settings preserved:', encryptionPreserved);
    }

  } catch (error) {
    console.error('Error during test:', error);
  } finally {
    try {
      await pipe.stop();
      console.log('\nTest completed and node stopped.');
    } catch (error) {
      console.error('Error stopping node:', error);
    }
  }
}

// Run the test
(async () => {
  try {
    await testEncryption();
  } catch (error) {
    console.error('Test failed:', error);
    process.exit(1);
  }
})();

================
File: scripts/test-ipfs.ts
================
import { IpfsClient } from '../src/ipfsClient.js';
import { PipeRecord, Scope } from '../src/types.js';

async function testIpfsClient() {
  console.log('Starting IPFS Client tests...\n');
  const client = new IpfsClient();

  try {
    // Test 1: Node Initialization and Status
    console.log('Test 1: Testing node initialization and status...');
    const status = await client.getStatus();
    console.log('Node status:', status);
    console.assert(status.localNode === true, 'Local node should be initialized');
    console.assert(status.machineNode === true, 'Machine node should be initialized');
    console.assert(status.userNode === true, 'User node should be initialized');
    console.log('✓ Node initialization test passed\n');

    // Test 2: Publishing and Fetching
    console.log('Test 2: Testing publishing and fetching...');
    const testRecord: PipeRecord = {
      type: 'data',
      content: { test: 'data' },
      scope: 'private',
      pinned: true
    };
    
    const publishedRecord = await client.publish(testRecord);
    console.log('Published record:', publishedRecord);
    console.assert(publishedRecord.cid, 'Published record should have a CID');

    if (!publishedRecord.cid) {
      throw new Error('Published record CID is undefined');
    }

    const fetchedContent = await client.fetch(publishedRecord.cid, 'private');
    console.log('Fetched content:', fetchedContent);
    console.assert(JSON.stringify(fetchedContent) === JSON.stringify(testRecord.content), 
      'Fetched content should match original content');
    console.log('✓ Publishing and fetching test passed\n');

    // Test 3: Pinning Operations
    console.log('Test 3: Testing pinning operations...');
    const pinnedCids = await client.getPinnedCids('private');
    console.log('Pinned CIDs:', pinnedCids);
    console.assert(publishedRecord.cid && pinnedCids.includes(publishedRecord.cid), 
      'Published record should be in pinned CIDs');

    if (publishedRecord.cid) {
      await client.unpin(publishedRecord.cid, 'private');
      const afterUnpinCids = await client.getPinnedCids('private');
      console.assert(!afterUnpinCids.includes(publishedRecord.cid), 
        'Unpinned record should not be in pinned CIDs');
    }
    console.log('✓ Pinning operations test passed\n');

    // Test 4: Cross-scope Access Prevention
    console.log('Test 4: Testing cross-scope access prevention...');
    const machineRecord: PipeRecord = {
      type: 'data',
      content: { scope: 'machine-data' },
      scope: 'machine',
      pinned: true
    };
    
    const publishedMachineRecord = await client.publish(machineRecord);
    
    if (!publishedMachineRecord.cid) {
      throw new Error('Published machine record CID is undefined');
    }

    try {
      await client.fetch(publishedMachineRecord.cid, 'user');
      console.assert(false, 'Should not be able to fetch machine record from user scope');
    } catch (error) {
      console.log('✓ Successfully prevented cross-scope access');
    }
    console.log('✓ Cross-scope access prevention test passed\n');

    // Test 5: Storage Metrics and Configuration
    console.log('Test 5: Testing storage metrics and configuration...');
    const metrics = await client.getStorageMetrics('private');
    console.log('Storage metrics:', metrics);
    console.assert(typeof metrics.repoSize === 'number', 'Storage metrics should include repo size');

    const config = await client.getConfiguration('private');
    console.log('Node configuration:', config);
    console.assert(config.peerId, 'Configuration should include peer ID');
    console.log('✓ Storage metrics and configuration test passed\n');

    console.log('All tests completed successfully!');
  } catch (error) {
    console.error('Test failed:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  } finally {
    await client.stop();
    console.log('IPFS client stopped.');
  }
}

testIpfsClient().catch(error => {
  console.error('Test suite failed:', error);
  process.exit(1);
});

================
File: scripts/test-llm-wrapping.ts
================
import { PipeProtocol } from '../src/pipe.js';
import type { Tool } from '../src/types.js';

async function testLLMWrapping() {
  console.log('Testing LLM function wrapping with Pipe...');
  
  let pipe: PipeProtocol | undefined;

  try {
    // Initialize PipeProtocol
    pipe = new PipeProtocol({
      localNodeEndpoint: 'http://localhost:5001',
      publicNodeEndpoint: 'http://localhost:5001'
    });

    // Mock LLM function that simulates making an API call
    const mockLLMCall = async (prompt: string): Promise<string> => {
      console.log('Making mock LLM call with prompt:', prompt);
      // Simulate API latency
      await new Promise(resolve => setTimeout(resolve, 1000));
      return `Response to: ${prompt}\nThis is a simulated LLM response that provides an answer to your query.`;
    };

    // Create a tool definition for the LLM function
    const llmTool: Tool = {
      name: 'llm-query',
      description: 'Makes a query to a language model and returns its response',
      parameters: {
        type: 'object',
        properties: {
          prompt: {
            type: 'string',
            description: 'The prompt to send to the language model'
          }
        },
        required: ['prompt']
      },
      call: async (args: { prompt: string }) => {
        const response = await mockLLMCall(args.prompt);
        return {
          prompt: args.prompt,
          response,
          timestamp: new Date().toISOString(),
          metadata: {
            model: 'mock-llm-model',
            version: '1.0.0'
          }
        };
      }
    };

    // Wrap the LLM tool with Pipe
    const [wrappedLLMTool] = pipe.wrap([llmTool]);

    // Test the wrapped tool with different prompts
    const prompts = [
      'What is the capital of France?',
      'Explain quantum computing in simple terms',
      'Write a haiku about programming'
    ];

    console.log('\nTesting wrapped LLM tool with multiple prompts...');
    
    for (const prompt of prompts) {
      console.log(`\nSending prompt: "${prompt}"`);
      
      const result = await wrappedLLMTool.execute({
        prompt,
        pipeOptions: {
          scope: 'private',
          generateSchema: true,
          pin: true
        }
      });

      console.log('Result CID:', result.cid);
      console.log('Schema CID:', result.schemaCid);
      
      // Fetch the stored result
      const storedRecord = await pipe.fetchRecord(result.cid, 'private');
      console.log('Stored content:', storedRecord?.content);
    }

    console.log('\nTest completed successfully!');
  } catch (error) {
    console.error('Error during test:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  } finally {
    try {
      if (pipe) {
        await pipe.stop();
        console.log('\nTest completed and node stopped.');
      }
    } catch (error) {
      console.error('Error stopping node:', error);
      if (error instanceof Error) {
        console.error('Error stack:', error.stack);
      }
      process.exit(1);
    }
  }
}

// Run the test
(async () => {
  try {
    await testLLMWrapping();
  } catch (error) {
    console.error('Test failed:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  }
})();

================
File: scripts/test-replication.ts
================
import { PipeProtocol } from '../src/pipe.js';

async function testReplication() {
  console.log('Starting replication test...\n');
  
  const pipe = new PipeProtocol({
    publicNodeEndpoint: 'https://ipfs.infura.io:5001'
  });

  try {
    // Test 1: Publish a record to private scope
    console.log('Test 1: Publishing a record to private scope...');
    const privateRecord = {
      type: 'data' as const,
      content: { message: 'Private data' },
      scope: 'private' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const publishedPrivate = await pipe.publishRecord(privateRecord);
    console.log('Published private record:', {
      cid: publishedPrivate.cid,
      scope: publishedPrivate.scope
    });

    // Test 2: Replicate to public scope
    console.log('\nTest 2: Replicating to public scope...');
    if (publishedPrivate.cid) {
      await pipe.replicate(publishedPrivate.cid, 'private', 'public');
      console.log('Record replicated to public scope');
    }

    // Test 3: Verify record is accessible in both scopes
    console.log('\nTest 3: Verifying record accessibility...');
    if (publishedPrivate.cid) {
      const privateAccess = await pipe.fetchRecord(publishedPrivate.cid, 'private');
      const publicAccess = await pipe.fetchRecord(publishedPrivate.cid, 'public');

      console.log('Record accessibility:', {
        privateScope: Boolean(privateAccess),
        publicScope: Boolean(publicAccess)
      });
    }

    // Test 4: Test machine scope
    console.log('\nTest 4: Testing machine scope...');
    const machineRecord = {
      type: 'data' as const,
      content: { message: 'Machine-specific data' },
      scope: 'machine' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const publishedMachine = await pipe.publishRecord(machineRecord);
    console.log('Published machine record:', {
      cid: publishedMachine.cid,
      scope: publishedMachine.scope
    });

    // Test 5: Test user scope
    console.log('\nTest 5: Testing user scope...');
    const userRecord = {
      type: 'data' as const,
      content: { message: 'User-specific data' },
      scope: 'user' as const,
      accessPolicy: { hiddenFromLLM: false },
      encryption: { enabled: false },
      pinned: true
    };

    const publishedUser = await pipe.publishRecord(userRecord);
    console.log('Published user record:', {
      cid: publishedUser.cid,
      scope: publishedUser.scope
    });

    // Test 6: Verify pinning across scopes
    console.log('\nTest 6: Verifying pinning across scopes...');
    const privatePins = await pipe.getPinnedCids('private');
    const publicPins = await pipe.getPinnedCids('public');
    const machinePins = await pipe.getPinnedCids('machine');
    const userPins = await pipe.getPinnedCids('user');

    console.log('Pinned CIDs by scope:', {
      private: privatePins.length,
      public: publicPins.length,
      machine: machinePins.length,
      user: userPins.length
    });

    // Test 7: Test scope isolation
    console.log('\nTest 7: Testing scope isolation...');
    if (publishedMachine.cid && publishedUser.cid) {
      try {
        await pipe.fetchRecord(publishedMachine.cid, 'user');
        console.log('Warning: Machine record accessible from user scope');
      } catch (error) {
        console.log('Expected: Machine record not accessible from user scope');
      }

      try {
        await pipe.fetchRecord(publishedUser.cid, 'machine');
        console.log('Warning: User record accessible from machine scope');
      } catch (error) {
        console.log('Expected: User record not accessible from machine scope');
      }
    }

  } catch (error) {
    console.error('Error during test:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  } finally {
    try {
      await pipe.stop();
      console.log('\nTest completed and node stopped.');
    } catch (error) {
      console.error('Error stopping node:', error);
      if (error instanceof Error) {
        console.error('Error stack:', error.stack);
      }
      process.exit(1);
    }
  }
}

// Run the test
(async () => {
  try {
    await testReplication();
  } catch (error) {
    console.error('Test failed:', error);
    if (error instanceof Error) {
      console.error('Error stack:', error.stack);
    }
    process.exit(1);
  }
})();

================
File: scripts/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "../dist-scripts"
  },
  "ts-node": {
    "esm": true,
    "experimentalSpecifierResolution": "node"
  },
  "include": ["./**/*"],
  "exclude": ["node_modules"]
}

================
File: src/__tests__/mocks/ipfs-http-client.ts
================
// Create a shared data store for all tests
export const mockDataStore = new Map<string, any>();
export const mockPinnedCids = new Set<string>();

const mockIPFSClient = {
  add: jest.fn().mockImplementation(async (data: any) => {
    const cid = `QmTest${Math.random().toString(36).substring(7)}`;
    // Store the data as a string, just like the real IPFS client
    const stringData = typeof data === 'string' ? data : JSON.stringify(data);
    mockDataStore.set(cid, stringData);
    return { path: cid };
  }),

  cat: jest.fn().mockImplementation(function* (cid: string) {
    const data = mockDataStore.get(cid);
    if (!data) {
      throw new Error('CID not found');
    }
    // Return the data as a Buffer, just like the real IPFS client
    yield Buffer.from(data);
  }),

  pin: {
    add: jest.fn().mockImplementation(async (cid: string) => {
      mockPinnedCids.add(cid);
      return undefined;
    }),
    rm: jest.fn().mockImplementation(async (cid: string) => {
      mockPinnedCids.delete(cid);
      return undefined;
    }),
    ls: jest.fn().mockImplementation(function* () {
      for (const cid of mockPinnedCids) {
        yield { cid: { toString: () => cid } };
      }
    })
  },

  id: jest.fn().mockResolvedValue({ id: 'test-node' }),

  stats: {
    repo: jest.fn().mockResolvedValue({
      repoSize: 1000,
      storageMax: 10000,
      numObjects: mockDataStore.size
    })
  },

  stop: jest.fn().mockResolvedValue(undefined),
  getEndpointConfig: jest.fn().mockReturnValue('http://localhost:5001')
};

// Create a store for record metadata
export const mockRecordStore = new Map<string, any>();

// Override the add method to store both content and record metadata
mockIPFSClient.add = jest.fn().mockImplementation(async (data: any) => {
  const cid = `QmTest${Math.random().toString(36).substring(7)}`;
  // Store the data as a string, just like the real IPFS client
  const stringData = typeof data === 'string' ? data : JSON.stringify(data);
  mockDataStore.set(cid, stringData);
  return { path: cid };
});

export const create = jest.fn(() => mockIPFSClient);
export type { IPFSHTTPClient } from 'ipfs-http-client';

================
File: src/__tests__/encryption.test.ts
================
import { EncryptionService } from '../encryption';

describe('EncryptionService', () => {
  let encryption: EncryptionService;

  beforeEach(() => {
    encryption = new EncryptionService();
  });

  describe('encrypt and decrypt', () => {
    it('should successfully encrypt and decrypt data', async () => {
      const plaintext = 'Hello, World!';
      const encrypted = await encryption.encrypt(plaintext);
      const decrypted = await encryption.decrypt(encrypted);
      expect(decrypted).toBe(plaintext);
    });

    it('should handle empty strings', async () => {
      const plaintext = '';
      const encrypted = await encryption.encrypt(plaintext);
      const decrypted = await encryption.decrypt(encrypted);
      expect(decrypted).toBe(plaintext);
    });

    it('should handle long strings', async () => {
      const plaintext = 'a'.repeat(1000);
      const encrypted = await encryption.encrypt(plaintext);
      const decrypted = await encryption.decrypt(encrypted);
      expect(decrypted).toBe(plaintext);
    });

    it('should handle special characters', async () => {
      const plaintext = '!@#$%^&*()_+-=[]{}|;:,.<>?';
      const encrypted = await encryption.encrypt(plaintext);
      const decrypted = await encryption.decrypt(encrypted);
      expect(decrypted).toBe(plaintext);
    });

    it('should handle unicode characters', async () => {
      const plaintext = '你好，世界！🌍';
      const encrypted = await encryption.encrypt(plaintext);
      const decrypted = await encryption.decrypt(encrypted);
      expect(decrypted).toBe(plaintext);
    });

    it('should handle JSON strings', async () => {
      const data = { hello: 'world', num: 42, arr: [1, 2, 3] };
      const plaintext = JSON.stringify(data);
      const encrypted = await encryption.encrypt(plaintext);
      const decrypted = await encryption.decrypt(encrypted);
      expect(decrypted).toBe(plaintext);
    });

    it('should handle different encryption methods', async () => {
      const plaintext = 'Test different methods';
      const encrypted = await encryption.encrypt(plaintext, 'AES-GCM');
      const decrypted = await encryption.decrypt(encrypted, 'AES-GCM');
      expect(decrypted).toBe(plaintext);
    });

    it('should handle different key references', async () => {
      const plaintext = 'Test different keys';
      const keyRef = 'customKey';
      const encrypted = await encryption.encrypt(plaintext, 'AES-GCM', keyRef);
      const decrypted = await encryption.decrypt(encrypted, 'AES-GCM', keyRef);
      expect(decrypted).toBe(plaintext);
    });
  });

  describe('key management', () => {
    it('should export and import keys', async () => {
      const keyRef = 'testKey';
      const plaintext = 'Test export/import';
      
      // Encrypt with original key
      const encrypted = await encryption.encrypt(plaintext, 'AES-GCM', keyRef);
      
      // Export the key
      const exportedKey = await encryption.exportKey(keyRef);
      
      // Create new encryption service
      const newEncryption = new EncryptionService();
      
      // Import the key
      await newEncryption.importKey(exportedKey, 'AES-GCM', keyRef);
      
      // Decrypt with imported key
      const decrypted = await newEncryption.decrypt(encrypted, 'AES-GCM', keyRef);
      expect(decrypted).toBe(plaintext);
    });

    it('should handle multiple keys', async () => {
      const plaintext = 'test';
      const encrypted1 = await encryption.encrypt(plaintext, 'AES-GCM', 'key1', true);
      const encrypted2 = await encryption.encrypt(plaintext, 'AES-GCM', 'key2', true);
      
      const decrypted1 = await encryption.decrypt(encrypted1, 'AES-GCM', 'key1');
      const decrypted2 = await encryption.decrypt(encrypted2, 'AES-GCM', 'key2');
      
      expect(decrypted1).toBe(plaintext);
      expect(decrypted2).toBe(plaintext);
      expect(encrypted1).not.toBe(encrypted2);
    });

    it.skip('should clear keys correctly', async () => {
      const plaintext = 'test';
      const keyRef = 'testKey';
      
      const encrypted = await encryption.encrypt(plaintext, 'AES-GCM', keyRef, true);
      encryption.clearKeys();
      const encrypted2 = await encryption.encrypt(plaintext, 'AES-GCM', keyRef, true);
      
      expect(encrypted).not.toBe(encrypted2);
    });
  });

  describe('error handling', () => {
    it('should throw error for invalid encryption method', async () => {
      await expect(encryption.encrypt('test', 'INVALID')).rejects.toThrow();
    });

    it('should throw error for invalid ciphertext', async () => {
      await expect(encryption.decrypt('invalid-base64!')).rejects.toThrow();
    });

    it('should throw error for tampered ciphertext', async () => {
      const encrypted = await encryption.encrypt('test');
      const tampered = encrypted.slice(0, -5) + 'XXXXX'; // Modify the end
      await expect(encryption.decrypt(tampered)).rejects.toThrow();
    });

    it('should throw error for wrong key', async () => {
      const encrypted = await encryption.encrypt('test', 'AES-GCM', 'key1');
      await expect(encryption.decrypt(encrypted, 'AES-GCM', 'key2')).rejects.toThrow();
    });

    it('should throw error for invalid key export reference', async () => {
      await expect(encryption.exportKey('nonexistent-key')).rejects.toThrow();
    });

    it('should throw error for invalid key import data', async () => {
      const invalidKey = { k: 'invalid-key-data' };
      await expect(encryption.importKey(invalidKey)).rejects.toThrow();
    });

    it('should handle encryption info extraction errors', () => {
      const result = encryption.getEncryptionInfo('not-encrypted-data');
      expect(result).toBeNull();
    });

    it('should handle malformed encryption info', () => {
      const malformed = Buffer.from('{"invalid":"json').toString('base64');
      const result = encryption.getEncryptionInfo(`encrypted:${malformed}`);
      expect(result).toBeNull();
    });
  });
});

================
File: src/__tests__/ipfsClient.test.ts
================
import { IpfsClient } from '../ipfsClient';
import { PipeRecord } from '../types';
import { mockDataStore, mockPinnedCids } from './mocks/ipfs-http-client';

describe('IpfsClient', () => {
  let ipfsClient: IpfsClient;

  beforeEach(async () => {
    mockDataStore.clear();
    mockPinnedCids.clear();
    ipfsClient = new IpfsClient({
      endpoint: 'http://localhost:5001'
    });
    await ipfsClient.init('http://localhost:5001', 'http://localhost:5001');
  });

  afterEach(async () => {
    await ipfsClient.stop();
  });

  describe('publish and fetch', () => {
    it('should successfully publish and fetch data', async () => {
      const record: PipeRecord = {
        content: 'test data',
        type: 'data' as const,
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      };

      const published = await ipfsClient.publish(record);
      expect(published.cid).toBeDefined();

      const fetched = await ipfsClient.fetch(published.cid!, 'private');
      expect(fetched).toBeDefined();
      expect(fetched?.content).toBe('test data');
    });

    it('should handle JSON data', async () => {
      const data = { message: 'Hello, World!' };
      const record: PipeRecord = {
        content: data,
        type: 'data' as const,
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      };

      const published = await ipfsClient.publish(record);
      expect(published.cid).toBeDefined();

      const fetched = await ipfsClient.fetch(published.cid!, 'private');
      expect(fetched).toBeDefined();
      expect(fetched?.content).toEqual(data);
    });

    it('should handle different scopes', async () => {
      const record: PipeRecord = {
        content: 'test data',
        type: 'data' as const,
        scope: 'public' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      };

      const published = await ipfsClient.publish(record);
      expect(published.cid).toBeDefined();

      const fetched = await ipfsClient.fetch(published.cid!, 'public');
      expect(fetched).toBeDefined();
      expect(fetched?.content).toBe('test data');
    });
  });

  describe('pin management', () => {
    it('should pin and unpin content', async () => {
      const record: PipeRecord = {
        content: 'test data',
        type: 'data' as const,
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      };

      const published = await ipfsClient.publish(record);
      await ipfsClient.pin(published.cid!, 'private');

      const pinnedCids = await ipfsClient.getPinnedCids('private');
      expect(pinnedCids).toContain(published.cid);

      await ipfsClient.unpin(published.cid!, 'private');
      const updatedPinnedCids = await ipfsClient.getPinnedCids('private');
      expect(updatedPinnedCids).not.toContain(published.cid);
    });
  });

  describe('replication', () => {
    it('should replicate content between scopes', async () => {
      const record: PipeRecord = {
        content: 'test data',
        type: 'data' as const,
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      };

      const published = await ipfsClient.publish(record);
      await ipfsClient.replicate(published.cid!, 'private', 'public');

      const fetched = await ipfsClient.fetch(published.cid!, 'public');
      expect(fetched).toBeDefined();
      expect(fetched?.content).toBe('test data');
    });
  });

  describe('node management', () => {
    it('should return node status', () => {
      const status = ipfsClient.getStatus();
      expect(status).toBe(true);
    });

    it('should return node info', async () => {
      const info = await ipfsClient.getNodeInfo('private');
      expect(info).toBeDefined();
      expect(info.id).toBe('test-node');
    });

    it('should return storage metrics', async () => {
      const metrics = await ipfsClient.getStorageMetrics('private');
      expect(metrics).toBeDefined();
      expect(metrics.repoSize).toBe(1000);
      expect(metrics.storageMax).toBe(10000);
      expect(metrics.numObjects).toBe(0); // Should be 0 since we clear the store before each test
    });

    it('should return node configuration', async () => {
      const config = await ipfsClient.getConfiguration('private');
      expect(config).toBeDefined();
      expect(config.endpoint).toBe('http://localhost:5001');
    });
  });

  describe('error handling', () => {
    it('should handle non-existent CID', async () => {
      const result = await ipfsClient.fetch('QmNonExistent', 'private');
      expect(result).toBeNull();
    });

    it('should handle invalid scope', async () => {
      const record: PipeRecord = {
        content: 'test data',
        type: 'data' as const,
        scope: 'invalid' as any,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      };

      await expect(ipfsClient.publish(record)).rejects.toThrow();
    });

    it('should handle stop and restart', async () => {
      await ipfsClient.stop();
      expect(ipfsClient.getStatus()).toBe(false);

      await ipfsClient.init('http://localhost:5001', 'http://localhost:5001');
      expect(ipfsClient.getStatus()).toBe(true);
    });
  });
});

================
File: src/__tests__/pipe.test.ts
================
import { PipeProtocol } from '../pipe';
import { Tool } from '../types';
import { mockDataStore } from './mocks/ipfs-http-client';

describe('PipeProtocol', () => {
  let pipe: PipeProtocol;

  beforeEach(() => {
    mockDataStore.clear();
    pipe = new PipeProtocol({
      localNodeEndpoint: 'http://localhost:5001',
      publicNodeEndpoint: 'http://localhost:5001'
    });
  });

  afterEach(async () => {
    await pipe.stop();
  });

  describe('data storage', () => {
    it('should store and retrieve data', async () => {
      const data = { message: 'Hello, World!' };
      const { cid } = await pipe.storeData(data);
      expect(cid).toBeDefined();

      const record = await pipe.fetchRecord(cid, 'private');
      expect(record).toBeDefined();
      expect(record?.content).toEqual(data);
    });

    it('should generate schema when storing data', async () => {
      const data = {
        name: 'John Doe',
        age: 30,
        email: 'john@example.com'
      };

      const { cid, schemaCid } = await pipe.storeData(data);
      expect(cid).toBeDefined();
      expect(schemaCid).toBeDefined();

      const schemaRecord = await pipe.fetchRecord(schemaCid!, 'private');
      expect(schemaRecord).toBeDefined();
      expect(schemaRecord?.content).toMatchObject({
        $schema: 'http://json-schema.org/draft-07/schema#',
        type: 'object',
        properties: {
          name: { type: 'string' },
          age: { type: 'number' },
          email: { type: 'string' }
        }
      });
    });

    it('should handle storing data without schema', async () => {
      const data = { message: 'No Schema' };
      const { cid, schemaCid } = await pipe.storeData(data, { generateSchema: false });
      expect(cid).toBeDefined();
      expect(schemaCid).toBeNull();
    });
  });

  describe('record management', () => {
    it('should publish and fetch records', async () => {
      const record = {
        content: { message: 'Test Record' },
        type: 'data' as const,
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      };

      const published = await pipe.publishRecord(record);
      expect(published.cid).toBeDefined();

      const fetched = await pipe.fetchRecord(published.cid!, 'private');
      expect(fetched).toBeDefined();
      expect(fetched?.content).toEqual(record.content);
    });

    it('should handle encrypted records', async () => {
      const record = {
        content: { message: 'Secret Data' },
        type: 'data' as const,
        scope: 'private' as const,
        accessPolicy: { hiddenFromLLM: false },
        encryption: { 
          enabled: true,
          keyRef: 'test-key',
          method: 'AES-GCM'
        }
      };

      const published = await pipe.publishRecord(record);
      expect(published.cid).toBeDefined();
      expect(published.encryption.ciphertext).toBe(true);

      const fetched = await pipe.fetchRecord(published.cid!, 'private');
      expect(fetched).toBeDefined();
      expect(fetched?.content).toEqual(record.content);
      expect(fetched?.encryption.ciphertext).toBe(false);
    });
  });

  describe('bundle management', () => {
    it('should publish and fetch bundles', async () => {
      const bundle = {
        schemaRecord: {
          content: {
            $schema: 'http://json-schema.org/draft-07/schema#',
            type: 'object',
            properties: {
              message: { type: 'string' }
            }
          },
          type: 'schema' as const,
          scope: 'private' as const,
          accessPolicy: { hiddenFromLLM: false },
          encryption: { enabled: false }
        },
        dataRecord: {
          content: { message: 'Test Bundle' },
          type: 'data' as const,
          scope: 'private' as const,
          accessPolicy: { hiddenFromLLM: false },
          encryption: { enabled: false }
        }
      };

      const published = await pipe.publishBundle(bundle);
      expect(published.schemaRecord.cid).toBeDefined();
      expect(published.dataRecord.cid).toBeDefined();
      expect(published.timestamp).toBeDefined();

      const fetchedSchema = await pipe.fetchRecord(published.schemaRecord.cid!, 'private');
      const fetchedData = await pipe.fetchRecord(published.dataRecord.cid!, 'private');

      expect(fetchedSchema?.content).toEqual(bundle.schemaRecord.content);
      expect(fetchedData?.content).toEqual(bundle.dataRecord.content);
    });
  });

  describe('tool wrapping', () => {
    it('should wrap tools and store their results', async () => {
      const mockTool: Tool = {
        name: 'testTool',
        description: 'A test tool',
        parameters: {
          type: 'object',
          properties: {
            input: { type: 'string' }
          }
        },
        call: async (args: any) => ({ result: args.input })
      };

      const wrappedTools = pipe.wrap([mockTool]);
      expect(wrappedTools).toHaveLength(1);

      const result = await wrappedTools[0].execute({ input: 'test' });
      expect(result.cid).toBeDefined();
      expect(result.schemaCid).toBeDefined();
      expect(result.description).toBe(mockTool.description);

      const storedResult = await pipe.fetchRecord(result.cid, 'private');
      expect(storedResult?.content).toEqual({ result: 'test' });
    });

    it('should handle tool execution with custom options', async () => {
      const mockTool: Tool = {
        name: 'testTool',
        description: 'A test tool',
        parameters: {
          type: 'object',
          properties: {
            input: { type: 'string' }
          }
        },
        call: async (args: any) => ({ result: args.input })
      };

      const wrappedTools = pipe.wrap([mockTool]);
      const result = await wrappedTools[0].execute({
        input: 'test',
        pipeOptions: {
          scope: 'public',
          generateSchema: false,
          pin: true
        }
      });

      expect(result.cid).toBeDefined();
      expect(result.schemaCid).toBeNull();

      const storedResult = await pipe.fetchRecord(result.cid, 'public');
      expect(storedResult?.content).toEqual({ result: 'test' });
    });
  });

  describe('hooks', () => {
    it('should process pre-store hooks', async () => {
      const hook = {
        name: 'testHook',
        trigger: 'pre-store' as const,
        handler: async (data: any) => ({
          ...data,
          processed: true
        })
      };

      pipe.addHook(hook);
      const { cid } = await pipe.storeData({ message: 'Test' });
      const record = await pipe.fetchRecord(cid, 'private');
      expect(record?.content).toHaveProperty('processed', true);
    });

    it('should process post-store hooks', async () => {
      let hookCalled = false;
      const hook = {
        name: 'testHook',
        trigger: 'post-store' as const,
        handler: async (data: any) => {
          hookCalled = true;
          return data;
        }
      };

      pipe.addHook(hook);
      await pipe.storeData({ message: 'Test' });
      expect(hookCalled).toBe(true);
    });
  });
});

================
File: src/__tests__/setup.ts
================
// Increase timeout for IPFS operations
jest.setTimeout(10000);

// Mock crypto for consistent test results
const mockRandomValues = new Uint8Array([
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
]);

const originalCrypto = global.crypto;
global.crypto = {
  ...originalCrypto,
  getRandomValues: <T extends ArrayBufferView | null>(array: T): T => {
    if (array instanceof Uint8Array) {
      array.set(mockRandomValues.subarray(0, array.length));
    }
    return array;
  }
};

// Clean up function to restore original crypto
afterAll(() => {
  global.crypto = originalCrypto;
});

================
File: src/tests/pipe.test.ts
================
import { PipeProtocol } from '../pipe.js';
import { PipeOptions } from '../pipe';
import { pipe } from '../index';
import { createApi } from '../api';
import { PipeRecord, PipeBundle, Scope } from '../types.js';
import { AddressInfo } from 'net';
import { Server } from 'http';
import { expect, describe, test, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';

interface NodeStatus {
  localNode: boolean;
  publicNode: boolean;
}

interface NodeInfo {
  peerId: string;
}

interface StorageMetrics {
  repoSize: number;
}

interface NodeConfig {
  peerId: string;
  addrs: string[];
}

interface PublishResponse {
  cid: string;
}

interface FetchResponse {
  content: any;
}

interface StatusResponse extends NodeStatus {}
interface InfoResponse extends NodeInfo {}
interface MetricsResponse extends StorageMetrics {}
interface ConfigResponse extends NodeConfig {}
interface PinnedResponse extends Array<string> {}

const mockRecord: PipeRecord = {
  type: 'data',
  content: { test: 'data' },
  scope: 'private' as Scope,
  accessPolicy: { hiddenFromLLM: false },
  encryption: { enabled: false },
  pinned: true
};

const mockBundle: PipeBundle = {
  schemaRecord: {
    type: 'schema',
    content: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        age: { type: 'number' }
      },
      required: ['name', 'age']
    },
    scope: 'private' as Scope,
    accessPolicy: { hiddenFromLLM: false },
    encryption: { enabled: false },
    pinned: true
  },
  dataRecord: {
    type: 'data',
    content: {
      name: 'John Doe',
      age: 30
    },
    scope: 'private' as Scope,
    accessPolicy: { hiddenFromLLM: false },
    encryption: { enabled: false },
    pinned: true
  },
  combinedScope: 'private',
  timestamp: new Date().toISOString()
};

describe('PipeProtocol', () => {
  let pipe: PipeProtocol;
  
  beforeEach(() => {
    pipe = new PipeProtocol({});
  });

  afterEach(async () => {
    await pipe.stop();
  });

  test('should publish and fetch a record', async () => {
    const published = await pipe.publishRecord(mockRecord);
    expect(published.cid).toBeDefined();

    if (published.cid) {
      const fetched = await pipe.fetchRecord(published.cid, 'private');
      expect(fetched?.content).toEqual(mockRecord.content);
    }
  });

  test('should get node status', async () => {
    const status = await pipe.getStatus() as NodeStatus;
    expect(status).toEqual({
      localNode: true,
      publicNode: false
    });
  });

  test('should get node info', async () => {
    const info = await pipe.getNodeInfo('private') as NodeInfo;
    expect(info).toEqual({
      peerId: expect.any(String)
    });
  });

  test('should get storage metrics', async () => {
    const metrics = await pipe.getStorageMetrics('private') as StorageMetrics;
    expect(metrics).toEqual({
      repoSize: 0
    });
  });

  test('should get configuration', async () => {
    const config = await pipe.getConfiguration('private') as NodeConfig;
    expect(config).toEqual({
      peerId: expect.any(String),
      addrs: []
    });
  });
});

describe('Pipe Core Functionality', () => {
  let pipeProtocol: PipeProtocol;
  let server: Server;
  let port: number;

  beforeAll(async () => {
    const options: PipeOptions = {
      publicNodeEndpoint: 'https://ipfs.infura.io:5001'
    };
    pipeProtocol = new PipeProtocol(options);
    const app = createApi(pipeProtocol);
    server = app.listen(0);
    port = (server.address() as AddressInfo).port;
  });

  afterAll(async() => {
    server.close();
    await pipeProtocol.stop();
  });

  test('Tool Wrapping', () => {
    const tools = [{
      name: 'weatherTool',
      description: 'Get weather data',
      call: () => 'Sunny'
    }];

    const wrapped = pipe(tools);
    const pipeTool = wrapped.find(t => t.name === 'Pipe');
    expect(pipeTool).toBeDefined();
  });

  test('Should publish a record and return a cid', async () => {
    const record = await pipeProtocol.publishRecord(mockRecord);
    expect(record.cid).toBeDefined();
  });

  test('Should publish a record and then fetch it', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    const fetched = await pipeProtocol.fetchRecord(published.cid || '', 'private');
    expect(fetched?.content).toEqual(mockRecord.content);
  });

  test('Should publish a bundle and return two cids', async () => {
    const bundle = await pipeProtocol.publishBundle(mockBundle);
    expect(bundle.dataRecord.cid).toBeDefined();
    expect(bundle.schemaRecord.cid).toBeDefined();
  });

  test('Should pin a record', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    await pipeProtocol.pin(published.cid || '', 'private');
  });

  test('Should unpin a record', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    await pipeProtocol.unpin(published.cid || '', 'private');
  });

  test('Should replicate a record', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    await pipeProtocol.replicate(published.cid || '', 'private', 'public');
  });

  test('Should get node status', async () => {
    const status = await pipeProtocol.getStatus() as NodeStatus;
    expect(status.localNode).toBe(true);
    expect(status.publicNode).toBe(true);
  });

  test('Should get node info', async () => {
    const info = await pipeProtocol.getNodeInfo('private') as NodeInfo;
    expect(info.peerId).toBeDefined();
  });

  test('Should be able to post a record to the api and return a record', async () => {
    const response = await fetch(`http://localhost:${port}/publish`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(mockRecord)
    });
    const data = await response.json() as PublishResponse;
    expect(data.cid).toBeDefined();
  });

  test('Should be able to get a record from the api', async () => {
    const published = await pipeProtocol.publishRecord(mockRecord);
    const response = await fetch(`http://localhost:${port}/fetch?cid=${published.cid}&scope=private`);
    const data = await response.json() as FetchResponse;
    expect(data.content).toEqual(mockRecord.content);
  });

  test('Should be able to get the node status from the api', async () => {
    const response = await fetch(`http://localhost:${port}/node-status`);
    const status = await response.json() as StatusResponse;
    expect(status.localNode).toBe(true);
    expect(status.publicNode).toBe(true);
  });

  test('Should be able to get the node info from the api', async () => {
    const response = await fetch(`http://localhost:${port}/node-info?scope=private`);
    const info = await response.json() as InfoResponse;
    expect(info.peerId).toBeDefined();
  });

  test('Should be able to get storage metrics from the api', async () => {
    const response = await fetch(`http://localhost:${port}/storage-metrics?scope=private`);
    const metrics = await response.json() as MetricsResponse;
    expect(metrics.repoSize).toBeDefined();
  });

  test('Should be able to get the pinned CIDs from the api', async () => {
    const record = await pipeProtocol.publishRecord(mockRecord);
    await pipeProtocol.pin(record.cid || '', 'private');
    const response = await fetch(`http://localhost:${port}/pinned-cids?scope=private`);
    const pins = await response.json() as PinnedResponse;
    expect(pins).toContain(record.cid);
  });

  test('Should be able to get the configuration from the api', async () => {
    const response = await fetch(`http://localhost:${port}/configuration?scope=private`);
    const config = await response.json() as ConfigResponse;
    expect(config.peerId).toBeDefined();
    expect(config.addrs).toBeDefined();
  });
});

================
File: src/types/index.ts
================
export type Scope = 'private' | 'public' | 'machine' | 'user';

export interface EncryptionInfo {
  enabled: boolean;
  method?: string;
  keyRef?: string;
  ciphertext?: boolean;
}

export interface AccessPolicy {
  hiddenFromLLM: boolean;
  allowedTools?: string[];
}

export interface PipeRecord {
  type: 'data' | 'schema';
  content: any;
  scope: Scope;
  cid?: string;
  pinned?: boolean;
  encryption?: EncryptionInfo;
  accessPolicy?: AccessPolicy;
  metadata?: Record<string, any>;
  timestamp?: string;
}

export interface PipeBundle {
  schemaRecord: PipeRecord;
  dataRecord: PipeRecord;
  combinedScope: Scope;
  timestamp?: string;
}

export interface PipeConfig {
  ipfsEndpoint?: string;
  defaultScope?: Scope;
  autoPin?: boolean;
  hooks?: PipeHook[];
}

export interface PipeHook {
  name: string;
  handler: (data: any, metadata: Record<string, any>) => Promise<any>;
  trigger: 'pre-store' | 'post-store';
}

export interface StoreOptions {
  scope?: Scope;
  pin?: boolean;
  generateSchema?: boolean;
}

export interface Tool {
  name: string;
  description: string;
  call: (...args: any[]) => any;
  parameters?: any;
  returns?: any;
}

export interface PipeTool {
  name: string;
  description: string;
  call: (method: string, args: any) => Promise<PipeRecord | PipeBundle | null | void>;
}

================
File: src/utils/index.ts
================
/**
 * Generates a summary of the provided data
 * @param data Any data to be summarized
 * @returns A string summary of the data
 */
export async function generateSummary(data: any): Promise<string> {
  try {
    // Convert data to string if it's not already
    const stringData = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    
    // For now, return a simple summary
    // In a production environment, this could use an LLM or other summarization technique
    const summary = `Data of type ${typeof data}, length: ${stringData.length} characters`;
    
    return summary;
  } catch (error) {
    console.error('Error generating summary:', error);
    return 'Error generating summary';
  }
}

/**
 * Validates a scope value
 * @param scope The scope to validate
 * @returns boolean indicating if the scope is valid
 */
export function isValidScope(scope: any): boolean {
  return ['private', 'public', 'machine', 'user'].includes(scope);
}

/**
 * Deep clones an object
 * @param obj The object to clone
 * @returns A deep clone of the object
 */
export function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Generates a timestamp in ISO format
 * @returns Current timestamp in ISO format
 */
export function generateTimestamp(): string {
  return new Date().toISOString();
}

/**
 * Validates a CID string
 * @param cid The CID to validate
 * @returns boolean indicating if the CID is valid
 */
export function isValidCID(cid: string): boolean {
  // Basic validation - could be enhanced with actual CID validation logic
  return typeof cid === 'string' && cid.length > 0;
}

/**
 * Formats error messages
 * @param message The error message
 * @param code Optional error code
 * @returns Formatted error message
 */
export function formatError(message: string, code?: string): string {
  return code ? `[${code}] ${message}` : message;
}

================
File: src/api.ts
================
import express from 'express';
import { PipeProtocol } from './pipe';
import { PipeRecord, PipeBundle, Scope } from './types';

export function createPipeAPI(pipe: PipeProtocol) {
  const app = express();
  app.use(express.json());

  app.post('/publish', async (req, res) => {
    try {
      const record: PipeRecord = req.body;
      const published = await pipe.publishRecord(record);
      res.json(published);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.post('/publish-bundle', async (req, res) => {
    try {
      const bundle: PipeBundle = req.body;
      const published = await pipe.publishBundle(bundle);
      res.json(published);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.get('/fetch', async (req, res) => {
    try {
      const { cid, scope } = req.query;
      if (!cid || !scope) {
        return res.status(400).json({ error: 'Missing cid or scope parameter' });
      }
      const record = await pipe.fetchRecord(cid as string, scope as Scope);
      res.json(record);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.post('/pin', async (req, res) => {
    try {
      const { cid, scope } = req.body;
      if (!cid || !scope) {
        return res.status(400).json({ error: 'Missing cid or scope parameter' });
      }
      await pipe.pin(cid, scope as Scope);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.post('/unpin', async (req, res) => {
    try {
      const { cid, scope } = req.body;
      if (!cid || !scope) {
        return res.status(400).json({ error: 'Missing cid or scope parameter' });
      }
      await pipe.unpin(cid, scope as Scope);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.post('/replicate', async (req, res) => {
    try {
      const { cid, fromScope, toScope } = req.body;
      if (!cid || !fromScope || !toScope) {
        return res.status(400).json({ error: 'Missing required parameters' });
      }
      await pipe.replicate(cid, fromScope as Scope, toScope as Scope);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.get('/node-status', async (_req, res) => {
    try {
      const status = await pipe.getStatus();
      res.json(status);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.get('/node-info', async (req, res) => {
    try {
      const { scope } = req.query;
      if (!scope) {
        return res.status(400).json({ error: 'Missing scope parameter' });
      }
      const info = await pipe.getNodeInfo(scope as Scope);
      res.json(info);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.get('/storage-metrics', async (req, res) => {
    try {
      const { scope } = req.query;
      if (!scope) {
        return res.status(400).json({ error: 'Missing scope parameter' });
      }
      const metrics = await pipe.getStorageMetrics(scope as Scope);
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.get('/pinned-cids', async(req, res) => {
    try {
      const { scope } = req.query;
      if (!scope) {
        return res.status(400).json({ error: 'Missing scope parameter' });
      }
      const cids = await pipe.getPinnedCids(scope as Scope);
      res.json(cids);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.get('/configuration', async (req, res) => {
    try {
      const { scope } = req.query;
      if (!scope) {
        return res.status(400).json({ error: 'Missing scope parameter' });
      }
      const config = await pipe.getConfiguration(scope as Scope);
      res.json(config);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  return app;
}

================
File: src/encryption.ts
================
/// <reference lib="dom" />
import { webcrypto } from 'node:crypto';
import { TextEncoder, TextDecoder } from 'util';
const { subtle } = webcrypto;

// Add type imports from lib.dom.d.ts
type CryptoKey = webcrypto.CryptoKey;
type JsonWebKey = webcrypto.JsonWebKey;

export class EncryptionService {
  private keyCache: Map<string, CryptoKey>;
  private encoder: TextEncoder;
  private decoder: TextDecoder;
  private readonly IV_LENGTH = 12;

  constructor() {
    this.keyCache = new Map();
    this.encoder = new TextEncoder();
    this.decoder = new TextDecoder();
  }

  private async generateKey(method: string, keyRef: string, isTest: boolean = false): Promise<CryptoKey> {
    if (method !== 'AES-GCM') {
      throw new Error('Unsupported encryption method: ' + method);
    }

    // Generate a 32-byte key (256 bits)
    const seed = new Uint8Array(32);
    if (isTest) {
      // In test mode, use a deterministic seed based on keyRef and timestamp
      const timestamp = Date.now().toString();
      const keyBytes = this.encoder.encode(keyRef + timestamp);
      const hash = new Uint32Array(8); // 32 bytes / 4 bytes per uint32
      
      // Simple hash function to distribute keyRef bytes across the seed
      for (let i = 0; i < keyBytes.length; i++) {
        const pos = i % 8;
        hash[pos] = ((hash[pos] << 5) - hash[pos]) + keyBytes[i];
      }
      
      // Fill seed with hash values
      const hashBytes = new Uint8Array(hash.buffer);
      for (let i = 0; i < 32; i++) {
        seed[i] = hashBytes[i % hashBytes.length];
      }
    } else {
      // In production, use random values
      webcrypto.getRandomValues(seed);
    }
    
    return subtle.importKey(
      'raw',
      seed,
      {
        name: method,
        length: 256
      },
      true,
      ['encrypt', 'decrypt']
    );
  }

  private async getKey(method: string, keyRef: string, isTest: boolean = false): Promise<CryptoKey> {
    const keyId = `${method}:${keyRef}`;
    let key = this.keyCache.get(keyId);
    
    if (!key) {
      key = await this.generateKey(method, keyRef, isTest);
      this.keyCache.set(keyId, key);
    }
    
    return key;
  }

  async encrypt(plaintext: string, method: string = 'AES-GCM', keyRef: string = 'defaultKey', isTest: boolean = false): Promise<string> {
    try {
      const key = await this.getKey(method, keyRef, isTest);
      let iv: Uint8Array;
      
      if (isTest) {
        // In test mode, use a deterministic IV based on both keyRef and plaintext
        const keyBytes = this.encoder.encode(keyRef);
        const textBytes = this.encoder.encode(plaintext);
        iv = new Uint8Array(this.IV_LENGTH);
        
        // Mix keyRef and plaintext bytes to create IV
        for (let i = 0; i < this.IV_LENGTH; i++) {
          iv[i] = (
            (i < keyBytes.length ? keyBytes[i] : 0) ^
            (i < textBytes.length ? textBytes[i] : 0)
          ) % 256;
        }
      } else {
        iv = webcrypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
      }

      const algorithm = {
        name: method,
        iv
      };
      const encodedData = this.encoder.encode(plaintext);
      
      const encryptedData = await subtle.encrypt(
        algorithm,
        key,
        encodedData
      );

      // Convert ArrayBuffer to Uint8Array for manipulation
      const encryptedArray = new Uint8Array(encryptedData);
      
      // Create combined array with space for both IV and encrypted data
      const combined = new Uint8Array(this.IV_LENGTH + encryptedArray.byteLength);
      
      // Copy IV and encrypted data into combined array
      combined.set(iv, 0);
      combined.set(encryptedArray, this.IV_LENGTH);
      
      // Convert to base64 for storage/transmission
      return Buffer.from(combined).toString('base64');
    } catch (error) {
      console.error('Encryption error:', error);
      throw new Error('Failed to encrypt data');
    }
  }

  async decrypt(
    ciphertext: string,
    method: string = 'AES-GCM',
    keyRef: string = 'defaultKey',
    isTest: boolean = false
  ): Promise<string> {
    try {
      const key = await this.getKey(method, keyRef, isTest);
      if (!key) {
        throw new Error('No key available for decryption');
      }

      const data = Buffer.from(ciphertext, 'base64');
      const iv = data.subarray(0, this.IV_LENGTH);
      const encryptedData = data.subarray(this.IV_LENGTH);

      const decryptedData = await subtle.decrypt(
        {
          name: method,
          iv
        },
        key,
        encryptedData
      );

      return this.decoder.decode(new Uint8Array(decryptedData));
    } catch (error) {
      console.error('Decryption error:', error);
      throw new Error('Failed to decrypt data');
    }
  }

  async exportKey(keyRef: string, method: string = 'AES-GCM'): Promise<JsonWebKey> {
    const keyId = `${method}:${keyRef}`;
    const key = this.keyCache.get(keyId);
    if (!key) {
      throw new Error(`Key not found: ${keyRef}`);
    }
    return subtle.exportKey('jwk', key);
  }

  async importKey(jwk: JsonWebKey, method: string = 'AES-GCM', keyRef: string = 'defaultKey'): Promise<void> {
    try {
      const key = await subtle.importKey(
        'jwk',
        jwk,
        { name: method },
        true,
        ['encrypt', 'decrypt']
      );
      this.keyCache.set(`${method}:${keyRef}`, key);
    } catch (error) {
      throw new Error('Failed to import key');
    }
  }

  clearKeys(): void {
    this.keyCache.clear();
  }

  getEncryptionInfo(ciphertext: string): { method: string; keyRef: string } | null {
    if (!ciphertext.startsWith('encrypted:')) {
      return null;
    }
    
    try {
      const base64Data = ciphertext.slice(10); // Remove 'encrypted:' prefix
      const decryptedJson = Buffer.from(base64Data, 'base64').toString();
      const { method, keyRef } = JSON.parse(decryptedJson);
      return { method, keyRef };
    } catch (error) {
      console.warn('Failed to extract encryption info:', error);
      return null;
    }
  }
}

================
File: src/index.ts
================
import { PipeProtocol } from './pipe';
import { PipeRecord, PipeBundle, Scope } from './types';

interface Tool {
  name: string;
  description: string;
  call: (...args: any[]) => any;
}

interface PipeTool {
  name: string;
  description: string;
  call: (method: string, args: any) => Promise<PipeRecord | PipeBundle | null | void>;
}

export function pipe(tools: Tool[]): (Tool | PipeTool)[] {
  const pipeProtocol = new PipeProtocol();

  const pipeTool: PipeTool = {
    name: 'Pipe',
    description: `
      A special tool that allows referencing large data via IPFS.
      You can publish data or fetch data by CID.
      Example usage:
        - publishRecord({type, content, scope, pinned, encryption, accessPolicy})
        - fetchRecord(cid, scope)
        - publishBundle({schemaRecord, dataRecord, combinedScope})
        - pin(cid, scope)
        - unpin(cid, scope)
        - replicate(cid, fromScope, toScope)
        - getStatus()
        - getNodeInfo(scope)
        - getStorageMetrics(scope)
        - getPinnedCids(scope)
        - getConfiguration(scope)
      The LLM typically should not decrypt hidden data if hiddenFromLLM = true.
    `,
    call: async (method: string, args: any) => {
      switch (method) {
        case 'publishRecord':
          return pipeProtocol.publishRecord(args as PipeRecord);
        case 'fetchRecord':
          return pipeProtocol.fetchRecord(args.cid, args.scope as Scope);
        case 'publishBundle':
          return pipeProtocol.publishBundle(args as PipeBundle);
        case 'pin':
          return pipeProtocol.pin(args.cid, args.scope as Scope);
        case 'unpin':
          return pipeProtocol.unpin(args.cid, args.scope as Scope);
        case 'replicate':
          return pipeProtocol.replicate(args.cid, args.fromScope as Scope, args.toScope as Scope);
        case 'getStatus':
          return pipeProtocol.getStatus();
        case 'getNodeInfo':
          return pipeProtocol.getNodeInfo(args.scope as Scope);
        case 'getStorageMetrics':
          return pipeProtocol.getStorageMetrics(args.scope as Scope);
        case 'getPinnedCids':
          return pipeProtocol.getPinnedCids(args.scope as Scope);
        case 'getConfiguration':
          return pipeProtocol.getConfiguration(args.scope as Scope);
        default:
          throw new Error(`Unknown Pipe method: ${method}`);
      }
    },
  };

  return [...tools, pipeTool];
}

export { PipeProtocol };
export { IpfsClient } from './ipfsClient';
export { EncryptionService } from './encryption';
export * from './types';

// Export the example summary hook
export { summaryHook } from './pipe';

================
File: src/ipfsClient.ts
================
import { create, IPFSHTTPClient } from 'ipfs-http-client';
import { PipeRecord, Scope, PipeIpfsOptions } from './types';
import { config } from 'dotenv';
config();

export class IpfsClient {
  private localNode?: IPFSHTTPClient;
  private publicNode?: IPFSHTTPClient;
  private isRunning: boolean = false;

  constructor(config: PipeIpfsOptions = {}) {
    const { endpoint, options } = config;
    
    if (endpoint) {
      this.localNode = create({ url: endpoint, ...options });
      this.publicNode = create({ url: endpoint, ...options });
    }
  }

  public async init(localNodeEndpoint?: string, publicNodeEndpoint?: string): Promise<void> {
    if (localNodeEndpoint) {
      this.localNode = create({ url: localNodeEndpoint });
    }
    if (publicNodeEndpoint) {
      this.publicNode = create({ url: publicNodeEndpoint });
    }
    this.isRunning = true;

    // Test connections
    try {
      if (!this.localNode || !this.publicNode) {
        throw new Error('IPFS nodes not initialized');
      }
      await Promise.all([
        this.localNode.id(),
        this.publicNode.id()
      ]);
    } catch (error) {
      console.error('Failed to initialize IPFS nodes:', error);
      throw error;
    }
  }

  private getNodeForScope(scope: Scope): IPFSHTTPClient {
    if (!this.isRunning) {
      throw new Error('IPFS client is not running');
    }

    switch (scope) {
      case 'private':
      case 'machine':
        if (!this.localNode) throw new Error('Local node not initialized');
        return this.localNode;
      case 'public':
      case 'user':
        if (!this.publicNode) throw new Error('Public node not initialized');
        return this.publicNode;
      default:
        throw new Error(`Invalid scope: ${scope}`);
    }
  }

  async publish(record: PipeRecord): Promise<PipeRecord> {
    if (!this.isRunning) {
      throw new Error('IPFS client is not running');
    }

    const node = this.getNodeForScope(record.scope);
    
    try {
      // Store the entire record
      const result = await node.add(JSON.stringify(record));
      
      return {
        ...record,
        cid: result.path
      };
    } catch (error) {
      console.error('Error publishing to IPFS:', error);
      throw error;
    }
  }

  async fetch(cid: string, scope: Scope): Promise<PipeRecord | null> {
    if (!this.isRunning) {
      throw new Error('IPFS client is not running');
    }

    const node = this.getNodeForScope(scope);
    
    try {
      const chunks = [];
      for await (const chunk of node.cat(cid)) {
        chunks.push(chunk);
      }
      
      const rawContent = Buffer.concat(chunks).toString();
      let record: PipeRecord;
      
      try {
        record = JSON.parse(rawContent);
      } catch {
        // If we can't parse the content as a record, assume it's just the content
        record = {
          cid,
          content: rawContent,
          type: 'data',
          scope,
          accessPolicy: { hiddenFromLLM: false },
          encryption: { enabled: false }
        };
      }
      
      return record;
    } catch (error) {
      console.error('Error fetching from IPFS:', error);
      return null;
    }
  }

  async pin(cid: string, scope: Scope): Promise<void> {
    const node = this.getNodeForScope(scope);
    await node.pin.add(cid);
  }

  async unpin(cid: string, scope: Scope): Promise<void> {
    const node = this.getNodeForScope(scope);
    await node.pin.rm(cid);
  }

  async replicate(cid: string, fromScope: Scope, toScope: Scope): Promise<void> {
    const content = await this.fetch(cid, fromScope);
    if (!content) {
      throw new Error(`Content not found for CID: ${cid}`);
    }
    await this.publish({
      ...content,
      scope: toScope
    });
  }

  async stop(): Promise<void> {
    if (this.isRunning) {
      try {
        if (this.localNode) await this.localNode.stop();
        if (this.publicNode) await this.publicNode.stop();
        this.isRunning = false;
      } catch (error) {
        console.error('Error stopping IPFS client:', error);
        throw error;
      }
    }
  }

  getStatus(): boolean {
    return this.isRunning;
  }

  async getNodeInfo(scope: Scope): Promise<any> {
    const node = this.getNodeForScope(scope);
    return node.id();
  }

  async getStorageMetrics(scope: Scope): Promise<any> {
    const node = this.getNodeForScope(scope);
    const stats = await node.stats.repo();
    return {
      repoSize: stats.repoSize,
      storageMax: stats.storageMax,
      numObjects: stats.numObjects
    };
  }

  async getPinnedCids(scope: Scope): Promise<string[]> {
    const node = this.getNodeForScope(scope);
    const pins = node.pin.ls();
    const cids: string[] = [];
    
    for await (const pin of pins) {
      cids.push(pin.cid.toString());
    }
    
    return cids;
  }

  getConfiguration(scope: Scope): any {
    const node = this.getNodeForScope(scope);
    return {
      endpoint: node.getEndpointConfig(),
      scope
    };
  }
}

================
File: src/pipe.ts
================
import { IpfsClient } from './ipfsClient';
import { EncryptionService } from './encryption';
import { 
  PipeRecord, 
  PipeBundle, 
  Scope, 
  PipeHook,
  StoreOptions,
  Tool,
  PipeOptions,
  PipeIpfsOptions
} from './types';
import { generateSummary, generateTimestamp, deepClone } from './utils';

export class PipeProtocol {
  private ipfs: IpfsClient;
  private encryption: EncryptionService;
  private hooks: PipeHook[] = [];
  private currentTool: string | undefined;
  private initialized: Promise<void>;

  constructor(options: PipeOptions = {}) {
    try {
      this.encryption = new EncryptionService();
      
      // Map PipeOptions to PipeIpfsOptions
      const ipfsConfig: PipeIpfsOptions = {
        endpoint: options.localNodeEndpoint,
        options: {}
      };
      
      this.ipfs = new IpfsClient(ipfsConfig);
      this.hooks = options.hooks || [];
      this.initialized = this.init(options.localNodeEndpoint, options.publicNodeEndpoint).catch(error => {
        console.error('Error during IPFS initialization:', error);
        if (error instanceof Error) {
          console.error('Error stack:', error.stack);
        }
        throw error;
      });
    } catch (error) {
      console.error('Error during PipeProtocol initialization:', error);
      if (error instanceof Error) {
        console.error('Error stack:', error.stack);
      }
      throw error;
    }
  }

  private async init(localNodeEndpoint?: string, publicNodeEndpoint?: string) {
    await this.ipfs.init(localNodeEndpoint, publicNodeEndpoint);
  }

  async processHooks(trigger: 'pre-store' | 'post-store', data: any, metadata: Record<string, any>) {
    let processed = data;
    for (const hook of this.hooks) {
      if (hook.trigger === trigger) {
        processed = await hook.handler(processed, metadata);
      }
    }
    return processed;
  }

  addHook(hook: PipeHook) {
    this.hooks.push(hook);
  }

  async storeData(data: any, options: StoreOptions = {}) {
    await this.initialized;
    const generateSchema = options.generateSchema !== false;
    const schema = generateSchema ? this.generateSchema(data) : null;

    // Process pre-store hooks
    const processedData = await this.processHooks('pre-store', data, {
      tool: this.currentTool,
      timestamp: generateTimestamp()
    });

    const [dataCid, schemaCid] = await Promise.all([
      this.publishRecord({
        type: 'data',
        content: processedData,
        scope: options.scope || 'private',
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      }),
      schema ? this.publishRecord({
        type: 'schema',
        content: schema,
        scope: options.scope || 'private',
        accessPolicy: { hiddenFromLLM: false },
        encryption: { enabled: false }
      }) : Promise.resolve(null)
    ]);

    const result = {
      cid: dataCid.cid!,
      schemaCid: schemaCid ? schemaCid.cid : null,
      timestamp: generateTimestamp()
    };

    // Process post-store hooks
    await this.processHooks('post-store', result, {
      tool: this.currentTool,
      timestamp: generateTimestamp()
    });

    return result;
  }

  private generateSchema(data: any) {
    return {
      $schema: 'http://json-schema.org/draft-07/schema#',
      type: 'object',
      properties: Object.keys(data).reduce((acc, key) => {
        acc[key] = { type: typeof data[key] };
        return acc;
      }, {} as Record<string, any>)
    };
  }

  public async publishRecord(record: PipeRecord): Promise<PipeRecord> {
    await this.initialized;
    const validRecord = deepClone(record);

    if (validRecord.encryption?.enabled && !validRecord.encryption?.ciphertext && validRecord.content) {
      const method = validRecord.encryption?.method || 'AES-GCM';
      const keyRef = validRecord.encryption?.keyRef || 'defaultKey';
      const isJson = typeof validRecord.content !== 'string';

      // Always stringify content for encryption
      const plaintext = isJson ? JSON.stringify(validRecord.content) : validRecord.content;
        
      const encrypted = await this.encryption.encrypt(plaintext, method, keyRef, process.env.NODE_ENV === 'test');
      
      // Create a new record with encrypted content and updated encryption info
      const encryptedRecord = {
        ...validRecord,
        content: encrypted,
        encryption: {
          ...validRecord.encryption,
          enabled: true,
          ciphertext: true,
          method,
          keyRef,
          contentType: isJson ? 'json' as const : 'string' as const
        }
      };

      return this.ipfs.publish(encryptedRecord);
    }

    return this.ipfs.publish(validRecord);
  }

  public async publishBundle(bundle: PipeBundle): Promise<PipeBundle> {
    await this.initialized;
    const validBundle = deepClone(bundle);
    
    const publishedSchema = await this.publishRecord(validBundle.schemaRecord);
    const publishedData = await this.publishRecord(validBundle.dataRecord);

    return {
      ...validBundle,
      schemaRecord: publishedSchema,
      dataRecord: publishedData,
      timestamp: generateTimestamp()
    };
  }

  public async fetchRecord(cid: string, scope: Scope): Promise<PipeRecord | null> {
    await this.initialized;
    const record = await this.ipfs.fetch(cid, scope);
    if (!record) return null;

    if (record.encryption?.enabled && record.encryption?.ciphertext) {
      const decrypted = await this.encryption.decrypt(
        record.content,
        record.encryption.method || 'AES-GCM',
        record.encryption.keyRef || 'defaultKey',
        process.env.NODE_ENV === 'test'
      );
      
      // Parse content based on the original content type
      if (record.encryption.contentType === 'json') {
        try {
          record.content = JSON.parse(decrypted);
        } catch (error) {
          console.error('Failed to parse decrypted JSON:', error);
          throw new Error('Failed to parse decrypted content as JSON');
        }
      } else {
        record.content = decrypted;
      }
      
      record.encryption = {
        ...record.encryption,
        enabled: true,
        ciphertext: false
      };
    } else if (typeof record.content === 'string' && !record.encryption?.contentType) {
      // Only try to parse non-encrypted content as JSON if it's not explicitly marked as a string
      try {
        record.content = JSON.parse(record.content);
      } catch {
        // Keep content as is if it's not valid JSON
      }
    }

    return record;
  }

  // IPFS Node Management Methods
  public async stop() {
    await this.initialized;
    await this.ipfs.stop();
  }

  public async getStatus() {
    await this.initialized;
    return this.ipfs.getStatus();
  }

  public async getNodeInfo(scope: Scope) {
    await this.initialized;
    return this.ipfs.getNodeInfo(scope);
  }

  public async getStorageMetrics(scope: Scope) {
    await this.initialized;
    return this.ipfs.getStorageMetrics(scope);
  }

  public async getPinnedCids(scope: Scope) {
    await this.initialized;
    return this.ipfs.getPinnedCids(scope);
  }

  public async getConfiguration(scope: Scope) {
    await this.initialized;
    return this.ipfs.getConfiguration(scope);
  }

  // Pin Management Methods
  public async pin(cid: string, scope: Scope): Promise<void> {
    await this.initialized;
    return this.ipfs.pin(cid, scope);
  }

  public async unpin(cid: string, scope: Scope): Promise<void> {
    await this.initialized;
    return this.ipfs.unpin(cid, scope);
  }

  public async replicate(cid: string, fromScope: Scope, toScope: Scope): Promise<void> {
    await this.initialized;
    return this.ipfs.replicate(cid, fromScope, toScope);
  }

  // Tool Wrapping Methods
  wrap(tools: Tool[]): any[] {
    return tools.map(tool => this.wrapTool(tool));
  }

  private wrapTool(tool: Tool) {
    return {
      originalTool: tool,
      wrappedDefinition: {
        ...tool,
        parameters: this.enhanceParameters(tool.parameters),
        returns: this.getReturnSchema()
      },
      execute: async (args: any) => {
        this.currentTool = tool.name;
        
        // Execute original tool
        const result = await tool.call(args);

        // Process hooks
        const metadata = { tool: tool.name, timestamp: generateTimestamp() };
        const processed = await this.processHooks('pre-store', result, metadata);
    
        // Store in IPFS
        const options = args?.pipeOptions || {};
        const { cid, schemaCid } = await this.storeData(processed, options);

        // Post-store hooks
        await this.processHooks('post-store', { cid, data: processed }, metadata);
       
        return {
          cid,
          schemaCid,
          description: tool.description,
          type: tool.returns?.type || typeof result,
          metadata
        };
      }
    };
  }

  private enhanceParameters(originalParams: any) {
    return {
      ...originalParams,
      properties: {
        ...originalParams.properties,
        pipeOptions: {
          type: 'object',
          properties: {
            scope: {
              type: 'string',
              enum: ['private', 'public', 'machine', 'user'],
              default: 'private'
            },
            storeResult: {
              type: 'boolean',
              default: true
            },
            generateSchema: {
              type: 'boolean',
              default: true
            },
            pin: {
              type: 'boolean',
              default: true
            }
          }
        }
      }
    };
  }

  private getReturnSchema(): any {
    return {
      type: 'object',
      properties: {
        cid: { type: 'string', description: 'IPFS Content Identifier' },
        schemaCid: { type: 'string', description: 'CID for JSON schema of returned data' },
        description: { type: 'string' },
        type: { type: 'string' },
        metadata: { type: 'object' }
      }
    };
  }
}

// Example Summary Hook
export const summaryHook: PipeHook = {
  name: 'data-summarizer',
  trigger: 'pre-store',
  async handler(data: any, metadata: any) {
    const summary = await generateSummary(data);
    return {
      ...data,
      metadata: {
        ...metadata,
        summary
      }
    };
  }
};

================
File: src/schema.ts
================
import { z } from 'zod';
import { AccessPolicy, EncryptionInfo, PipeRecord, PipeBundle } from './types';

const EncryptionSchema: z.ZodSchema<EncryptionInfo> = z.object({
  enabled: z.boolean(),
  method: z.string().optional(),
  keyRef: z.string().optional(),
  nonce: z.string().optional(),
  ciphertext: z.boolean().optional(),
});

const AccessPolicySchema: z.ZodSchema<AccessPolicy> = z.object({
  hiddenFromLLM: z.boolean(),
  allowedTools: z.array(z.string()).optional(),
  allowedUsers: z.array(z.string()).optional()
});

const PipeRecordSchema = z.object({
  cid: z.string().optional(),
  content: z.any(),
  type: z.enum(['data', 'schema']),
  scope: z.enum(['private', 'public', 'machine', 'user']),
  accessPolicy: AccessPolicySchema,
  encryption: z.object({
    enabled: z.boolean(),
    method: z.string().optional(),
    keyRef: z.string().optional(),
    ciphertext: z.boolean().optional()
  })
});

const PipeBundleSchema = z.object({
  schemaRecord: PipeRecordSchema,
  dataRecord: PipeRecordSchema,
  timestamp: z.string().optional()
});

export { AccessPolicySchema, PipeRecordSchema, PipeBundleSchema };

================
File: src/types.ts
================
export interface EncryptionInfo {
  enabled: boolean;
  method?: string;
  keyRef?: string;
  nonce?: string;
  ciphertext?: boolean;
  contentType?: 'string' | 'json';
}

export interface AccessPolicy {
  hiddenFromLLM: boolean;
  allowedTools?: string[];
  allowedUsers?: string[];
}

export type Scope = 'private' | 'public' | 'machine' | 'user';

export interface PipeRecord {
  cid?: string;
  content: any;
  type: 'data' | 'schema';
  scope: Scope;
  accessPolicy: AccessPolicy;
  encryption: EncryptionInfo;
}

export interface PipeBundle {
  schemaRecord: PipeRecord;
  dataRecord: PipeRecord;
  timestamp?: string;
}

export interface PipeOptions {
  localNodeEndpoint?: string;
  publicNodeEndpoint?: string;
  hooks?: PipeHook[];
}

export interface PipeIpfsOptions {
  endpoint?: string;
  options?: Record<string, any>;
  localNodeEndpoint?: string;
  publicNodeEndpoint?: string;
}

export interface PipeHook {
  name: string;
  trigger: 'pre-store' | 'post-store';
  handler: (data: any, metadata: Record<string, any>) => Promise<any>;
}

export interface StoreOptions {
  scope?: Scope;
  generateSchema?: boolean;
  pin?: boolean;
}

export interface Tool {
  name: string;
  description: string;
  parameters: {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
  };
  returns?: {
    type: string;
    description?: string;
  };
  call: (args: any) => Promise<any>;
}

export interface IpfsNodeConfig {
  endpoint?: string;
  options?: Record<string, any>;
}

================
File: .eslintrc.json
================
{
  "env": {
    "node": true,
    "es2020": true,
    "jest": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2020,
    "sourceType": "module"
  },
  "plugins": [
    "@typescript-eslint"
  ],
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "semi": ["error", "always"],
    "quotes": ["error", "single"],
    "indent": ["error", 2],
    "comma-dangle": ["error", "never"],
    "object-curly-spacing": ["error", "always"]
  }
}

================
File: .gitignore
================
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build output
dist/
build/
*.tsbuildinfo

# Test coverage
coverage/

# IDE and editor files
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Environment variables
.env
.env.local
.env.*.local

# Logs
logs/
*.log

# Temporary files
*.tmp
*.temp
.cache/

================
File: jest.config.ts
================
import type { Config } from '@jest/types';

const config: Config.InitialOptions = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.test.ts'],
  setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts'],
  moduleNameMapper: {
    '^ipfs-http-client$': '<rootDir>/src/__tests__/mocks/ipfs-http-client.ts'
  },
  transform: {
    '^.+\\.ts$': ['ts-jest', {
      tsconfig: 'tsconfig.json',
      useESM: true
    }]
  },
  moduleFileExtensions: ['ts', 'js', 'json', 'node'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};

export default config;

================
File: jest.setup.cjs
================
const { TextEncoder, TextDecoder } = require('util');
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;

jest.mock('helia', () => ({
  createHelia: jest.fn().mockResolvedValue({
    blockstore: {
      put: jest.fn(),
      get: jest.fn()
    },
    stop: jest.fn()
  }),
  Helia: jest.fn()
}));

jest.mock('multiformats/cid', () => ({
  CID: {
    parse: jest.fn(),
    create: jest.fn()
  }
}));

jest.mock('multiformats/codecs/raw', () => ({
  code: 0x55,
  encode: jest.fn(),
  decode: jest.fn()
}));

jest.mock('multiformats/hashes/sha2', () => ({
  sha256: {
    code: 0x12,
    digest: jest.fn()
  }
}));

jest.mock('blockstore-core', () => ({
  MemoryBlockstore: jest.fn().mockImplementation(() => ({
    put: jest.fn(),
    get: jest.fn(),
    has: jest.fn(),
    delete: jest.fn()
  }))
}));

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Pipe Protocol Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "pipe-protocol",
  "version": "0.1.0",
  "description": "A protocol for wrapping LLM tools with IPFS storage and encryption",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "clean": "rimraf dist coverage",
    "prepare": "npm run build",
    "test:llm-wrapping": "bun run scripts/test-llm-wrapping.ts"
  },
  "dependencies": {
    "blockstore-core": "^5.0.0",
    "dotenv": "^16.0.0",
    "express": "^4.18.2",
    "ipfs-http-client": "^60.0.0",
    "multiformats": "^12.0.1",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.4",
    "@types/node": "^20.5.9",
    "@typescript-eslint/eslint-plugin": "^6.6.0",
    "@typescript-eslint/parser": "^6.6.0",
    "eslint": "^8.48.0",
    "jest": "^29.6.4",
    "rimraf": "^5.0.1",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.1",
    "typescript": "^5.2.2"
  },
  "engines": {
    "node": ">=16.0.0"
  },
  "keywords": [
    "ipfs",
    "encryption",
    "llm",
    "tools",
    "protocol"
  ],
  "author": "",
  "license": "MIT"
}

================
File: README.md
================
# Pipe Protocol

A protocol for wrapping LLM tools with IPFS storage and encryption capabilities.

## Features

- Store tool inputs and outputs on IPFS
- Automatic schema generation for stored data
- End-to-end encryption support
- Multiple storage scopes (private, public, machine, user)
- Pre and post-store hooks for data processing
- Tool wrapping with enhanced capabilities

## Installation

```bash
npm install pipe-protocol
```

## Quick Start

```typescript
import { PipeProtocol } from 'pipe-protocol';

// Initialize the protocol
const pipe = new PipeProtocol();

// Wrap your existing tools
const tools = pipe.wrap([
  {
    name: 'myTool',
    description: 'A sample tool',
    parameters: {
      type: 'object',
      properties: {
        input: { type: 'string' }
      }
    },
    call: async (args) => {
      return { result: args.input };
    }
  }
]);

// Use the wrapped tool
const result = await tools[0].execute({
  input: 'test',
  pipeOptions: {
    scope: 'private',
    generateSchema: true,
    pin: true
  }
});

console.log(result);
// {
//   cid: 'Qm...',
//   schemaCid: 'Qm...',
//   description: 'A sample tool',
//   type: 'object',
//   metadata: { ... }
// }
```

## Storage Scopes

- `private`: Data stored locally, not shared
- `public`: Data stored on public IPFS network
- `machine`: Data stored locally, shared between processes
- `user`: Data stored locally, shared between users

## Encryption

Data can be encrypted before storage:

```typescript
const record = {
  content: { sensitive: 'data' },
  type: 'data',
  scope: 'private',
  accessPolicy: { hiddenFromLLM: false },
  encryption: { enabled: true }
};

const published = await pipe.publishRecord(record);
```

## Hooks

Add pre and post-store processing:

```typescript
pipe.addHook({
  name: 'summarizer',
  trigger: 'pre-store',
  handler: async (data, metadata) => {
    return {
      ...data,
      summary: generateSummary(data)
    };
  }
});
```

## Development

```bash
# Install dependencies
npm install

# Run tests
npm test

# Build
npm run build

# Lint
npm run lint
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "ES2020",
    "lib": ["ES2020", "DOM"],
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",
    "moduleResolution": "node",
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    "resolveJsonModule": true,
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    "allowJs": true,
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    "declaration": true,
    "declarationMap": true,
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    "sourceMap": true,
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist",
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    "isolatedModules": true,
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    "allowSyntheticDefaultImports": true,
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,

    /* Type Checking */
    "strict": true,
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true,
    "rootDir": "."
  },
  "ts-node": {
    "esm": true,
    "experimentalSpecifierResolution": "node"
  },
  "include": ["src/**/*", "scripts/**/*"],
  "exclude": ["node_modules", "dist", "src/**/*.test.ts"]
}

================
File: tsconfig.scripts.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist-scripts",
    "rootDir": "."
  },
  "ts-node": {
    "esm": true,
    "experimentalSpecifierResolution": "node"
  },
  "include": ["scripts/**/*", "src/**/*"],
  "exclude": ["node_modules", "dist"]
}
